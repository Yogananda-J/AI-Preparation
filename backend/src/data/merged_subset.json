{
  "questions": [
    {
      "title": "Two Sum",
      "problem_id": "1",
      "frontend_id": "1",
      "difficulty": "Easy",
      "problem_slug": "two-sum",
      "topics": [
        "Array",
        "Hash Table"
      ],
      "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [3,2,4], target = 6\nOutput: [1,2]",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: nums = [3,3], target = 6\nOutput: [0,1]",
          "images": []
        }
      ],
      "constraints": [
        "2 <= nums.length <= 104",
        "-109 <= nums[i] <= 109",
        "-109 <= target <= 109",
        "Only one valid answer exists."
      ],
      "follow_ups": [],
      "hints": [
        "A really brute force way would be to search for all possible pairs of numbers but that would be too slow. Again, it's best to try out brute force solutions for just for completeness. It is from these brute force solutions that you can come up with optimizations.",
        "So, if we fix one of the numbers, say <code>x</code>, we have to scan the entire array to find the next number <code>y</code> which is <code>value - x</code> where value is the input parameter. Can we change our array somehow so that this search becomes faster?",
        "The second train of thought is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n    }\n};",
        "java": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        ",
        "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* twoSum(int* nums, int numsSize, int target, int* returnSize) {\n    \n}",
        "csharp": "public class Solution {\n    public int[] TwoSum(int[] nums, int target) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    \n};",
        "typescript": "function twoSum(nums: number[], target: number): number[] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer[]\n     */\n    function twoSum($nums, $target) {\n        \n    }\n}",
        "swift": "class Solution {\n    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun twoSum(nums: IntArray, target: Int): IntArray {\n        \n    }\n}",
        "dart": "class Solution {\n  List<int> twoSum(List<int> nums, int target) {\n    \n  }\n}",
        "golang": "func twoSum(nums []int, target int) []int {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer[]}\ndef two_sum(nums, target)\n    \nend",
        "scala": "object Solution {\n    def twoSum(nums: Array[Int], target: Int): Array[Int] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {\n        \n    }\n}",
        "racket": "(define/contract (two-sum nums target)\n  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))\n  )",
        "erlang": "-spec two_sum(Nums :: [integer()], Target :: integer()) -> [integer()].\ntwo_sum(Nums, Target) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec two_sum(nums :: [integer], target :: integer) :: [integer]\n  def two_sum(nums, target) do\n    \n  end\nend"
      },
      "solution": "[TOC]\n\n## Video Solution\n\n---## Solution Article\n\n---\n\n### Approach 1: Brute Force\n\n**Algorithm**\n\nThe brute force approach is simple. Loop through each element $$x$$ and find if there is another value that equals to $$target - x$$.\n\n**Implementation****Complexity Analysis**\n\n* Time complexity: $$O(n^2)$$.\nFor each element, we try to find its complement by looping through the rest of the array which takes $$O(n)$$ time. Therefore, the time complexity is $$O(n^2)$$.\n\n* Space complexity: $$O(1)$$.\nThe space required does not depend on the size of the input array, so only constant space is used.\n\n---\n### Approach 2: Two-pass Hash Table\n\n**Intuition**\n\nTo improve our runtime complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to get its index. What is the best way to maintain a mapping of each element in the array to its index? A hash table.\n\nWe can reduce the lookup time from $$O(n)$$ to $$O(1)$$ by trading space for speed. A hash table is well suited for this purpose because it supports fast lookup in *near* constant time. I say \"near\" because if a collision occurred, a lookup could degenerate to $$O(n)$$ time. However, lookup in a hash table should be amortized $$O(1)$$ time as long as the hash function was chosen carefully.\n\n**Algorithm**\n\nA simple implementation uses two iterations. In the first iteration, we add each element's value as a key and its index as a value to the hash table. Then, in the second iteration, we check if each element's complement ($$target - nums[i]$$) exists in the hash table. If it does exist, we return current element's index and its complement's index. Beware that the complement must not be $$nums[i]$$ itself!\n\n**Implementation****Complexity Analysis**\n\n* Time complexity: $$O(n)$$.\nWe traverse the list containing $$n$$ elements exactly twice. Since the hash table reduces the lookup time to $$O(1)$$, the overall time complexity is $$O(n)$$.\n\n* Space complexity: $$O(n)$$.\nThe extra space required depends on the number of items stored in the hash table, which stores exactly $$n$$ elements.\n\n---\n### Approach 3: One-pass Hash Table\n\n**Algorithm**\n    \nIt turns out we can do it in one-pass. While we are iterating and inserting elements into the hash table, we also look back to check if current element's complement already exists in the hash table. If it exists, we have found a solution and return the indices immediately.\n\n**Implementation****Complexity Analysis**\n\n* Time complexity: $$O(n)$$.\nWe traverse the list containing $$n$$ elements only once. Each lookup in the table costs only $$O(1)$$ time.\n\n* Space complexity: $$O(n)$$.\nThe extra space required depends on the number of items stored in the hash table, which stores at most $$n$$ elements."
    },
    {
      "title": "Add Two Numbers",
      "problem_id": "2",
      "frontend_id": "2",
      "difficulty": "Medium",
      "problem_slug": "add-two-numbers",
      "topics": [
        "Linked List",
        "Math",
        "Recursion"
      ],
      "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.",
          "images": [
            "https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: l1 = [0], l2 = [0]\nOutput: [0]",
          "images": [
            "https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg"
          ]
        },
        {
          "example_num": 3,
          "example_text": "Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]",
          "images": [
            "https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg"
          ]
        }
      ],
      "constraints": [
        "The number of nodes in each linked list is in the range [1, 100].",
        "0 <= Node.val <= 9",
        "It is guaranteed that the list represents a number that does not have leading zeros."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        \n    }\n};",
        "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        \n    }\n}",
        "python": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: Optional[ListNode]\n        :type l2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        ",
        "python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        ",
        "c": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {\n    \n}",
        "csharp": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\n        \n    }\n}",
        "javascript": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function(l1, l2) {\n    \n};",
        "typescript": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n    \n};",
        "php": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $l1\n     * @param ListNode $l2\n     * @return ListNode\n     */\n    function addTwoNumbers($l1, $l2) {\n        \n    }\n}",
        "swift": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\n        \n    }\n}",
        "kotlin": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun addTwoNumbers(l1: ListNode?, l2: ListNode?): ListNode? {\n        \n    }\n}",
        "dart": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? addTwoNumbers(ListNode? l1, ListNode? l2) {\n    \n  }\n}",
        "golang": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n    \n}",
        "ruby": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} l1\n# @param {ListNode} l2\n# @return {ListNode}\ndef add_two_numbers(l1, l2)\n    \nend",
        "scala": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = {\n        \n    }\n}",
        "rust": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn add_two_numbers(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        \n    }\n}",
        "racket": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (add-two-numbers l1 l2)\n  (-> (or/c list-node? #f) (or/c list-node? #f) (or/c list-node? #f))\n  )",
        "erlang": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec add_two_numbers(L1 :: #list_node{} | null, L2 :: #list_node{} | null) -> #list_node{} | null.\nadd_two_numbers(L1, L2) ->\n  .",
        "elixir": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec add_two_numbers(l1 :: ListNode.t | nil, l2 :: ListNode.t | nil) :: ListNode.t | nil\n  def add_two_numbers(l1, l2) do\n    \n  end\nend"
      },
      "solution": "## Video Solution\n---## Solution Article\n\n---\n\n### Approach 1: Elementary Math\n\n**Intuition**\n\nKeep track of the carry using a variable and simulate digits-by-digits sum starting from the head of list, which contains the least-significant digit.\n\n![Illustration of Adding two numbers](../Figures/2_add_two_numbers.svg){:width=\"539px\"}\n\n\n*Figure 1. Visualization of the addition of two numbers: $$342 + 465 = 807$$.  \nEach node contains a single digit and the digits are stored in reverse order.*\n\n\n**Algorithm**\n\nJust like how you would sum two numbers on a piece of paper, we begin by summing the least-significant digits, which is the head of $$l1$$ and $$l2$$. Since each digit is in the range of $$0 \\ldots 9$$, summing two digits may \"overflow\". For example $$5 + 7 = 12$$. In this case, we set the current digit to $$2$$ and bring over the $$carry = 1$$ to the next iteration. $$carry$$ must be either $$0$$ or $$1$$ because the largest possible sum of two digits (including the carry) is $$9 + 9 + 1 = 19$$.\n\nThe pseudocode is as following:\n\n* Initialize current node to dummy head of the returning list.\n* Initialize carry to $$0$$.\n* Loop through lists $$l1$$ and $$l2$$ until you reach both ends and carry is $$0$$.\n    * Set $$x$$ to node $$l1$$'s value. If $$l1$$ has reached the end of $$l1$$, set to $$0$$.\n    * Set $$y$$ to node $$l2$$'s value. If $$l2$$ has reached the end of $$l2$$, set to $$0$$.\n    * Set $$sum = x + y + carry$$.\n    * Update $$carry = sum / 10$$.\n    * Create a new node with the digit value of $$(sum \\bmod 10)$$ and set it to current node's next, then advance current node to next.\n    * Advance both $$l1$$ and $$l2$$.\n* Return dummy head's next node.\n\nNote that we use a dummy head to simplify the code. Without a dummy head, you would have to write extra conditional statements to initialize the head's value.\n\nTake extra caution of the following cases:\n\n| Test case | Explanation |\n| ------------- | ---------------- |\n| $$l1=[0,1]$$$$l2=[0,1,2]$$ | When one list is longer than the other. |\n| $$l1=[]$$$$l2=[0,1]$$ | When one list is null, which means an empty list. |\n| $$l1=[9,9]$$$$l2=[1]$$ | The sum could have an extra carry of one at the end, which is easy to forget. |\n\n**Implementation****Complexity Analysis**\n\n* Time complexity : $$O(\\max(m, n))$$. Assume that $$m$$ and $$n$$ represents the length of $$l1$$ and $$l2$$ respectively, the algorithm above iterates at most $$\\max(m, n)$$ times.\n\n* Space complexity : $$O(1)$$. The length of the new list is at most $$\\max(m,n) + 1$$ However, we don't count the answer as part of the space complexity.\n\n**Follow up**\n\nWhat if the the digits in the linked list are stored in non-reversed order? For example:\n\n$$\n(3 \\to 4 \\to 2) + (4 \\to 6 \\to 5) = 8 \\to 0 \\to 7\n$$"
    },
    {
      "title": "Longest Substring Without Repeating Characters",
      "problem_id": "3",
      "frontend_id": "3",
      "difficulty": "Medium",
      "problem_slug": "longest-substring-without-repeating-characters",
      "topics": [
        "Hash Table",
        "String",
        "Sliding Window"
      ],
      "description": "Given a string s, find the length of the longest substring without duplicate characters.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.",
          "images": []
        }
      ],
      "constraints": [
        "0 <= s.length <= 5 * 104",
        "s consists of English letters, digits, symbols and spaces."
      ],
      "follow_ups": [],
      "hints": [
        "Generate all possible substrings & check for each substring if it's valid and keep updating maxLen accordingly."
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        \n    }\n};",
        "java": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        ",
        "c": "int lengthOfLongestSubstring(char* s) {\n    \n}",
        "csharp": "public class Solution {\n    public int LengthOfLongestSubstring(string s) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    \n};",
        "typescript": "function lengthOfLongestSubstring(s: string): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function lengthOfLongestSubstring($s) {\n        \n    }\n}",
        "swift": "class Solution {\n    func lengthOfLongestSubstring(_ s: String) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun lengthOfLongestSubstring(s: String): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int lengthOfLongestSubstring(String s) {\n    \n  }\n}",
        "golang": "func lengthOfLongestSubstring(s string) int {\n    \n}",
        "ruby": "# @param {String} s\n# @return {Integer}\ndef length_of_longest_substring(s)\n    \nend",
        "scala": "object Solution {\n    def lengthOfLongestSubstring(s: String): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn length_of_longest_substring(s: String) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (length-of-longest-substring s)\n  (-> string? exact-integer?)\n  )",
        "erlang": "-spec length_of_longest_substring(S :: unicode:unicode_binary()) -> integer().\nlength_of_longest_substring(S) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec length_of_longest_substring(s :: String.t) :: integer\n  def length_of_longest_substring(s) do\n    \n  end\nend"
      }
    },
    {
      "title": "Median of Two Sorted Arrays",
      "problem_id": "4",
      "frontend_id": "4",
      "difficulty": "Hard",
      "problem_slug": "median-of-two-sorted-arrays",
      "topics": [
        "Array",
        "Binary Search",
        "Divide and Conquer"
      ],
      "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.",
          "images": []
        }
      ],
      "constraints": [
        "nums1.length == m",
        "nums2.length == n",
        "0 <= m <= 1000",
        "0 <= n <= 1000",
        "1 <= m + n <= 2000",
        "-106 <= nums1[i], nums2[i] <= 106"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n    }\n};",
        "java": "class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        ",
        "c": "double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) {\n    \n}",
        "csharp": "public class Solution {\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar findMedianSortedArrays = function(nums1, nums2) {\n    \n};",
        "typescript": "function findMedianSortedArrays(nums1: number[], nums2: number[]): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @return Float\n     */\n    function findMedianSortedArrays($nums1, $nums2) {\n        \n    }\n}",
        "swift": "class Solution {\n    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double {\n        \n    }\n}",
        "dart": "class Solution {\n  double findMedianSortedArrays(List<int> nums1, List<int> nums2) {\n    \n  }\n}",
        "golang": "func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\n    \n}",
        "ruby": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @return {Float}\ndef find_median_sorted_arrays(nums1, nums2)\n    \nend",
        "scala": "object Solution {\n    def findMedianSortedArrays(nums1: Array[Int], nums2: Array[Int]): Double = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {\n        \n    }\n}",
        "racket": "(define/contract (find-median-sorted-arrays nums1 nums2)\n  (-> (listof exact-integer?) (listof exact-integer?) flonum?)\n  )",
        "erlang": "-spec find_median_sorted_arrays(Nums1 :: [integer()], Nums2 :: [integer()]) -> float().\nfind_median_sorted_arrays(Nums1, Nums2) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec find_median_sorted_arrays(nums1 :: [integer], nums2 :: [integer]) :: float\n  def find_median_sorted_arrays(nums1, nums2) do\n    \n  end\nend"
      },
      "solution": "[TOC]\n\n## Video Solution\n\n---## Solution\n\n--- \n\n### Overview\n\nIn this problem, we are given two **sorted** arrays, `nums1` and `nums2`. We need to return the **median** of these two arrays.\n\n---\n\n### Approach 1: Merge Sort\n\n#### Intuition   \n\nLet's start with the straightforward approach. If we put the elements of two arrays in one array `A` and arrange them in order. Assume the merged arrays has a length of `n`, then the median is:\n    - `A[n / 2]`, if `n` is odd.\n    - The average of `A[n / 2]` and `A[n / 2 + 1]`, if `n` is even.\n\nHowever, we do not really need to merge and sort these arrays. Note that both arrays are already sorted, so the smallest element is either the first element of `nums1` or the first element of `nums2`. Therefore, we can set two pointers `p1` and `p2` at the start of each array, then we can get the smallest element from the `nums1` and `nums2` by comparing the values `nums1[p1]` and `nums2[p2]`.\n\nPlease refer to the following slide as an example:\n\n!?!../Documents/4/s1.json:601,301!?!#### Algorithm\n\n1) Get the total size of two arrays `m + n`\n    - If `m + n` is odd, we are looking for the `(m + n) / 2`-th element.\n    - If `m + n` is even, we are looking for the average of the `(m + n) / 2`-th and the `(m + n) / 2 + 1`-th elements.\n2) Set two pointers `p1` and `p2` at the beginning of arrays `nums1` and `nums2`. \n3) If both `p1` and `p2` are in bounds of the arrays, compare the values at `p1` and `p2`:\n\n    - If `nums1[p1]` is smaller than `nums2[p2]`, we move `p1` one place to the right.\n    - Otherwise, we move `p2` one place to the right.\n\n    If `p1` is outside `nums1`, just move `p2` one place to the right.     \n    If `p2` is outside `nums2`, just move `p1` one place to the right.\n4) Get the target elements and calculate the median:\n    - If `m + n` is odd, repeat step 3 by `(m + n + 1) / 2` times and return the element from the last step.\n    - If `m + n` is even, repeat step 3 by `(m + n) / 2 + 1` times and return the average of the elements from the last two steps.\n\n\n\n#### Implementation#### Complexity Analysis\n\nLet $$m$$ be the size of array `nums1` and $$n$$ be the size of array `nums2`.\n\n* Time complexity: $$O(m + n)$$\n\n    - We get the smallest element by comparing two values at `p1` and `p2`, it takes $$O(1)$$ to compare two elements and move the corresponding pointer to the right.\n    - We need to traverse half of the arrays before reaching the median element(s).\n    - To sum up, the time complexity is $$O(m + n)$$.\n    \n\n* Space complexity: $$O(1)$$\n\n    - We only need to maintain two pointers `p1` and `p2`.---\n\n### Approach 2: Binary Search, Recursive\n\n#### Intuition   \n\nBecause the inputs are sorted arrays and the problem asks for a logarithmic time limit, we strongly feel that binary search (or a similar approach) is a promising method. While we're not sure how to cast the same pattern as a normal binary search on this problem, let's go over some steps of a regular binary search and see if we can get any inspiration. (If you are not familiar with binary search, you can refer to our [Binary Search Explore Card](https://leetcode.com/explore/learn/card/binary-search/))\n\n\nHere we use binary search to find `target` in a sorted array `A`:\n\n- Locate the middle index (element) of `A`.\n- Compare the value of the middle element with `target`.\n- Reduce the search space by cutting the current array in half and discarding the half which is guaranteed not to contain `target`.\n\n- Repeat the above process until we either empty the array (move to half a the length of 0) or find `target`.\n\n\n\n![img](../Figures/4/bs.png)\n\nAt each step, the search space is cut in half, so we can quickly get the result. Now back to this problem where we have two sorted arrays. For the sake of convenience, let's call them `A` and `B`. \n\n![img](../Figures/4/2.png)\n\nSimilarly, we can get and compare their middle values `A_mid` and `B_mid`. Without loss of generality in this example we assume `A_mid <= B_mid` initially, as shown in the yellow boxes. \n\n\n\n![img](../Figures/4/3.png)\n\n**What does this comparison imply?**\n\nIt implies that we can compare sections of `A` and `B`.\n\n> For the rest of this article, we will use $$\\le$$ to represent the relative magnitude of values in arrays. For example, $$A_{\\text{left}} \\le A_{\\text{right}}$$ means that every element in $A_{\\text{left}}$ is no larger than any element in $A_{\\text{right}}$. We also 'compare' elements in an array with a single element similarly, for example, $$A_{\\text{left}} \\le A_{\\text{mid}}$$ means that every element in $A_{\\text{left}}$ is no larger than the element $A_{\\text{mid}}$. \nThis may not be the most standard way of expressing it, but is easy enough to understand.\n\nRecall that both arrays are sorted, so we know that:\n- $$A_{\\text{left}} \\le A_{\\text{mid}}$$\n- $$B_{\\text{mid}} \\le B_{\\text{right}}$$\n\nCombine these observations with the comparison we just made:\n\n\n$$A_{\\text{mid}} \\le B_{\\text{mid}}$$\n\nWe have the following result:\n\n$$A_{\\text{left}} \\le A_{\\text{mid}} \\le B_{\\text{mid}} \\le B_{\\text{right}}$$\n\nThus, \n\n$$A_{\\text{left}} \\le B_{\\text{right}}$$\n\nAs shown in the picture below:\n\n![img](../Figures/4/4.png)\n\nSince `A` is sorted, we know that $$A_{\\text{left}} \\le A_{\\text{right}}$$.\n\n![img](../Figures/4/5.png)\n\n\nNow we know that `A_left` is smaller than two halves: `A_right` and `B_right`. Although we still don't know where exactly these elements are, what we do know is **`A_left` doesn't intersect with `A_right + B_right`**! There is an invisible boundary between the `A_left` segment and the mixed segment `A_right + B_right`. As shown in the picture below, the dashed line divides all sorted elements into two halves.\n\n\n\n![img](../Figures/4/6.png)\n\n\nWe can apply all the same logic to the mixed segment $$A_{\\text{left}}$$ + $$B_{\\text{left}}$$ and $$B_{\\text{right}}$$, which also do not intersect. You can try to prove it yourself as an exercise.\n\n\n![img](../Figures/4/7.png)\n\n\nIt looks somewhat clearer, we have clearly separated some subarrays. How do we continue to leverage this knowledge and use the cut-in-half method repeatedly?**The following step is the most important one.**\n\n\nRemember that we are looking for the median of `sorted A + B` which is one or two target values. We regard the index of the target value in the `sorted(A + B)` as `k`. For example: \n\n- If the lengths of `A` and `B` are `6` and `5`, the target index is `k = (6 + 5 + 1) / 2 = 6`, we shall look for the 6th smallest element. \n\n- If the lengths of `A` and `B` are `6` and `6`, the target indexes are `k = (6 + 6) / 2 = 6` and `k + 1 = 7`, we shall look for the 6th and the 7th smallest elements. \n\n\n\nDepending on whether the total number of elements is odd or even, we need the $$k^{th}$$ (and maybe the $$(k + 1)^{th}$$) elements. What matters is that we set an index `k` at the beginning and we want to find the $$k^{th}$$ smallest element using the Binary Search-like algorithm discussed previously (for convenience, we will discuss only the $$k^{th}$$ element for now).\n\n\n\nHowever, during the Binary Search-like algorithm, we keep removing one half of an array, so the index `k` might not stay unchanged. Suppose we removed `3` elements that are smaller than the original $$k^{th}$$ smallest element, we shall look for the $$(k-3)^{th}$$ smallest element from the **remaining** arrays.\n\n\n![img](../Figures/4/exp_1.png)\n\nMore specifically:\n\nIf `k` is larger than half the total number of elements in `sorted(A + B)`, it means that the $$k^{th}$$ element is in the second (larger) half of `sorted(A + B)`, thus $$A_{\\text{left}}$$ (or $$B_{\\text{left}}$$, the smaller of the two smaller sections according to the comparison) is guaranteed not to contain this element, and we can safely cut this half, and reduce `k` by the length of the removed half.\n\n\nIf `k` is not larger than half the total number of elements in `sorted(A + B)`, it means that the $$k^{th}$$ element is in the first (smaller) half of `sorted(A + B)`, thus $$B_{\\text{right}}$$ (or $$A_{\\text{right}}$$, the larger of the two larger sections according to the comparison) is guaranteed not to contain this element, and we can safely discard it. Note that we don't need to modify `k` this time, since we removed one larger half that doesn't affect the order of the $$k^{th}$$ smallest element.\n\n\n\nWe can continue our search like above in the **remaining** arrays. The long arrow that starts from the bottom and points to the top-left indicates that we are repeating the process. Once we cut off part of either `A` or `B`, we regard the remaining arrays as modified `A` and `B` and restart this algorithm. Note that the following picture represents one case only: we consider the case that `a_value < b_value`, thus we remove either the smaller half of `A` or the larger half of `B`. If the comparison result is `a_value >= b_value`, we shall remove either the smaller half of `B` or the larger half of `A`.\n\n![img](../Figures/4/9.png)\n\n\nThat's it. We cut one of the two arrays in half at each step, so this approach has a logarithmic time complexity which we will discuss in detail later.\n\n\n> One more thing!\n\nIn the previous picture, we repeat all processes using the modified arrays, but this is just for the sake of understanding. We won't create copies of two arrays repeatedly, because that would introduce a linear time complexity at least. Instead, we just treat a part of the original array as the modified array for the next step, so that we can repeat the process on the original array without making any duplication. To do this, we need to maintain four pointers, two pointers for each array, e.g., `a_start` and `a_end` represent an inclusive range `[a_start, a_end]` of `A`.#### Algorithm\n\nLet's define a function that helps us find the $$k^{th}$$ smallest element from two inclusive ranges `[a_start, a_end]` and `[b_start, b_end]` from arrays `A` and `B`.\n\n\n\n1) If the range (for example, a range of `A`) is empty, in other words `a_start > a_end`, it means all elements in `A` are passed, we just return the `(k - a_start)`-th element from the other array `B`. Vice versa if `b_start > b_end`.\n\n2) Otherwise, get the middle indexes of the two ranges: `a_index = (a_start + a_end) / 2`, `b_index = (b_start + b_end) / 2`.\n3) Get the middle values of the two ranges: `a_value = A[a_index]`, `b_value = B[b_index]`.\n4) Cut one array in half, according to:\n    - If `a_index + b_index < k`, cut one smaller half.\n        - If `a_value < b_value`, cut the smaller half of `A`.\n        - Otherwise, cut the smaller half of `B`.\n    - Otherwise, cut one larger half.\n        - If `b_value < a_value`, cut the larger half of `B`.\n        - Otherwise, cut the larger half of `A`.\n5) Repeat step 1 using the new starting and ending indexes of `A` and `B`.\n\n\nThen we move on to find the median elements, and get the length of both arrays `na = len(A)` and `nb = len(B)`.\n- If the total number of elements in `A` and `B` is odd, we just use the above function to find the middle element, that is `k = (na + nb) / 2`.\n- Otherwise, we use the function to find two middle elements: `k = (na + nb) / 2 - 1` and `k = (na + nb) / 2`, and return their average.\n\n#### Implementation#### Complexity Analysis\n\nLet $$m$$ be the size of array `nums1` and $$n$$ be the size of array `nums2`.\n\n* Time complexity: $$O(\\log(m \\cdot n))$$\n\n\n    - At each step, we cut one half off from either `nums1` or `nums2`. If one of the arrays is emptied, we can directly get the target from the other array in a constant time. Therefore, the total time spent depends on when one of the arrays is cut into an empty array.\n    - In the worst-case scenario, we may need to cut both arrays before finding the target element.\n    - One of the two arrays is cut in half at each step, thus it takes logarithmic time to empty an array. The time to empty two arrays are independent of each other.![img](../Figures/4/tc.png)\n\n    - Therefore, the time complexity is $$O(\\log m + \\log n)$$.\n     $$O(\\log m + \\log n) = O(\\log (m\\cdot n))$$\n    \n\n* Space complexity: $$O(\\log m + \\log n)$$\n\n    - Similar to the analysis on time complexity, the recursion steps depend on the number of iterations before we cut an array into an empty array. In the worst-case scenario, we need $$O(\\log m + \\log n)$$ recursion steps. \n    - However, during the recursive self-call, we only need to maintain 4 pointers: `a_start`, `a_end`, `b_start` and `b_end`. The last step of the function is to call itself, so if tail call optimization is implemented, the call stack always has $$O(1)$$ records.\n\n    - Please refer to [Tail Call](https://en.wikipedia.org/wiki/Tail_call) for more information on tail call optimization.---\n\n### Approach 3: A Better Binary Search\n\n\n#### Intuition   \n\nRecall the previous approach where we perform a binary search over the 'merged' array consisting of `nums1` and `nums2`, resulting in a time complexity of $$O(\\log(m \\cdot n))$$. We could further improve the algorithm by performing the binary search only on the smaller array of `nums1` and `nums2`, thus the time complexity is reduced to $$O(\\log(\\min(m, n)))$$.\n\n\nThe main idea is similar to approach 2, where we need to find a point of partition in both arrays such that the maximum of the smaller half is less than or equal to the minimum of the larger half. \n\n\nHowever, instead of partitioning over the merged arrays, we can only focus on partitioning the smaller array (let's call this array `A`). Suppose the partition index is `partitionA`, we specify that the smaller half contains `(m + n + 1) / 2` elements, and we can use this feature to our advantage by directly making `partitionB` equal to `(m + n + 1) / 2 - partitionA`, thus the smaller halves of both arrays always contain a total of `(m + n + 1) / 2` elements, as shown in the picture below.\n\n![img](../Figures/4/2_0.png)\n\nThe next step is to compare these edge elements.\n\n![img](../Figures/4/2_1.png)\n\nIf both `maxLeftA <= minRightB` and `maxLeftB <= minRightA` hold, it means that we have partitioned arrays at the correct place. \n\n- The smaller half consists of two sections `A_left` and `B_left`\n- THe larger half consists of two sections `A_right` and `B_right`\n\nWe just need to find the maximum value from the smaller half as `max(A[maxLeftA], B[maxLeftB])` and the minimum value from the larger half as `min(A[minRightA], B[minRightB])`. The median value depends on these four boundary values and the total length of the input arrays and we can compute it by situation.\n\n![img](../Figures/4/2_2.png)\n\nIf `maxLeftA > minRightB`, it implies that `maxLeftA` is **too large to be in the smaller half** and we should look for a smaller partition value of `A`. \n\n\n![img](../Figures/4/2_3.png)\n\nOtherwise, it denotes that `minRightA` is **too small to be in the larger half** and we should look for a larger partition value of `A`.\n\n![img](../Figures/4/2_4.png)#### Algorithm\n\n1) Assuming `nums1` to be the smaller array (If `nums2` is smaller, we can swap them). Let `m, n` represent the size of `nums1` and `nums2`, respectively.\n\n2) Define the search space for the partitioning index `partitionA` by setting boundaries as `left = 0` and `right = m`.\n\n3) While `left <= right` holds, do the following.\n\n4) Compute the partition index of `nums1` as `partitionA = (left + right) / 2`. Consequently, the partition index of `nums2` is `(m + n + 1) / 2 - partitionA`.\n\n5) Obtain the edge elements:\n    - Determine the maximum value of the section `A_left` as `maxLeftA = nums1[partitionA - 1]`. If `partitionA - 1 < 0`, set it as `maxLeftA = float(-inf)`.\n    - Determine the minimum value of the section `A_right` as `minRightA = nums1[partitionA]`. If `partitionA >= m`, set it as `minRightA = float(inf)`.\n    - Determine the maximum value of the section `B_left` as `maxLeftB = nums2[partitionB - 1]`. If `partitionB - 1 < 0`, set it as `maxLeftB = float(-inf)`.\n    - Determine the maximum value of the section `B_right` as `minRightB = nums2[partitionB]`. If `partitionB >= n`, set it as `minRightB = float(inf)`.\n\n\n6) Compare and recalculate: Compare `maxLeftA` with `minRightB` and `maxLeftB` with `minRightA`. \n    - If `maxLeftA > minRightB`, it means the `maxLeftA` is too large to be in the smaller half, so we update `right = partitionA - 1` to move to the left half of the search space.\n    - If `maxLeftB > minRightA`, it means that we are too far on the left side for `partitionA` and we need to go to the right half of the search space by updating `left = partitionA + 1`. \n\n    Repeat step 4.\n\n7) When both `maxLeftA <= minRightB` and `maxLeftB <= minRightA` are true:\n    - If `(m + n) % 2 = 0`, the median value is the average of the maximum value of the smaller half and the minimum value of the larger half, given by `answer = (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2`.\n    - Otherwise, the median value is the maximum value of the smaller half, given by `answer = max(maxLeftA, maxLeftB)`.\n\n\n\n#### Implementation#### Complexity Analysis\n\nLet $$m$$ be the size of array `nums1` and $$n$$ be the size of array `nums2`.\n\n* Time complexity: $$O(\\log(\\min(m, n)))$$\n\n    - We perform a binary search over the smaller array of size $$\\min(m, n)$$.\n\n* Space complexity: $$O(1)$$\n\n    - The algorithm only requires a constant amount of additional space to store and update a few parameters during the binary search."
    },
    {
      "title": "Longest Palindromic Substring",
      "problem_id": "5",
      "frontend_id": "5",
      "difficulty": "Medium",
      "problem_slug": "longest-palindromic-substring",
      "topics": [
        "Two Pointers",
        "String",
        "Dynamic Programming"
      ],
      "description": "Given a string s, return the longest palindromic substring in s.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: s = \"cbbd\"\nOutput: \"bb\"",
          "images": []
        }
      ],
      "constraints": [
        "1 <= s.length <= 1000",
        "s consist of only digits and English letters."
      ],
      "follow_ups": [],
      "hints": [
        "How can we reuse a previously computed palindrome to compute a larger palindrome?",
        "If “aba” is a palindrome, is “xabax” a palindrome? Similarly is “xabay” a palindrome?",
        "Complexity based hint:</br>\r\nIf we use brute-force and check whether for every start and end position a substring is a palindrome we have O(n^2) start - end pairs and O(n) palindromic checks. Can we reduce the time for palindromic checks to O(1) by reusing some previous computation."
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        \n    }\n};",
        "java": "class Solution {\n    public String longestPalindrome(String s) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        ",
        "c": "char* longestPalindrome(char* s) {\n    \n}",
        "csharp": "public class Solution {\n    public string LongestPalindrome(string s) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function(s) {\n    \n};",
        "typescript": "function longestPalindrome(s: string): string {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return String\n     */\n    function longestPalindrome($s) {\n        \n    }\n}",
        "swift": "class Solution {\n    func longestPalindrome(_ s: String) -> String {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun longestPalindrome(s: String): String {\n        \n    }\n}",
        "dart": "class Solution {\n  String longestPalindrome(String s) {\n    \n  }\n}",
        "golang": "func longestPalindrome(s string) string {\n    \n}",
        "ruby": "# @param {String} s\n# @return {String}\ndef longest_palindrome(s)\n    \nend",
        "scala": "object Solution {\n    def longestPalindrome(s: String): String = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn longest_palindrome(s: String) -> String {\n        \n    }\n}",
        "racket": "(define/contract (longest-palindrome s)\n  (-> string? string?)\n  )",
        "erlang": "-spec longest_palindrome(S :: unicode:unicode_binary()) -> unicode:unicode_binary().\nlongest_palindrome(S) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec longest_palindrome(s :: String.t) :: String.t\n  def longest_palindrome(s) do\n    \n  end\nend"
      },
      "solution": "[TOC]\n\n## Video Solution\n\n---## Solution\n\n---\n\n### Approach 1: Check All Substrings\n\n**Intuition**\n\nWe can start with a brute-force approach. We will simply check if each substring is a palindrome, and take the longest one that is.\n\nFirst, let's talk about how we can check if a given string is a palindrome. This is a classic problem and we can do it using two pointers. If a string is a palindrome, the first character is equal to the last character. The second character is equal to the second last character, and so on.\n\n![Palindrome Check](../Figures/5/1.png)\n\nWe initialize two pointers: one at the start of the string and another at the end of it. We check if the characters at the pointers are equal - if they aren't, we know the string cannot be a palindrome. If they are equal, we move to the next pair of characters by moving the pointers toward each other. We continue until we either find a mismatch or the pointers meet. If the pointers meet, then we have checked all pairs and we know the string is a palindrome.\n\nOne bonus to using this algorithm is that we frequently exit early on strings that are not palindromes. If you had a string of length `1000` and the third and third last characters did not match, we would exit the algorithm after only 3 iterations.\n\nThere's another optimization that we can do. Because the problem wants the longest palindrome, we can start by checking the longest-length substrings and iterate toward the shorter-length substrings. This way, the first time we find a substring that is a palindrome, we can immediately return it as the answer.\n\n**Algorithm**\n\n1. Create a helper method `check(i, j)` to determine if a substring is a palindrome.\n    - To save space, we will not pass the substring itself. Instead, we will pass two indices that represent the substring in question. The first character will be `s[i]` and the last character will be `s[j - 1]`.\n    - In this function, declare two pointers `left = i` and `right = j - 1`.\n    - While `left < right`, do the following steps:\n    - If `s[left] != s[right]`, return `false`.\n    - Otherwise, increment `left` and decrement `right`.\n    - If we get through the while loop, return `true`.\n2. Use a for loop to iterate a variable `length` starting from `s.length` until `1`. This variable represents the length of the substrings we are currently considering.\n3. Use a for loop to iterate a variable `start` starting from `0` until and including `s.length - length`. This variable represents the starting point of the substring we are currently considering.\n4. In each inner loop iteration, we are considering the substring starting at `start` until `start + length`. Pass these values into `check` to see if this substring is a palindrome. If it is, return the substring.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as the length of `s`,\n\n* Time complexity: $$O(n^3)$$\n\n    The two nested for loops iterate $$O(n^2)$$ times. We check one substring of length `n`, two substrings of length `n - 1`, three substrings of length `n - 2`, and so on.\n\n    There are `n` substrings of length 1, but we don't check them all since any substring of length 1 is a palindrome, and we will return immediately.\n\n    Therefore, the number of substrings that we check in the worst case is `1 + 2 + 3 + ... + n - 1`. This is the partial sum of [this series](https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF#Partial_sums) for `n - 1`, which is equal to $$\\frac{n \\cdot (n - 1)}{2} = O(n^2)$$.\n\n    In each iteration of the while loop, we perform a palindrome check. The cost of this check is linear with `n` as well, giving us a time complexity of $$O(n^3)$$.\n\n    Note that this time complexity is in the worst case and has a significant constant divisor that is dropped by big O. Due to the optimizations of checking the longer length substrings first and exiting the palindrome check early if we determine that a substring cannot be a palindrome, the practical runtime of this algorithm is not too bad.\n\n* Space complexity: $$O(1)$$\n\n    We don't count the answer as part of the space complexity. Thus, all we use are a few integer variables.---\n\n### Approach 2: Dynamic Programming\n\n**Intuition**\n\nLet's say that we knew the substring with inclusive bounds `i, j` was a palindrome. If `s[i - 1] == s[j + 1]`, then we know the substring with inclusive bounds `i - 1, j + 1` must also be a palindrome, and this check can be done in constant time.\n\nWe can flip the direction of this logic as well - if `s[i] == s[j]` and the substring `i + 1, j - 1` is a palindrome, then the substring `i, j` must also be a palindrome.\n\n![DP Example](../Figures/5/2.png)\n\nWe know that all substrings of length 1 are palindromes. From this, we can check if each substring of length 3 is a palindrome using the above fact. We just need to check every `i, j` pair where `j - i = 2`. Once we know all palindromes of length 3, we can use that information to find all palindromes of length 5, and then 7, and so on.\n\nWhat about even-length palindromes? A substring of length 2 is a palindrome if both characters are equal. That is, `i, i + 1` is a palindrome if `s[i] == s[i + 1]`. From this, we can use the earlier logic to find all palindromes of length 4, then 6, and so on.\n\nLet's use a table `dp` with dimensions of `n * n`. `dp[i][j]` is a boolean representing if the substring with inclusive bounds `i, j` is a palindrome. We initialize `dp[i][i] = true` for the substrings of length 1, and then `dp[i][i + 1] = (s[i] == s[i + 1])` for the substrings of length 2.\n\nNow, we need to populate the table. We iterate over all `i, j` pairs, starting with pairs that have a difference of 2 (representing substrings of length 3), then pairs with a difference of 3, then 4, and so on. For each `i, j` pair, we check the condition from earlier:\n\n`s[i] == s[j] && dp[i + 1][j - 1]`\n\nIf this condition is true, then the substring with inclusive bounds `i, j` must be a palindrome. We set `dp[i][j] = true`.\n\nBecause we are starting with the shortest substrings and iterating toward the longest substrings, every time we find a new palindrome, it must be the longest one we have seen so far. We can use this fact to keep track of the answer on the fly.\n\n**Algorithm**\n\n1. Initialize `n = s.length` and a boolean table `dp` with size `n * n`, and all values to `false`.\n2. Initialize `ans = [0, 0]`. This will hold the inclusive bounds of the answer.\n3. Set all `dp[i][i] = true`.\n4. Iterate over all pairs `i, i + 1`. For each one, if `s[i] == s[i + 1]`, then set `dp[i][i + 1] = true` and update `ans = [i, i + 1]`.\n5. Now, we populate the `dp` table. Iterate over `diff` from `2` until `n`. This variable represents the difference `j - i`.\n6. In a nested for loop, iterate over `i` from `0` until `n - diff`.\n    - Set `j = i + diff`.\n    - Check the condition: if `s[i] == s[j] && dp[i + 1][j - 1]`, we found a palindrome.\n    - In that case, set `dp[i][j] = true` and `ans = [i, j]`\n\n7. Retrieve the answer bounds from `ans` as `i, j`. Return the substring of `s` starting at index `i` and ending with index `j`.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as the length of `s`,\n\n* Time complexity: $$O(n^2)$$\n\n    We declare an `n * n` table `dp`, which takes $$O(n^2)$$ time. We then populate $$O(n^2)$$ states `i, j` - each state takes $$O(1)$$ time to compute.\n\n* Space complexity: $$O(n^2)$$\n\n    The table `dp` takes $$O(n^2)$$ space.---\n\n### Approach 3: Expand From Centers\n\n**Intuition**\n\nIn the first approach, the palindrome check cost $$O(n)$$. In the second approach, the palindrome check cost $$O(1)$$. This allowed us to improve the time complexity from $$O(n^3)$$ to $$O(n^2)$$.\n\nThe problem with the second approach is that we **always** iterated over $$O(n^2)$$ states of `i, j`. Can we optimize further to minimize the number of iterations required?\n\nIn the first approach, we implemented a palindrome check using two pointers. We started by checking the first and last characters, then the second and second last characters, and so on.\n\nInstead of starting the pointers at the edges and moving inwards, the same logic can be applied when starting the pointers at the center and moving outwards. A palindrome mirrors around its center. Let's say you had `s = \"racecar\"`. If we start both pointers at the middle (`\"e\"`) and move them away from each other, we can see that at every iteration, the characters match: `e -> c -> a -> r`.\n\nThe previous two approaches focused on the bounds of a substring - `i, j`. There are $$O(n^2)$$ bounds, but only $$O(n)$$ centers. For each index `i`, we can consider odd-length palindromes by starting the pointers at `i, i`. To consider the even length palindromes, we can start the pointers at `i, i + 1`. There are $$n$$ starting points for the odd-length palindromes and $$n - 1$$ starting points for the even-length palindromes - that's $$2n - 1 = O(n)$$ starting points in total.\n\nThis is very promising - we can lower the minimum iterations required if we focus on the centers instead of on the bounds. Let's use a helper method `expand(i, j)` that starts two pointers `left = i` and `right = j`. In this method, we will consider `i, j` as a center. When `i == j`, we are considering odd-length palindromes. When `i != j`, we are considering even-length palindromes. We will expand from the center as far as we can to find the longest palindrome, and then return the length of this palindrome.\n\nLet's say that we have a center `i, i`. We call `expand` and find a length of `length`. What are the bounds of the palindrome? Because we are centered at `i, i`, it means `length` must be odd. If we perform floor division of `length` by 2, we will get the number of characters `dist` on each side of the palindrome. For example, given `s = \"racecar\"`, we have `length = 7` and `dist = 7 / 2 = 3`. There are 3 characters on each side - `\"rac\"` on the left and `\"car\"` on the right. Therefore, we can determine that the bounds of the palindrome are `i - dist, i + dist`.\n\nWhat about a center at `i, i + 1`? `length` must be even now. If we have a palindrome with length `2`, then `length / 2 = 1`, but there are zero characters on each side of the center. We can see that `dist` is too large by 1. Therefore, we will calculate `dist` as `(length / 2) - 1` instead. Now, `dist` correctly represents the number of characters on each side. The bounds of the palindrome are `i - dist, i + 1 + dist`.\n\n**Algorithm**\n\n1. Create a helper method `expand(i, j)` to find the length of the longest palindrome centered at `i, j`.\n    - Set `left = i` and `right = j`.\n    - While `left` and `right` are both in bounds and `s[left] == s[right]`, move the pointers away from each other.\n    - The formula for the length of a substring starting at `left` and ending at `right` is `right - left + 1`.\n    - However, when the while loop ends, it implies `s[left] != s[right]`. Therefore, we need to subtract `2`. Return `right - left - 1`.\n2. Initialize `ans = [0, 0]`. This will hold the inclusive bounds of the answer.\n3. Iterate `i` over all indices of `s`.\n    - Find the length of the longest odd-length palindrome centered at `i`: `oddLength = expand(i, i)`.\n    - If `oddLength` is the greatest length we have seen so far, i.e. `oddLength > ans[1] - ans[0] + 1`, update `ans`.\n    - Find the length of the longest even-length palindrome centered at `i`: `evenLength = expand(i, i + 1)`.\n    - If `evenLength` is the greatest length we have seen so far, update `ans`.\n4. Retrieve the answer bounds from `ans` as `i, j`. Return the substring of `s` starting at index `i` and ending with index `j`.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as the length of `s`,\n\n* Time complexity: $$O(n^2)$$\n\n    There are $$2n - 1 = O(n)$$ centers. For each center, we call `expand`, which costs up to $$O(n)$$.\n\n    Although the time complexity is the same as in the DP approach, the average/practical runtime of the algorithm is much faster. This is because most centers will not produce long palindromes, so most of the $$O(n)$$ calls to `expand` will cost far less than $$n$$ iterations.\n\n    The worst case scenario is when every character in the string is the same.\n\n* Space complexity: $$O(1)$$\n\n    We don't use any extra space other than a few integers. This is a big improvement on the DP approach.---\n\n### Approach 4: Manacher's Algorithm\n\nBelieve it or not, this problem can be solved in linear time.\n\n[Manacher's algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm) finds the longest palindromic substring in $$O(n)$$ time and space.\n\nNote: this algorithm is completely out of scope for coding interviews. Because of this, we will not be talking about the algorithm in detail. This approach has been included for the sake of completeness and for those who are curious about algorithms beyond the scope of interviews.\n\nIf you wish to learn more about Manacher's algorithm, please reference the above link.\n\n**Implementation****Complexity Analysis**\n\nGiven $$n$$ as the length of `s`,\n\n* Time complexity: $$O(n)$$\n\n    From Wikipedia (the implementation they describe is slightly different from the above code, but it's the same algorithm):\n\n    > The algorithm runs in linear time. This can be seen by noting that Center strictly increases after each outer loop and the sum Center + Radius is non-decreasing. Moreover, the number of operations in the first inner loop is linear in the increase of the sum Center + Radius while the number of operations in the second inner loop is linear in the increase of Center. Since Center $$\\leq$$ 2n+1 and Radius $$\\leq$$ n, the total number of operations in the first and second inner loops is $$O(n)$$ and the total number of operations in the outer loop, other than those in the inner loops, is also $$O(n)$$. The overall running time is therefore $$O(n)$$.\n\n* Space complexity: $$O(n)$$\n\n    We use `sPrime` and `palindromeRadii`, both of length $$O(n)$$.---"
    },
    {
      "title": "Zigzag Conversion",
      "problem_id": "6",
      "frontend_id": "6",
      "difficulty": "Medium",
      "problem_slug": "zigzag-conversion",
      "topics": [
        "String"
      ],
      "description": "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\nWrite the code that will take a string and make this conversion given a number of rows:\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "P   A   H   N\nA P L S I I G\nY   I   R",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "string convert(string s, int numRows);",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: s = \"PAYPALISHIRING\", numRows = 3\nOutput: \"PAHNAPLSIIGYIR\"",
          "images": []
        },
        {
          "example_num": 4,
          "example_text": "Input: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I",
          "images": []
        },
        {
          "example_num": 5,
          "example_text": "Input: s = \"A\", numRows = 1\nOutput: \"A\"",
          "images": []
        }
      ],
      "constraints": [
        "1 <= s.length <= 1000",
        "s consists of English letters (lower-case and upper-case), ',' and '.'.",
        "1 <= numRows <= 1000"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    string convert(string s, int numRows) {\n        \n    }\n};",
        "java": "class Solution {\n    public String convert(String s, int numRows) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        ",
        "c": "char* convert(char* s, int numRows) {\n    \n}",
        "csharp": "public class Solution {\n    public string Convert(string s, int numRows) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} s\n * @param {number} numRows\n * @return {string}\n */\nvar convert = function(s, numRows) {\n    \n};",
        "typescript": "function convert(s: string, numRows: number): string {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param Integer $numRows\n     * @return String\n     */\n    function convert($s, $numRows) {\n        \n    }\n}",
        "swift": "class Solution {\n    func convert(_ s: String, _ numRows: Int) -> String {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun convert(s: String, numRows: Int): String {\n        \n    }\n}",
        "dart": "class Solution {\n  String convert(String s, int numRows) {\n    \n  }\n}",
        "golang": "func convert(s string, numRows int) string {\n    \n}",
        "ruby": "# @param {String} s\n# @param {Integer} num_rows\n# @return {String}\ndef convert(s, num_rows)\n    \nend",
        "scala": "object Solution {\n    def convert(s: String, numRows: Int): String = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn convert(s: String, num_rows: i32) -> String {\n        \n    }\n}",
        "racket": "(define/contract (convert s numRows)\n  (-> string? exact-integer? string?)\n  )",
        "erlang": "-spec convert(S :: unicode:unicode_binary(), NumRows :: integer()) -> unicode:unicode_binary().\nconvert(S, NumRows) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec convert(s :: String.t, num_rows :: integer) :: String.t\n  def convert(s, num_rows) do\n    \n  end\nend"
      }
    },
    {
      "title": "Reverse Integer",
      "problem_id": "7",
      "frontend_id": "7",
      "difficulty": "Medium",
      "problem_slug": "reverse-integer",
      "topics": [
        "Math"
      ],
      "description": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: x = 123\nOutput: 321",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: x = -123\nOutput: -321",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: x = 120\nOutput: 21",
          "images": []
        }
      ],
      "constraints": [
        "-231 <= x <= 231 - 1"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int reverse(int x) {\n        \n    }\n};",
        "java": "class Solution {\n    public int reverse(int x) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def reverse(self, x: int) -> int:\n        ",
        "c": "int reverse(int x){\n\n}",
        "csharp": "public class Solution {\n    public int Reverse(int x) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number} x\n * @return {number}\n */\nvar reverse = function(x) {\n    \n};",
        "typescript": "function reverse(x: number): number {\n\n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer $x\n     * @return Integer\n     */\n    function reverse($x) {\n        \n    }\n}",
        "swift": "class Solution {\n    func reverse(_ x: Int) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun reverse(x: Int): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int reverse(int x) {\n\n  }\n}",
        "golang": "func reverse(x int) int {\n    \n}",
        "ruby": "# @param {Integer} x\n# @return {Integer}\ndef reverse(x)\n    \nend",
        "scala": "object Solution {\n    def reverse(x: Int): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn reverse(x: i32) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (reverse x)\n  (-> exact-integer? exact-integer?)\n\n  )",
        "erlang": "-spec reverse(X :: integer()) -> integer().\nreverse(X) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec reverse(x :: integer) :: integer\n  def reverse(x) do\n\n  end\nend"
      },
      "solution": "[TOC]\n\n## Video Solution\n---## Solution Article\n\n---\n\n### Approach 1: Pop and Push Digits & Check before Overflow\n\n**Intuition**\n\nWe can build up the reverse integer one digit at a time.\nWhile doing so, we can check beforehand whether or not appending another digit would cause overflow.\n\n**Algorithm**\n\nReversing an integer can be done similarly to reversing a string.\n\nWe want to repeatedly \"pop\" the last digit off of $$x$$ and \"push\" it to the back of the $$\\text{rev}$$. In the end, $$\\text{rev}$$ will be the reverse of the $$x$$.\n\nTo \"pop\" and \"push\" digits without the help of some auxiliary stack/array, we can use math.\n\n```cpp\n// pop operation:\npop = x % 10;\nx /= 10;\n\n// push operation:\ntemp = rev * 10 + pop;\nrev = temp;\n```\n\nHowever, this approach is dangerous, because the statement $$\\text{temp} = \\text{rev} \\cdot 10 + \\text{pop}$$ can cause overflow.\n\nLuckily, it is easy to check beforehand whether or this statement would cause an overflow.\n\nTo explain, lets assume that $$\\text{rev}$$ is positive.\n\n1. If $$temp = \\text{rev} \\cdot 10 + \\text{pop}$$ causes overflow, then it must be that $$\\text{rev} \\geq \\frac{INTMAX}{10}$$\n2. If $$\\text{rev} > \\frac{INTMAX}{10}$$, then $$temp = \\text{rev} \\cdot 10 + \\text{pop}$$ is guaranteed to overflow.\n3. If $$\\text{rev} == \\frac{INTMAX}{10}$$, then $$temp = \\text{rev} \\cdot 10 + \\text{pop}$$ will overflow if and only if $$\\text{pop} > 7$$\n\nSimilar logic can be applied when $$\\text{rev}$$ is negative.**Complexity Analysis**\n\n* Time Complexity: $$O(\\log(x))$$. There are roughly $$\\log_{10}(x)$$ digits in $$x$$.\n* Space Complexity: $$O(1)$$."
    },
    {
      "title": "String to Integer (atoi)",
      "problem_id": "8",
      "frontend_id": "8",
      "difficulty": "Medium",
      "problem_slug": "string-to-integer-atoi",
      "topics": [
        "String"
      ],
      "description": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.\nThe algorithm for myAtoi(string s) is as follows:\nReturn the integer as the final result.\nExample 1:\nExample 2:\nExample 3:\nExample 4:\nExample 5:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "The underlined characters are what is read in and the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"42\" (\"42\" is read in)\n           ^",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Step 1: \"   -042\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -042\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -042\" (\"042\" is read in, leading zeros ignored in the result)\n               ^",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Step 1: \"1337c0d3\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"1337c0d3\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"1337c0d3\" (\"1337\" is read in; reading stops because the next character is a non-digit)\n             ^",
          "images": []
        },
        {
          "example_num": 4,
          "example_text": "Step 1: \"0-1\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"0-1\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"0-1\" (\"0\" is read in; reading stops because the next character is a non-digit)\n          ^",
          "images": []
        }
      ],
      "constraints": [
        "0 <= s.length <= 200",
        "s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int myAtoi(string s) {\n        \n    }\n};",
        "java": "class Solution {\n    public int myAtoi(String s) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def myAtoi(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        ",
        "c": "int myAtoi(char* s) {\n    \n}",
        "csharp": "public class Solution {\n    public int MyAtoi(string s) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar myAtoi = function(s) {\n    \n};",
        "typescript": "function myAtoi(s: string): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function myAtoi($s) {\n        \n    }\n}",
        "swift": "class Solution {\n    func myAtoi(_ s: String) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun myAtoi(s: String): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int myAtoi(String s) {\n    \n  }\n}",
        "golang": "func myAtoi(s string) int {\n    \n}",
        "ruby": "# @param {String} s\n# @return {Integer}\ndef my_atoi(s)\n    \nend",
        "scala": "object Solution {\n    def myAtoi(s: String): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn my_atoi(s: String) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (my-atoi s)\n  (-> string? exact-integer?)\n  )",
        "erlang": "-spec my_atoi(S :: unicode:unicode_binary()) -> integer().\nmy_atoi(S) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec my_atoi(s :: String.t) :: integer\n  def my_atoi(s) do\n    \n  end\nend"
      }
    },
    {
      "title": "Palindrome Number",
      "problem_id": "9",
      "frontend_id": "9",
      "difficulty": "Easy",
      "problem_slug": "palindrome-number",
      "topics": [
        "Math"
      ],
      "description": "Given an integer x, return true if x is a palindrome, and false otherwise.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.",
          "images": []
        }
      ],
      "constraints": [
        "-231 <= x <= 231 - 1"
      ],
      "follow_ups": [],
      "hints": [
        "Beware of overflow when you reverse the integer."
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        \n    }\n};",
        "java": "class Solution {\n    public boolean isPalindrome(int x) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        ",
        "c": "bool isPalindrome(int x) {\n    \n}",
        "csharp": "public class Solution {\n    public bool IsPalindrome(int x) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number} x\n * @return {boolean}\n */\nvar isPalindrome = function(x) {\n    \n};",
        "typescript": "function isPalindrome(x: number): boolean {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer $x\n     * @return Boolean\n     */\n    function isPalindrome($x) {\n        \n    }\n}",
        "swift": "class Solution {\n    func isPalindrome(_ x: Int) -> Bool {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun isPalindrome(x: Int): Boolean {\n        \n    }\n}",
        "dart": "class Solution {\n  bool isPalindrome(int x) {\n    \n  }\n}",
        "golang": "func isPalindrome(x int) bool {\n    \n}",
        "ruby": "# @param {Integer} x\n# @return {Boolean}\ndef is_palindrome(x)\n    \nend",
        "scala": "object Solution {\n    def isPalindrome(x: Int): Boolean = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn is_palindrome(x: i32) -> bool {\n        \n    }\n}",
        "racket": "(define/contract (is-palindrome x)\n  (-> exact-integer? boolean?)\n  )",
        "erlang": "-spec is_palindrome(X :: integer()) -> boolean().\nis_palindrome(X) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec is_palindrome(x :: integer) :: boolean\n  def is_palindrome(x) do\n    \n  end\nend"
      }
    },
    {
      "title": "Regular Expression Matching",
      "problem_id": "10",
      "frontend_id": "10",
      "difficulty": "Hard",
      "problem_slug": "regular-expression-matching",
      "topics": [
        "String",
        "Dynamic Programming",
        "Recursion"
      ],
      "description": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\nThe matching should cover the entire input string (not partial).\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".",
          "images": []
        }
      ],
      "constraints": [
        "1 <= s.length <= 20",
        "1 <= p.length <= 20",
        "s contains only lowercase English letters.",
        "p contains only lowercase English letters, '.', and '*'.",
        "It is guaranteed for each appearance of the character '*', there will be a previous valid character to match."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        \n    }\n};",
        "java": "class Solution {\n    public boolean isMatch(String s, String p) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        ",
        "c": "bool isMatch(char* s, char* p) {\n    \n}",
        "csharp": "public class Solution {\n    public bool IsMatch(string s, string p) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} s\n * @param {string} p\n * @return {boolean}\n */\nvar isMatch = function(s, p) {\n    \n};",
        "typescript": "function isMatch(s: string, p: string): boolean {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String $p\n     * @return Boolean\n     */\n    function isMatch($s, $p) {\n        \n    }\n}",
        "swift": "class Solution {\n    func isMatch(_ s: String, _ p: String) -> Bool {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun isMatch(s: String, p: String): Boolean {\n        \n    }\n}",
        "dart": "class Solution {\n  bool isMatch(String s, String p) {\n    \n  }\n}",
        "golang": "func isMatch(s string, p string) bool {\n    \n}",
        "ruby": "# @param {String} s\n# @param {String} p\n# @return {Boolean}\ndef is_match(s, p)\n    \nend",
        "scala": "object Solution {\n    def isMatch(s: String, p: String): Boolean = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn is_match(s: String, p: String) -> bool {\n        \n    }\n}",
        "racket": "(define/contract (is-match s p)\n  (-> string? string? boolean?)\n  )",
        "erlang": "-spec is_match(S :: unicode:unicode_binary(), P :: unicode:unicode_binary()) -> boolean().\nis_match(S, P) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec is_match(s :: String.t, p :: String.t) :: boolean\n  def is_match(s, p) do\n    \n  end\nend"
      },
      "solution": "[TOC]\n\n## Solution\n\n---\n### Approach 1: Recursion\n\n**Intuition**\n\nIf there were no Kleene stars (the `*` wildcard character for regular expressions), the problem would be easier - we simply check from left to right if each character of the text matches the pattern.\n\nWhen a star is present, we may need to check many different suffixes of the text and see if they match the rest of the pattern.  A recursive solution is a straightforward way to represent this relationship.\n\n**Algorithm**\n\nWithout a Kleene star, our solution would look like this:If a star is present in the pattern, it will be in the second position $$\\text{pattern[1]}$$.  Then, we may ignore this part of the pattern, or delete a matching character in the text.  If we have a match on the remaining strings after any of these operations, then the initial inputs matched.**Complexity Analysis**\n\n* Time Complexity: Let $$T, P$$ be the lengths of the text and the pattern respectively.  In the worst case, a call to `match(text[i:], pattern[2j:])` will be made $$\\binom{i+j}{i}$$ times, and strings of the order $$O(T - i)$$ and $$O(P - 2*j)$$ will be made.  Thus, the complexity has the order $$\\sum_{i = 0}^T \\sum_{j = 0}^{P/2} \\binom{i+j}{i} O(T+P-i-2j)$$.  With some effort outside the scope of this article, we can show this is bounded by $$O\\big((T+P)2^{T + \\frac{P}{2}}\\big)$$.\n\n* Space Complexity:  For every call to `match`, we will create those strings as described above, possibly creating duplicates.  If memory is not freed, this will also take a total of $$O\\big((T+P)2^{T + \\frac{P}{2}}\\big)$$ space, even though there are only order $$O(T^2 + P^2)$$ unique suffixes of $$P$$ and  $$T$$ that are actually required.---\n\n### Approach 2: Dynamic Programming\n\n**Intuition**\n\nAs the problem has an **optimal substructure**, it is natural to cache intermediate results.  We ask the question $$\\text{dp(i, j)}$$: does $$\\text{text[i:]}$$ and $$\\text{pattern[j:]}$$ match?  We can describe our answer in terms of answers to questions involving smaller strings.\n\n**Algorithm**\n\nWe proceed with the same recursion as in [Approach 1](#approach-1-recursion), except because calls will only ever be made to `match(text[i:], pattern[j:])`, we use $$\\text{dp(i, j)}$$ to handle those calls instead, saving us expensive string-building operations and allowing us to cache the intermediate results.\n\n\n*Top-Down Variation**Bottom-Up Variation***Complexity Analysis**\n\n* Time Complexity: Let $$T, P$$ be the lengths of the text and the pattern respectively.  The work for every call to `dp(i, j)` for $$i=0, ... ,T$$; $$j=0, ... ,P$$ is done once, and it is $$O(1)$$ work.  Hence, the time complexity is $$O(TP)$$.\n\n* Space Complexity:  The only memory we use is the $$O(TP)$$ boolean entries in our cache.  Hence, the space complexity is $$O(TP)$$."
    },
    {
      "title": "Container With Most Water",
      "problem_id": "11",
      "frontend_id": "11",
      "difficulty": "Medium",
      "problem_slug": "container-with-most-water",
      "topics": [
        "Array",
        "Two Pointers",
        "Greedy"
      ],
      "description": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.",
          "images": [
            "https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: height = [1,1]\nOutput: 1",
          "images": [
            "https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg"
          ]
        }
      ],
      "constraints": [
        "n == height.length",
        "2 <= n <= 105",
        "0 <= height[i] <= 104"
      ],
      "follow_ups": [],
      "hints": [
        "If you simulate the problem, it will be O(n^2) which is not efficient.",
        "Try to use two-pointers. Set one pointer to the left and one to the right of the array. Always move the pointer that points to the lower line.",
        "How can you calculate the amount of water at each step?"
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        \n    }\n};",
        "java": "class Solution {\n    public int maxArea(int[] height) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        ",
        "c": "int maxArea(int* height, int heightSize) {\n    \n}",
        "csharp": "public class Solution {\n    public int MaxArea(int[] height) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} height\n * @return {number}\n */\nvar maxArea = function(height) {\n    \n};",
        "typescript": "function maxArea(height: number[]): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $height\n     * @return Integer\n     */\n    function maxArea($height) {\n        \n    }\n}",
        "swift": "class Solution {\n    func maxArea(_ height: [Int]) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun maxArea(height: IntArray): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int maxArea(List<int> height) {\n    \n  }\n}",
        "golang": "func maxArea(height []int) int {\n    \n}",
        "ruby": "# @param {Integer[]} height\n# @return {Integer}\ndef max_area(height)\n    \nend",
        "scala": "object Solution {\n    def maxArea(height: Array[Int]): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn max_area(height: Vec<i32>) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (max-area height)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
        "erlang": "-spec max_area(Height :: [integer()]) -> integer().\nmax_area(Height) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec max_area(height :: [integer]) :: integer\n  def max_area(height) do\n    \n  end\nend"
      }
    },
    {
      "title": "Integer to Roman",
      "problem_id": "12",
      "frontend_id": "12",
      "difficulty": "Medium",
      "problem_slug": "integer-to-roman",
      "topics": [
        "Hash Table",
        "Math",
        "String"
      ],
      "description": "Seven different symbols represent Roman numerals with the following values:\nRoman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:\nGiven an integer, convert it to a Roman numeral.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M)\n 700 = DCC as 500 (D) + 100 (C) + 100 (C)\n  40 = XL as 10 (X) less of 50 (L)\n   9 = IX as 1 (I) less of 10 (X)\nNote: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "50 = L\n 8 = VIII",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "1000 = M\n 900 = CM\n  90 = XC\n   4 = IV",
          "images": []
        }
      ],
      "constraints": [
        "1 <= num <= 3999"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    string intToRoman(int num) {\n        \n    }\n};",
        "java": "class Solution {\n    public String intToRoman(int num) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        ",
        "c": "char* intToRoman(int num) {\n    \n}",
        "csharp": "public class Solution {\n    public string IntToRoman(int num) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number} num\n * @return {string}\n */\nvar intToRoman = function(num) {\n    \n};",
        "typescript": "function intToRoman(num: number): string {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer $num\n     * @return String\n     */\n    function intToRoman($num) {\n        \n    }\n}",
        "swift": "class Solution {\n    func intToRoman(_ num: Int) -> String {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun intToRoman(num: Int): String {\n        \n    }\n}",
        "dart": "class Solution {\n  String intToRoman(int num) {\n    \n  }\n}",
        "golang": "func intToRoman(num int) string {\n    \n}",
        "ruby": "# @param {Integer} num\n# @return {String}\ndef int_to_roman(num)\n    \nend",
        "scala": "object Solution {\n    def intToRoman(num: Int): String = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn int_to_roman(num: i32) -> String {\n        \n    }\n}",
        "racket": "(define/contract (int-to-roman num)\n  (-> exact-integer? string?)\n  )",
        "erlang": "-spec int_to_roman(Num :: integer()) -> unicode:unicode_binary().\nint_to_roman(Num) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec int_to_roman(num :: integer) :: String.t\n  def int_to_roman(num) do\n    \n  end\nend"
      }
    },
    {
      "title": "Roman to Integer",
      "problem_id": "13",
      "frontend_id": "13",
      "difficulty": "Easy",
      "problem_slug": "roman-to-integer",
      "topics": [
        "Hash Table",
        "Math",
        "String"
      ],
      "description": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nFor example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nGiven a roman numeral, convert it to an integer.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Symbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: s = \"III\"\nOutput: 3\nExplanation: III = 3.",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.",
          "images": []
        },
        {
          "example_num": 4,
          "example_text": "Input: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.",
          "images": []
        }
      ],
      "constraints": [
        "1 <= s.length <= 15",
        "s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').",
        "It is guaranteed that s is a valid roman numeral in the range [1, 3999]."
      ],
      "follow_ups": [],
      "hints": [
        "Problem is simpler to solve by working the string from back to front and using a map."
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int romanToInt(string s) {\n        \n    }\n};",
        "java": "class Solution {\n    public int romanToInt(String s) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        ",
        "c": "int romanToInt(char* s) {\n    \n}",
        "csharp": "public class Solution {\n    public int RomanToInt(string s) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar romanToInt = function(s) {\n    \n};",
        "typescript": "function romanToInt(s: string): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function romanToInt($s) {\n        \n    }\n}",
        "swift": "class Solution {\n    func romanToInt(_ s: String) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun romanToInt(s: String): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int romanToInt(String s) {\n    \n  }\n}",
        "golang": "func romanToInt(s string) int {\n    \n}",
        "ruby": "# @param {String} s\n# @return {Integer}\ndef roman_to_int(s)\n    \nend",
        "scala": "object Solution {\n    def romanToInt(s: String): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn roman_to_int(s: String) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (roman-to-int s)\n  (-> string? exact-integer?)\n  )",
        "erlang": "-spec roman_to_int(S :: unicode:unicode_binary()) -> integer().\nroman_to_int(S) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec roman_to_int(s :: String.t) :: integer\n  def roman_to_int(s) do\n    \n  end\nend"
      }
    },
    {
      "title": "Longest Common Prefix",
      "problem_id": "14",
      "frontend_id": "14",
      "difficulty": "Easy",
      "problem_slug": "longest-common-prefix",
      "topics": [
        "Array",
        "String",
        "Trie"
      ],
      "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.",
          "images": []
        }
      ],
      "constraints": [
        "1 <= strs.length <= 200",
        "0 <= strs[i].length <= 200",
        "strs[i] consists of only lowercase English letters if it is non-empty."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        \n    }\n};",
        "java": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        ",
        "c": "char* longestCommonPrefix(char** strs, int strsSize) {\n    \n}",
        "csharp": "public class Solution {\n    public string LongestCommonPrefix(string[] strs) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string[]} strs\n * @return {string}\n */\nvar longestCommonPrefix = function(strs) {\n    \n};",
        "typescript": "function longestCommonPrefix(strs: string[]): string {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String[] $strs\n     * @return String\n     */\n    function longestCommonPrefix($strs) {\n        \n    }\n}",
        "swift": "class Solution {\n    func longestCommonPrefix(_ strs: [String]) -> String {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun longestCommonPrefix(strs: Array<String>): String {\n        \n    }\n}",
        "dart": "class Solution {\n  String longestCommonPrefix(List<String> strs) {\n    \n  }\n}",
        "golang": "func longestCommonPrefix(strs []string) string {\n    \n}",
        "ruby": "# @param {String[]} strs\n# @return {String}\ndef longest_common_prefix(strs)\n    \nend",
        "scala": "object Solution {\n    def longestCommonPrefix(strs: Array[String]): String = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn longest_common_prefix(strs: Vec<String>) -> String {\n        \n    }\n}",
        "racket": "(define/contract (longest-common-prefix strs)\n  (-> (listof string?) string?)\n  )",
        "erlang": "-spec longest_common_prefix(Strs :: [unicode:unicode_binary()]) -> unicode:unicode_binary().\nlongest_common_prefix(Strs) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec longest_common_prefix(strs :: [String.t]) :: String.t\n  def longest_common_prefix(strs) do\n    \n  end\nend"
      },
      "solution": "[TOC]\n\n## Video Solution\n---## Solution Article\n\n---\n\n\n### Approach 1: Horizontal scanning\n\n#### Intuition\n\nFor a start we will describe a simple way of finding the longest prefix shared by a set of strings $$LCP(S_1  \\ldots  S_n)$$.\nWe will use the observation that :\n\n$$LCP(S_1 \\ldots S_n) = LCP(LCP(LCP(S_1, S_2),S_3),\\ldots S_n)$$\n\n#### Algorithm\n\n To employ this idea, the algorithm iterates through the strings $$[S_1  \\ldots  S_n]$$, finding at each iteration $$i$$ the longest common prefix of strings $$LCP(S_1  \\ldots  S_i)$$ When $$LCP(S_1  \\ldots  S_i)$$ is an empty string, the algorithm ends. Otherwise after $$n$$ iterations, the algorithm returns $$LCP(S_1  \\ldots  S_n)$$.\n\n ![Finding the longest common prefix](https://leetcode.com/media/original_images/14_basic.png){:width=\"539px\"}\n \n\n *Figure 1. Finding the longest common prefix (Horizontal scanning)*\n \n#### Implementation#### Complexity Analysis\n\n* Time complexity : $$O(S)$$ , where S is the sum of all characters in all strings.\n\n    In the worst case all $$n$$ strings are the same. The algorithm compares the string $$S1$$ with the other strings $$[S_2 \\ldots S_n]$$ There are $$S$$ character comparisons, where $$S$$ is the sum of all characters in the input array.\n\n* Space complexity : $$O(1)$$. We only used constant extra space.\n\n---\n\n### Approach 2: Vertical scanning\n\n#### Algorithm\n\nImagine a very short string is the common prefix at the end of the array. The above approach will still do $$S$$ comparisons. One way to optimize this case is to do vertical scanning. We compare characters from top to bottom on the same column (same character index of  the strings) before moving on to the next column.\n\n#### Implementation#### Complexity Analysis\n\n* Time complexity : $$O(S)$$ , where S is the sum of all characters in all strings.\nIn the worst case there will be $$n$$ equal strings with length $$m$$ and the algorithm performs  $$S = m \\cdot n$$ character comparisons.\nEven though the worst case is still the same as [Approach 1](#approach-1-horizontal-scanning), in the best case there are at most $$n \\cdot minLen$$ comparisons where $$minLen$$ is the length of the shortest string in the array.\n* Space complexity : $$O(1)$$. We only used constant extra space.\n\n---\n\n### Approach 3: Divide and conquer\n\n#### Intuition\n\nThe idea of the algorithm comes from the associative property of LCP operation. We notice that :\n$$LCP(S_1 \\ldots S_n) = LCP(LCP(S_1 \\ldots S_k), LCP (S_{k+1} \\ldots S_n))$$\n, where $$LCP(S_1 \\ldots S_n)$$ is the longest common prefix in set of strings $$[S_1 \\ldots S_n]$$ , $$1 < k < n$$\n\n#### Algorithm\n\nTo apply the observation above, we use divide and conquer technique, where we split the $$LCP(S_i \\ldots S_j)$$ problem into two subproblems $$LCP(S_i \\ldots S_{mid})$$   and $$LCP(S_{mid+1} \\ldots S_j)$$, where `mid` is $$\\frac{i + j}{2}$$. We use their solutions `lcpLeft` and `lcpRight` to construct the solution of the main problem $$LCP(S_i \\ldots S_j)$$. To accomplish this we compare one by one the characters of `lcpLeft` and `lcpRight` till there is no character match. The found common prefix of `lcpLeft` and `lcpRight` is the solution of the  $$LCP(S_i \\ldots S_j)$$.\n\n![Finding the longest common prefix](https://leetcode.com/media/original_images/14_lcp_diviso_et_lmpera.png){:width=\"539px\"}\n\n\n*Figure 2. Finding the longest common prefix of strings using divide and conquer technique*\n\n#### Implementation#### Complexity Analysis\n\nIn the worst case we have $$n$$ equal strings with length $$m$$\n\n* Time complexity : $$O(S)$$, where $$S$$ is the number of all characters in the array, $$S = m \\cdot n$$\n Time complexity is $$2 \\cdot T\\left ( \\frac{n}{2} \\right ) + O(m)$$. Therefore time complexity is $$O(S)$$.\n  In the best case this algorithm performs  $$O(minLen \\cdot n)$$ comparisons, where  $$minLen$$ is the shortest string of the array\n\n* Space complexity : $$O(m \\cdot \\log n)$$\n\n    There is a memory overhead since we store recursive calls in the execution stack. There are $$\\log n$$ recursive calls, each store need $$m$$ space to store the result,  so space complexity is $$O(m \\cdot \\log n)$$\n\n\n---\n\n### Approach 4: Binary search\n\n#### Intuition\n\nThe idea is to apply binary search method to find the string with maximum value `L`, which is common prefix of all of the strings. The algorithm searches space is the interval $$(0 \\ldots minLen)$$, where `minLen` is minimum string length and the maximum possible common prefix. Each time search space is divided in two equal parts, one of them is discarded, because it is sure that it doesn't contain the solution. There are two possible cases:\n* `S[1...mid]` is not a common string. This means that for each `j > i S[1..j]` is not a common string and we discard the second half of the  search space.\n* `S[1...mid]` is common string. This means that for each `i < j S[1..i]` is a common string and we discard the first half of the search space, because we try to find longer common prefix.\n\n![Finding the longest common prefix](https://leetcode.com/media/original_images/14_lcp_binary_search.png){:width=\"539px\"}\n\n\n*Figure 3. Finding the longest common prefix of strings using binary search technique*\n\n#### Implementation#### Complexity Analysis\n\nIn the worst case we have $$n$$ equal strings with length $$m$$\n\n* Time complexity : $$O(S \\cdot \\log m)$$, where $$S$$ is the sum of all characters in all strings.\n\n    The algorithm makes $$\\log m$$ iterations, for each of them there are $$S = m \\cdot n$$ comparisons, which gives in total $$O(S \\cdot \\log m)$$ time complexity.\n\n* Space complexity : $$O(1)$$. We only used constant extra space.\n\n---\n\n### Further Thoughts / Follow up\n\nLet's take a look at a slightly different problem:\n\n> Given a set of keys S = $$[S_1,S_2 \\ldots S_n]$$, find the longest common prefix among a string `q` and S. This LCP query will be called frequently.\n\nWe could optimize LCP queries by storing the set of keys S in a Trie. For more information about Trie, please see this article [Implement a trie (Prefix trie)](https://leetcode.com/articles/implement-trie-prefix-tree/). In a Trie, each node descending from the root represents a common prefix of some keys. But we need to find the longest common prefix of a string `q` and all key strings. This means that we have to find the deepest path from the root, which satisfies the following conditions:\n* it is prefix of query string `q`\n* each node along the path must contain only one child element. Otherwise the found path will not be a common prefix among all strings.\n* the path doesn't comprise of nodes which are marked as end of key. Otherwise the path couldn't be a prefix a of key which is shorter than itself.\n\n#### Algorithm\n\nThe only question left, is how to find the deepest path in the Trie, that fulfills the requirements above. The most effective way is to build a trie from $$[S_1 \\ldots   S_n]$$ strings. Then find the prefix of query string `q` in the Trie. We traverse the Trie from the root, till it is impossible to continue the path in the Trie because one of the conditions above is not satisfied.\n\n![Finding the longest common prefix using Trie](../Figures/14/14_lcp_trie_fix.png)\n\n*Figure 4. Finding the longest common prefix of strings using Trie*\n\n#### Implementation#### Complexity Analysis\n\nIn the worst case query $$q$$ has length $$m$$ and it is equal to all $$n$$ strings of the array.\n\n* Time complexity : preprocessing $$O(S)$$, where $$S$$ is the number of all characters in the array, LCP query $$O(m)$$.\n\n    Trie build has $$O(S)$$ time complexity. To find the common prefix of $$q$$ in the Trie takes in the worst case $$O(m)$$.\n\n* Space complexity : $$O(S)$$. We only used additional  $$S$$ extra space for the Trie."
    },
    {
      "title": "3Sum",
      "problem_id": "15",
      "frontend_id": "15",
      "difficulty": "Medium",
      "problem_slug": "3sum",
      "topics": [
        "Array",
        "Two Pointers",
        "Sorting"
      ],
      "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.",
          "images": []
        }
      ],
      "constraints": [
        "3 <= nums.length <= 3000",
        "-105 <= nums[i] <= 105"
      ],
      "follow_ups": [],
      "hints": [
        "So, we essentially need to find three numbers x, y, and z such that they add up to the given value. If we fix one of the numbers say x, we are left with the two-sum problem at hand!",
        "For the two-sum problem, if we fix one of the numbers, say x, we have to scan the entire array to find the next number y, which is value - x where value is the input parameter. Can we change our array somehow so that this search becomes faster?",
        "The second train of thought for two-sum is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        ",
        "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\n    \n}",
        "csharp": "public class Solution {\n    public IList<IList<int>> ThreeSum(int[] nums) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar threeSum = function(nums) {\n    \n};",
        "typescript": "function threeSum(nums: number[]): number[][] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[][]\n     */\n    function threeSum($nums) {\n        \n    }\n}",
        "swift": "class Solution {\n    func threeSum(_ nums: [Int]) -> [[Int]] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun threeSum(nums: IntArray): List<List<Int>> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<List<int>> threeSum(List<int> nums) {\n    \n  }\n}",
        "golang": "func threeSum(nums []int) [][]int {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @return {Integer[][]}\ndef three_sum(nums)\n    \nend",
        "scala": "object Solution {\n    def threeSum(nums: Array[Int]): List[List[Int]] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn three_sum(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        \n    }\n}",
        "racket": "(define/contract (three-sum nums)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)))\n  )",
        "erlang": "-spec three_sum(Nums :: [integer()]) -> [[integer()]].\nthree_sum(Nums) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec three_sum(nums :: [integer]) :: [[integer]]\n  def three_sum(nums) do\n    \n  end\nend"
      }
    },
    {
      "title": "3Sum Closest",
      "problem_id": "16",
      "frontend_id": "16",
      "difficulty": "Medium",
      "problem_slug": "3sum-closest",
      "topics": [
        "Array",
        "Two Pointers",
        "Sorting"
      ],
      "description": "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\nReturn the sum of the three integers.\nYou may assume that each input would have exactly one solution.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums = [-1,2,1,-4], target = 1\nOutput: 2\nExplanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [0,0,0], target = 1\nOutput: 0\nExplanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).",
          "images": []
        }
      ],
      "constraints": [
        "3 <= nums.length <= 500",
        "-1000 <= nums[i] <= 1000",
        "-104 <= target <= 104"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        \n    }\n};",
        "java": "class Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        ",
        "c": "int threeSumClosest(int* nums, int numsSize, int target) {\n    \n}",
        "csharp": "public class Solution {\n    public int ThreeSumClosest(int[] nums, int target) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar threeSumClosest = function(nums, target) {\n    \n};",
        "typescript": "function threeSumClosest(nums: number[], target: number): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer\n     */\n    function threeSumClosest($nums, $target) {\n        \n    }\n}",
        "swift": "class Solution {\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun threeSumClosest(nums: IntArray, target: Int): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int threeSumClosest(List<int> nums, int target) {\n    \n  }\n}",
        "golang": "func threeSumClosest(nums []int, target int) int {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer}\ndef three_sum_closest(nums, target)\n    \nend",
        "scala": "object Solution {\n    def threeSumClosest(nums: Array[Int], target: Int): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn three_sum_closest(nums: Vec<i32>, target: i32) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (three-sum-closest nums target)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
        "erlang": "-spec three_sum_closest(Nums :: [integer()], Target :: integer()) -> integer().\nthree_sum_closest(Nums, Target) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec three_sum_closest(nums :: [integer], target :: integer) :: integer\n  def three_sum_closest(nums, target) do\n    \n  end\nend"
      }
    },
    {
      "title": "Letter Combinations of a Phone Number",
      "problem_id": "17",
      "frontend_id": "17",
      "difficulty": "Medium",
      "problem_slug": "letter-combinations-of-a-phone-number",
      "topics": [
        "Hash Table",
        "String",
        "Backtracking"
      ],
      "description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: digits = \"23\"\nOutput: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
          "images": [
            "https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: digits = \"\"\nOutput: []",
          "images": [
            "https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png"
          ]
        },
        {
          "example_num": 3,
          "example_text": "Input: digits = \"2\"\nOutput: [\"a\",\"b\",\"c\"]",
          "images": [
            "https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png"
          ]
        }
      ],
      "constraints": [
        "0 <= digits.length <= 4",
        "digits[i] is a digit in the range ['2', '9']."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<String> letterCombinations(String digits) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        ",
        "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** letterCombinations(char* digits, int* returnSize) {\n    \n}",
        "csharp": "public class Solution {\n    public IList<string> LetterCombinations(string digits) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} digits\n * @return {string[]}\n */\nvar letterCombinations = function(digits) {\n    \n};",
        "typescript": "function letterCombinations(digits: string): string[] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $digits\n     * @return String[]\n     */\n    function letterCombinations($digits) {\n        \n    }\n}",
        "swift": "class Solution {\n    func letterCombinations(_ digits: String) -> [String] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun letterCombinations(digits: String): List<String> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<String> letterCombinations(String digits) {\n    \n  }\n}",
        "golang": "func letterCombinations(digits string) []string {\n    \n}",
        "ruby": "# @param {String} digits\n# @return {String[]}\ndef letter_combinations(digits)\n    \nend",
        "scala": "object Solution {\n    def letterCombinations(digits: String): List[String] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn letter_combinations(digits: String) -> Vec<String> {\n        \n    }\n}",
        "racket": "(define/contract (letter-combinations digits)\n  (-> string? (listof string?))\n  )",
        "erlang": "-spec letter_combinations(Digits :: unicode:unicode_binary()) -> [unicode:unicode_binary()].\nletter_combinations(Digits) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec letter_combinations(digits :: String.t) :: [String.t]\n  def letter_combinations(digits) do\n    \n  end\nend"
      }
    },
    {
      "title": "4Sum",
      "problem_id": "18",
      "frontend_id": "18",
      "difficulty": "Medium",
      "problem_slug": "4sum",
      "topics": [
        "Array",
        "Two Pointers",
        "Sorting"
      ],
      "description": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\nYou may return the answer in any order.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]",
          "images": []
        }
      ],
      "constraints": [
        "1 <= nums.length <= 200",
        "-109 <= nums[i] <= 109",
        "-109 <= target <= 109"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        ",
        "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) {\n    \n}",
        "csharp": "public class Solution {\n    public IList<IList<int>> FourSum(int[] nums, int target) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[][]}\n */\nvar fourSum = function(nums, target) {\n    \n};",
        "typescript": "function fourSum(nums: number[], target: number): number[][] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer[][]\n     */\n    function fourSum($nums, $target) {\n        \n    }\n}",
        "swift": "class Solution {\n    func fourSum(_ nums: [Int], _ target: Int) -> [[Int]] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun fourSum(nums: IntArray, target: Int): List<List<Int>> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<List<int>> fourSum(List<int> nums, int target) {\n    \n  }\n}",
        "golang": "func fourSum(nums []int, target int) [][]int {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer[][]}\ndef four_sum(nums, target)\n    \nend",
        "scala": "object Solution {\n    def fourSum(nums: Array[Int], target: Int): List[List[Int]] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn four_sum(nums: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        \n    }\n}",
        "racket": "(define/contract (four-sum nums target)\n  (-> (listof exact-integer?) exact-integer? (listof (listof exact-integer?)))\n  )",
        "erlang": "-spec four_sum(Nums :: [integer()], Target :: integer()) -> [[integer()]].\nfour_sum(Nums, Target) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec four_sum(nums :: [integer], target :: integer) :: [[integer]]\n  def four_sum(nums, target) do\n    \n  end\nend"
      },
      "solution": "[TOC]\n\n## Solution\n\nThis problem is a follow-up of [3Sum](https://leetcode.com/articles/3sum/), so take a look at that problem first if you haven't. 4Sum and 3Sum are very similar; the difference is that we are looking for unique quadruplets instead of triplets.\n\nAs you see, 3Sum just wraps Two Sum in an outer loop. As it iterates through each value `v`, it finds all pairs whose sum is equal to `target - v` using one of these approaches:\n\n1. [Two Sum](https://leetcode.com/articles/two-sum/) uses a hash set to check for a matching value.\n2. [Two Sum II](https://leetcode.com/articles/two-sum-ii-input-array-is-sorted/) uses the two pointers pattern in a sorted array.\n\nFollowing a similar logic, we can implement 4Sum by wrapping 3Sum in another loop. But wait - there is a catch. If an interviewer asks you to solve 4Sum, they can follow-up with 5Sum, 6Sum, and so on. What they are really expecting at this point is a kSum solution. Therefore, we will focus on a generalized implementation here.\n\n---\n\n### Approach 1: Two Pointers\n\n**Intuition**\n\nThe two pointers pattern requires the array to be sorted, so we do that first.  Also, it's easier to deal with duplicates if the array is sorted: repeated values are next to each other and easy to skip.\n\nFor 3Sum, we enumerate each value in a single loop, and use the two pointers pattern for the rest of the array. For kSum, we will have `k - 2` nested loops to enumerate all combinations of `k - 2` values.\n\n!?!../Documents/18_4Sum.json:1200,440!?!\n\n**Algorithm**\n\nWe can implement `k - 2` loops using a recursion. We will pass the starting point and `k` as the parameters. When `k == 2`, we will call `twoSum`, terminating the recursion.\n\n1. For the main function:\n    - Sort the input array `nums`.\n    - Call `kSum` with `start = 0`, `k = 4`, and `target`, and return the result.\n\n2. For `kSum` function:\n    - At the start of the `kSum` function, we will check three conditions:\n      1. Have we run out of numbers to choose from?\n      2. Is the smallest number remaining greater than `target / k`?If so, then any `k` numbers we choose will be too large.\n      3. Is the largest number remaining smaller than `target / k`?If so, then any `k` numbers we choose will be too small.\n      - If any of these conditions is true, there is no need to continue as no combination of the remaining elements can sum to `target`.\n    - If `k` equals `2`, call `twoSum` and return the result.\n    - Iterate `i` through the array from `start`:\n        - If the current value is the same as the one before, skip it.\n        - Recursively call `kSum` with `start = i + 1`, `k = k - 1`, and `target - nums[i]`.\n        - For each returned `subset` of values:\n            - Include the current value `nums[i]` into `subset`.\n            - Add `subset` to the result `res`.\n    - Return the result `res`.\n\n3. For `twoSum` function:\n    - Set the low pointer `lo` to `start`, and high pointer `hi` to the last index.\n    - While low pointer is smaller than high:\n        - If the sum of `nums[lo]` and `nums[hi]` is less than `target`, increment `lo`.\n            - Also increment `lo` if the value is the same as for `lo - 1`.\n        - If the sum is greater than `target`, decrement `hi`.\n            - Also decrement `hi` if the value is the same as for `hi + 1`.\n        - Otherwise, we found a pair:\n            - Add it to the result `res`.\n            - Decrement `hi` and increment `lo`.\n    - Return the result `res`.\n\n**Implementation****Complexity Analysis**\n\n- Time Complexity: $$O(n^{k - 1})$$, or $$O(n^3)$$ for 4Sum. We have $$k - 2$$ loops, and `twoSum` is $$O(n)$$.\n\n    Note that for $$k > 2$$, sorting the array does not change the overall time complexity.\n\n- Space Complexity: $$O(n)$$. We need $$O(k)$$ space for the recursion. $$k$$ can be the same as $$n$$ in the worst case for the generalized algorithm.\n\n    Note that, for the purpose of complexity analysis, we ignore the memory required for the output.\n\n---\n\n### Approach 2: Hash Set\n    \n**Intuition**\n\nSince elements must sum up to the exact target value, we can also use the [Two Sum: One-pass Hash Table](https://leetcode.com/articles/two-sum/#approach-3-one-pass-hash-table) approach.\n\nIn [3Sum: Hash Set](https://leetcode.com/articles/3sum/#approach-2-hash-set), we solved the problem without sorting the array. To do that, we needed to sort values within triplets, and track them in a hash set. Doing the same for k values could be impractical.\n\nSo, for this approach, we will also sort the array and skip duplicates the same way as in the Two Pointers approach above. Thus, the code will only differ in the `twoSum` implementation.\n\n**Algorithm**\n\n`twoSum` implementation here is almost the same as in [Two Sum: One-pass Hash Table](https://leetcode.com/articles/two-sum/#approach-3-one-pass-hash-table). The only difference is the check to avoid duplicates. Since the array is sorted, we can just compare the found pair with the last one in the result `res`.\n    \n**Implementation****Complexity Analysis**\n\n- Time Complexity: $$O(n^{k - 1})$$, or $$O(n^3)$$ for 4Sum. We have $$k - 2$$ loops iterating over $$n$$ elements, and `twoSum` is $$O(n)$$.\n\n    Note that for $$k > 2$$, sorting the array does not change the overall time complexity.\n\n- Space Complexity: $$O(n)$$ for the hash set. The space needed for the recursion will not exceed $$O(n)$$."
    },
    {
      "title": "Remove Nth Node From End of List",
      "problem_id": "19",
      "frontend_id": "19",
      "difficulty": "Medium",
      "problem_slug": "remove-nth-node-from-end-of-list",
      "topics": [
        "Linked List",
        "Two Pointers"
      ],
      "description": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you do this in one pass?",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]",
          "images": [
            "https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: head = [1], n = 1\nOutput: []",
          "images": [
            "https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg"
          ]
        },
        {
          "example_num": 3,
          "example_text": "Input: head = [1,2], n = 1\nOutput: [1]",
          "images": [
            "https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg"
          ]
        }
      ],
      "constraints": [
        "The number of nodes in the list is sz.",
        "1 <= sz <= 30",
        "0 <= Node.val <= 100",
        "1 <= n <= sz"
      ],
      "follow_ups": [
        "Could you do this in one pass?"
      ],
      "hints": [
        "Maintain two pointers and update one with a delay of n steps."
      ],
      "code_snippets": {
        "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        \n    }\n};",
        "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        \n    }\n}",
        "python": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type n: int\n        :rtype: Optional[ListNode]\n        \"\"\"\n        ",
        "python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        ",
        "c": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\n    \n}",
        "csharp": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\n        \n    }\n}",
        "javascript": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} n\n * @return {ListNode}\n */\nvar removeNthFromEnd = function(head, n) {\n    \n};",
        "typescript": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\n    \n};",
        "php": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @param Integer $n\n     * @return ListNode\n     */\n    function removeNthFromEnd($head, $n) {\n        \n    }\n}",
        "swift": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\n        \n    }\n}",
        "kotlin": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun removeNthFromEnd(head: ListNode?, n: Int): ListNode? {\n        \n    }\n}",
        "dart": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? removeNthFromEnd(ListNode? head, int n) {\n    \n  }\n}",
        "golang": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\n    \n}",
        "ruby": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @param {Integer} n\n# @return {ListNode}\ndef remove_nth_from_end(head, n)\n    \nend",
        "scala": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def removeNthFromEnd(head: ListNode, n: Int): ListNode = {\n        \n    }\n}",
        "rust": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\n        \n    }\n}",
        "racket": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (remove-nth-from-end head n)\n  (-> (or/c list-node? #f) exact-integer? (or/c list-node? #f))\n  )",
        "erlang": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec remove_nth_from_end(Head :: #list_node{} | null, N :: integer()) -> #list_node{} | null.\nremove_nth_from_end(Head, N) ->\n  .",
        "elixir": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec remove_nth_from_end(head :: ListNode.t | nil, n :: integer) :: ListNode.t | nil\n  def remove_nth_from_end(head, n) do\n    \n  end\nend"
      }
    },
    {
      "title": "Valid Parentheses",
      "problem_id": "20",
      "frontend_id": "20",
      "difficulty": "Easy",
      "problem_slug": "valid-parentheses",
      "topics": [
        "String",
        "Stack"
      ],
      "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\nAn input string is valid if:\nExample 1:\nExample 2:\nExample 3:\nExample 4:\nExample 5:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: s = \"()\"\nOutput: true",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: s = \"()[]{}\"\nOutput: true",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: s = \"(]\"\nOutput: false",
          "images": []
        },
        {
          "example_num": 4,
          "example_text": "Input: s = \"([])\"\nOutput: true",
          "images": []
        },
        {
          "example_num": 5,
          "example_text": "Input: s = \"([)]\"\nOutput: false",
          "images": []
        }
      ],
      "constraints": [
        "1 <= s.length <= 104",
        "s consists of parentheses only '()[]{}'."
      ],
      "follow_ups": [],
      "hints": [
        "Use a stack of characters.",
        "When you encounter an opening bracket, push it to the top of the stack.",
        "When you encounter a closing bracket, check if the top of the stack was the opening for it. If yes, pop it from the stack. Otherwise, return false."
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    bool isValid(string s) {\n        \n    }\n};",
        "java": "class Solution {\n    public boolean isValid(String s) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def isValid(self, s: str) -> bool:\n        ",
        "c": "bool isValid(char* s) {\n    \n}",
        "csharp": "public class Solution {\n    public bool IsValid(string s) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(s) {\n    \n};",
        "typescript": "function isValid(s: string): boolean {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Boolean\n     */\n    function isValid($s) {\n        \n    }\n}",
        "swift": "class Solution {\n    func isValid(_ s: String) -> Bool {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun isValid(s: String): Boolean {\n        \n    }\n}",
        "dart": "class Solution {\n  bool isValid(String s) {\n    \n  }\n}",
        "golang": "func isValid(s string) bool {\n    \n}",
        "ruby": "# @param {String} s\n# @return {Boolean}\ndef is_valid(s)\n    \nend",
        "scala": "object Solution {\n    def isValid(s: String): Boolean = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn is_valid(s: String) -> bool {\n        \n    }\n}",
        "racket": "(define/contract (is-valid s)\n  (-> string? boolean?)\n  )",
        "erlang": "-spec is_valid(S :: unicode:unicode_binary()) -> boolean().\nis_valid(S) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec is_valid(s :: String.t) :: boolean\n  def is_valid(s) do\n    \n  end\nend"
      }
    },
    {
      "title": "Merge Two Sorted Lists",
      "problem_id": "21",
      "frontend_id": "21",
      "difficulty": "Easy",
      "problem_slug": "merge-two-sorted-lists",
      "topics": [
        "Linked List",
        "Recursion"
      ],
      "description": "You are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]",
          "images": [
            "https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: list1 = [], list2 = []\nOutput: []",
          "images": [
            "https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg"
          ]
        },
        {
          "example_num": 3,
          "example_text": "Input: list1 = [], list2 = [0]\nOutput: [0]",
          "images": [
            "https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg"
          ]
        }
      ],
      "constraints": [
        "The number of nodes in both lists is in the range [0, 50].",
        "-100 <= Node.val <= 100",
        "Both list1 and list2 are sorted in non-decreasing order."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        \n    }\n};",
        "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        \n    }\n}",
        "python": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        ",
        "python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        ",
        "c": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {\n    \n}",
        "csharp": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode MergeTwoLists(ListNode list1, ListNode list2) {\n        \n    }\n}",
        "javascript": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} list1\n * @param {ListNode} list2\n * @return {ListNode}\n */\nvar mergeTwoLists = function(list1, list2) {\n    \n};",
        "typescript": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {\n    \n};",
        "php": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $list1\n     * @param ListNode $list2\n     * @return ListNode\n     */\n    function mergeTwoLists($list1, $list2) {\n        \n    }\n}",
        "swift": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func mergeTwoLists(_ list1: ListNode?, _ list2: ListNode?) -> ListNode? {\n        \n    }\n}",
        "kotlin": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun mergeTwoLists(list1: ListNode?, list2: ListNode?): ListNode? {\n        \n    }\n}",
        "dart": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? mergeTwoLists(ListNode? list1, ListNode? list2) {\n    \n  }\n}",
        "golang": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {\n    \n}",
        "ruby": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} list1\n# @param {ListNode} list2\n# @return {ListNode}\ndef merge_two_lists(list1, list2)\n    \nend",
        "scala": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def mergeTwoLists(list1: ListNode, list2: ListNode): ListNode = {\n        \n    }\n}",
        "rust": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn merge_two_lists(list1: Option<Box<ListNode>>, list2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        \n    }\n}",
        "racket": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (merge-two-lists list1 list2)\n  (-> (or/c list-node? #f) (or/c list-node? #f) (or/c list-node? #f))\n  )",
        "erlang": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec merge_two_lists(List1 :: #list_node{} | null, List2 :: #list_node{} | null) -> #list_node{} | null.\nmerge_two_lists(List1, List2) ->\n  .",
        "elixir": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec merge_two_lists(list1 :: ListNode.t | nil, list2 :: ListNode.t | nil) :: ListNode.t | nil\n  def merge_two_lists(list1, list2) do\n    \n  end\nend"
      }
    },
    {
      "title": "Generate Parentheses",
      "problem_id": "22",
      "frontend_id": "22",
      "difficulty": "Medium",
      "problem_slug": "generate-parentheses",
      "topics": [
        "String",
        "Dynamic Programming",
        "Backtracking"
      ],
      "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: n = 3\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: n = 1\nOutput: [\"()\"]",
          "images": []
        }
      ],
      "constraints": [
        "1 <= n <= 8"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<string> generateParenthesis(int n) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<String> generateParenthesis(int n) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        ",
        "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** generateParenthesis(int n, int* returnSize) {\n    \n}",
        "csharp": "public class Solution {\n    public IList<string> GenerateParenthesis(int n) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number} n\n * @return {string[]}\n */\nvar generateParenthesis = function(n) {\n    \n};",
        "typescript": "function generateParenthesis(n: number): string[] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return String[]\n     */\n    function generateParenthesis($n) {\n        \n    }\n}",
        "swift": "class Solution {\n    func generateParenthesis(_ n: Int) -> [String] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun generateParenthesis(n: Int): List<String> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<String> generateParenthesis(int n) {\n    \n  }\n}",
        "golang": "func generateParenthesis(n int) []string {\n    \n}",
        "ruby": "# @param {Integer} n\n# @return {String[]}\ndef generate_parenthesis(n)\n    \nend",
        "scala": "object Solution {\n    def generateParenthesis(n: Int): List[String] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn generate_parenthesis(n: i32) -> Vec<String> {\n        \n    }\n}",
        "racket": "(define/contract (generate-parenthesis n)\n  (-> exact-integer? (listof string?))\n  )",
        "erlang": "-spec generate_parenthesis(N :: integer()) -> [unicode:unicode_binary()].\ngenerate_parenthesis(N) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec generate_parenthesis(n :: integer) :: [String.t]\n  def generate_parenthesis(n) do\n    \n  end\nend"
      }
    },
    {
      "title": "Merge k Sorted Lists",
      "problem_id": "23",
      "frontend_id": "23",
      "difficulty": "Hard",
      "problem_slug": "merge-k-sorted-lists",
      "topics": [
        "Linked List",
        "Divide and Conquer",
        "Heap (Priority Queue)",
        "Merge Sort"
      ],
      "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted linked list:\n1->1->2->3->4->4->5->6",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: lists = []\nOutput: []",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: lists = [[]]\nOutput: []",
          "images": []
        }
      ],
      "constraints": [
        "k == lists.length",
        "0 <= k <= 104",
        "0 <= lists[i].length <= 500",
        "-104 <= lists[i][j] <= 104",
        "lists[i] is sorted in ascending order.",
        "The sum of lists[i].length will not exceed 104."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        \n    }\n};",
        "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        \n    }\n}",
        "python": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[Optional[ListNode]]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        ",
        "python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        ",
        "c": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* mergeKLists(struct ListNode** lists, int listsSize) {\n    \n}",
        "csharp": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode MergeKLists(ListNode[] lists) {\n        \n    }\n}",
        "javascript": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nvar mergeKLists = function(lists) {\n    \n};",
        "typescript": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction mergeKLists(lists: Array<ListNode | null>): ListNode | null {\n    \n};",
        "php": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode[] $lists\n     * @return ListNode\n     */\n    function mergeKLists($lists) {\n        \n    }\n}",
        "swift": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func mergeKLists(_ lists: [ListNode?]) -> ListNode? {\n        \n    }\n}",
        "kotlin": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun mergeKLists(lists: Array<ListNode?>): ListNode? {\n        \n    }\n}",
        "dart": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? mergeKLists(List<ListNode?> lists) {\n    \n  }\n}",
        "golang": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc mergeKLists(lists []*ListNode) *ListNode {\n    \n}",
        "ruby": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode[]} lists\n# @return {ListNode}\ndef merge_k_lists(lists)\n    \nend",
        "scala": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def mergeKLists(lists: Array[ListNode]): ListNode = {\n        \n    }\n}",
        "rust": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\n        \n    }\n}",
        "racket": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (merge-k-lists lists)\n  (-> (listof (or/c list-node? #f)) (or/c list-node? #f))\n  )",
        "erlang": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec merge_k_lists(Lists :: [#list_node{} | null]) -> #list_node{} | null.\nmerge_k_lists(Lists) ->\n  .",
        "elixir": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec merge_k_lists(lists :: [ListNode.t | nil]) :: ListNode.t | nil\n  def merge_k_lists(lists) do\n    \n  end\nend"
      }
    },
    {
      "title": "Swap Nodes in Pairs",
      "problem_id": "24",
      "frontend_id": "24",
      "difficulty": "Medium",
      "problem_slug": "swap-nodes-in-pairs",
      "topics": [
        "Linked List",
        "Recursion"
      ],
      "description": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\nExample 1:\nExample 2:\nExample 3:\nExample 4:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: head = [1,2,3,4]\nOutput: [2,1,4,3]\nExplanation:\n",
          "images": [
            "https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: head = []\nOutput: []",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: head = [1]\nOutput: [1]",
          "images": []
        },
        {
          "example_num": 4,
          "example_text": "Input: head = [1,2,3]\nOutput: [2,1,3]",
          "images": []
        }
      ],
      "constraints": [
        "The number of nodes in the list is in the range [0, 100].",
        "0 <= Node.val <= 100"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        \n    }\n};",
        "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        \n    }\n}",
        "python": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        ",
        "python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        ",
        "c": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* swapPairs(struct ListNode* head) {\n    \n}",
        "csharp": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode SwapPairs(ListNode head) {\n        \n    }\n}",
        "javascript": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    \n};",
        "typescript": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction swapPairs(head: ListNode | null): ListNode | null {\n    \n};",
        "php": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function swapPairs($head) {\n        \n    }\n}",
        "swift": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func swapPairs(_ head: ListNode?) -> ListNode? {\n        \n    }\n}",
        "kotlin": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun swapPairs(head: ListNode?): ListNode? {\n        \n    }\n}",
        "dart": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? swapPairs(ListNode? head) {\n    \n  }\n}",
        "golang": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc swapPairs(head *ListNode) *ListNode {\n    \n}",
        "ruby": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @return {ListNode}\ndef swap_pairs(head)\n    \nend",
        "scala": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def swapPairs(head: ListNode): ListNode = {\n        \n    }\n}",
        "rust": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        \n    }\n}",
        "racket": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (swap-pairs head)\n  (-> (or/c list-node? #f) (or/c list-node? #f))\n  )",
        "erlang": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec swap_pairs(Head :: #list_node{} | null) -> #list_node{} | null.\nswap_pairs(Head) ->\n  .",
        "elixir": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec swap_pairs(head :: ListNode.t | nil) :: ListNode.t | nil\n  def swap_pairs(head) do\n    \n  end\nend"
      }
    },
    {
      "title": "Reverse Nodes in k-Group",
      "problem_id": "25",
      "frontend_id": "25",
      "difficulty": "Hard",
      "problem_slug": "reverse-nodes-in-k-group",
      "topics": [
        "Linked List",
        "Recursion"
      ],
      "description": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\nExample 1:\nExample 2:\nConstraints:\nFollow-up: Can you solve the problem in O(1) extra memory space?",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]",
          "images": [
            "https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]",
          "images": [
            "https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg"
          ]
        }
      ],
      "constraints": [
        "The number of nodes in the list is n.",
        "1 <= k <= n <= 5000",
        "0 <= Node.val <= 1000"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        \n    }\n};",
        "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        \n    }\n}",
        "python": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type k: int\n        :rtype: Optional[ListNode]\n        \"\"\"\n        ",
        "python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        ",
        "c": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* reverseKGroup(struct ListNode* head, int k) {\n    \n}",
        "csharp": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode ReverseKGroup(ListNode head, int k) {\n        \n    }\n}",
        "javascript": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar reverseKGroup = function(head, k) {\n    \n};",
        "typescript": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction reverseKGroup(head: ListNode | null, k: number): ListNode | null {\n    \n};",
        "php": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @param Integer $k\n     * @return ListNode\n     */\n    function reverseKGroup($head, $k) {\n        \n    }\n}",
        "swift": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func reverseKGroup(_ head: ListNode?, _ k: Int) -> ListNode? {\n        \n    }\n}",
        "kotlin": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun reverseKGroup(head: ListNode?, k: Int): ListNode? {\n        \n    }\n}",
        "dart": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? reverseKGroup(ListNode? head, int k) {\n    \n  }\n}",
        "golang": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\n    \n}",
        "ruby": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @param {Integer} k\n# @return {ListNode}\ndef reverse_k_group(head, k)\n    \nend",
        "scala": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def reverseKGroup(head: ListNode, k: Int): ListNode = {\n        \n    }\n}",
        "rust": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn reverse_k_group(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\n        \n    }\n}",
        "racket": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (reverse-k-group head k)\n  (-> (or/c list-node? #f) exact-integer? (or/c list-node? #f))\n  )",
        "erlang": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec reverse_k_group(Head :: #list_node{} | null, K :: integer()) -> #list_node{} | null.\nreverse_k_group(Head, K) ->\n  .",
        "elixir": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec reverse_k_group(head :: ListNode.t | nil, k :: integer) :: ListNode.t | nil\n  def reverse_k_group(head, k) do\n    \n  end\nend"
      }
    },
    {
      "title": "Remove Duplicates from Sorted Array",
      "problem_id": "26",
      "frontend_id": "26",
      "difficulty": "Easy",
      "problem_slug": "remove-duplicates-from-sorted-array",
      "topics": [
        "Array",
        "Two Pointers"
      ],
      "description": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\nCustom Judge:\nThe judge will test your solution with the following code:\nIf all assertions pass, then your solution will be accepted.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "int[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
          "images": []
        }
      ],
      "constraints": [
        "1 <= nums.length <= 3 * 104",
        "-100 <= nums[i] <= 100",
        "nums is sorted in non-decreasing order."
      ],
      "follow_ups": [],
      "hints": [
        "In this problem, the key point to focus on is the input array being sorted. As far as duplicate elements are concerned, what is their positioning in the array when the given array is sorted? Look at the image below for the answer. If we know the position of one of the elements, do we also know the positioning of all the duplicate elements?\r\n\r\n<br>\r\n<img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_rem_dup.png\" width=\"500\"/>",
        "We need to modify the array in-place and the size of the final array would potentially be smaller than the size of the input array. So, we ought to use a two-pointer approach here. One, that would keep track of the current element in the original array and another one for just the unique elements.",
        "Essentially, once an element is encountered, you simply need to <b>bypass</b> its duplicates and move on to the next unique element."
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        \n    }\n};",
        "java": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        ",
        "c": "int removeDuplicates(int* nums, int numsSize) {\n    \n}",
        "csharp": "public class Solution {\n    public int RemoveDuplicates(int[] nums) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    \n};",
        "typescript": "function removeDuplicates(nums: number[]): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function removeDuplicates(&$nums) {\n        \n    }\n}",
        "swift": "class Solution {\n    func removeDuplicates(_ nums: inout [Int]) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun removeDuplicates(nums: IntArray): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int removeDuplicates(List<int> nums) {\n    \n  }\n}",
        "golang": "func removeDuplicates(nums []int) int {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef remove_duplicates(nums)\n    \nend",
        "scala": "object Solution {\n    def removeDuplicates(nums: Array[Int]): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\n        \n    }\n}"
      }
    },
    {
      "title": "Remove Element",
      "problem_id": "27",
      "frontend_id": "27",
      "difficulty": "Easy",
      "problem_slug": "remove-element",
      "topics": [
        "Array",
        "Two Pointers"
      ],
      "description": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\nCustom Judge:\nThe judge will test your solution with the following code:\nIf all assertions pass, then your solution will be accepted.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "int[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2,_,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: nums = [0,1,2,2,3,0,4,2], val = 2\nOutput: 5, nums = [0,1,4,0,3,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
          "images": []
        }
      ],
      "constraints": [
        "0 <= nums.length <= 100",
        "0 <= nums[i] <= 50",
        "0 <= val <= 100"
      ],
      "follow_ups": [],
      "hints": [
        "The problem statement clearly asks us to modify the array in-place and it also says that the element beyond the new length of the array can be anything. Given an element, we need to remove all the occurrences of it from the array. We don't technically need to <b>remove</b> that element per-say, right?",
        "We can move all the occurrences of this element to the end of the array. Use two pointers!\r\n<br><img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_remove_element.png\" width=\"500\"/>",
        "Yet another direction of thought is to consider the elements to be removed as non-existent. In a single pass, if we keep copying the visible elements in-place, that should also solve this problem for us."
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        \n    }\n};",
        "java": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def removeElement(self, nums, val):\n        \"\"\"\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        ",
        "c": "int removeElement(int* nums, int numsSize, int val) {\n    \n}",
        "csharp": "public class Solution {\n    public int RemoveElement(int[] nums, int val) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @param {number} val\n * @return {number}\n */\nvar removeElement = function(nums, val) {\n    \n};",
        "typescript": "function removeElement(nums: number[], val: number): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $val\n     * @return Integer\n     */\n    function removeElement(&$nums, $val) {\n        \n    }\n}",
        "swift": "class Solution {\n    func removeElement(_ nums: inout [Int], _ val: Int) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun removeElement(nums: IntArray, `val`: Int): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int removeElement(List<int> nums, int val) {\n    \n  }\n}",
        "golang": "func removeElement(nums []int, val int) int {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @param {Integer} val\n# @return {Integer}\ndef remove_element(nums, val)\n    \nend",
        "scala": "object Solution {\n    def removeElement(nums: Array[Int], `val`: Int): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {\n        \n    }\n}"
      }
    },
    {
      "title": "Find the Index of the First Occurrence in a String",
      "problem_id": "28",
      "frontend_id": "28",
      "difficulty": "Easy",
      "problem_slug": "find-the-index-of-the-first-occurrence-in-a-string",
      "topics": [
        "Two Pointers",
        "String",
        "String Matching"
      ],
      "description": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: haystack = \"sadbutsad\", needle = \"sad\"\nOutput: 0\nExplanation: \"sad\" occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: haystack = \"leetcode\", needle = \"leeto\"\nOutput: -1\nExplanation: \"leeto\" did not occur in \"leetcode\", so we return -1.",
          "images": []
        }
      ],
      "constraints": [
        "1 <= haystack.length, needle.length <= 104",
        "haystack and needle consist of only lowercase English characters."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        \n    }\n};",
        "java": "class Solution {\n    public int strStr(String haystack, String needle) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        ",
        "c": "int strStr(char* haystack, char* needle) {\n    \n}",
        "csharp": "public class Solution {\n    public int StrStr(string haystack, string needle) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} haystack\n * @param {string} needle\n * @return {number}\n */\nvar strStr = function(haystack, needle) {\n    \n};",
        "typescript": "function strStr(haystack: string, needle: string): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $haystack\n     * @param String $needle\n     * @return Integer\n     */\n    function strStr($haystack, $needle) {\n        \n    }\n}",
        "swift": "class Solution {\n    func strStr(_ haystack: String, _ needle: String) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun strStr(haystack: String, needle: String): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int strStr(String haystack, String needle) {\n    \n  }\n}",
        "golang": "func strStr(haystack string, needle string) int {\n    \n}",
        "ruby": "# @param {String} haystack\n# @param {String} needle\n# @return {Integer}\ndef str_str(haystack, needle)\n    \nend",
        "scala": "object Solution {\n    def strStr(haystack: String, needle: String): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn str_str(haystack: String, needle: String) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (str-str haystack needle)\n  (-> string? string? exact-integer?)\n  )",
        "erlang": "-spec str_str(Haystack :: unicode:unicode_binary(), Needle :: unicode:unicode_binary()) -> integer().\nstr_str(Haystack, Needle) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec str_str(haystack :: String.t, needle :: String.t) :: integer\n  def str_str(haystack, needle) do\n    \n  end\nend"
      }
    },
    {
      "title": "Divide Two Integers",
      "problem_id": "29",
      "frontend_id": "29",
      "difficulty": "Medium",
      "problem_slug": "divide-two-integers",
      "topics": [
        "Math",
        "Bit Manipulation"
      ],
      "description": "Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\nThe integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\nReturn the quotient after dividing dividend by divisor.\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. which is truncated to 3.",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: dividend = 7, divisor = -3\nOutput: -2\nExplanation: 7/-3 = -2.33333.. which is truncated to -2.",
          "images": []
        }
      ],
      "constraints": [
        "-231 <= dividend, divisor <= 231 - 1",
        "divisor != 0"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        \n    }\n};",
        "java": "class Solution {\n    public int divide(int dividend, int divisor) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        ",
        "c": "int divide(int dividend, int divisor) {\n    \n}",
        "csharp": "public class Solution {\n    public int Divide(int dividend, int divisor) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number} dividend\n * @param {number} divisor\n * @return {number}\n */\nvar divide = function(dividend, divisor) {\n    \n};",
        "typescript": "function divide(dividend: number, divisor: number): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer $dividend\n     * @param Integer $divisor\n     * @return Integer\n     */\n    function divide($dividend, $divisor) {\n        \n    }\n}",
        "swift": "class Solution {\n    func divide(_ dividend: Int, _ divisor: Int) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun divide(dividend: Int, divisor: Int): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int divide(int dividend, int divisor) {\n    \n  }\n}",
        "golang": "func divide(dividend int, divisor int) int {\n    \n}",
        "ruby": "# @param {Integer} dividend\n# @param {Integer} divisor\n# @return {Integer}\ndef divide(dividend, divisor)\n    \nend",
        "scala": "object Solution {\n    def divide(dividend: Int, divisor: Int): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn divide(dividend: i32, divisor: i32) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (divide dividend divisor)\n  (-> exact-integer? exact-integer? exact-integer?)\n  )",
        "erlang": "-spec divide(Dividend :: integer(), Divisor :: integer()) -> integer().\ndivide(Dividend, Divisor) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec divide(dividend :: integer, divisor :: integer) :: integer\n  def divide(dividend, divisor) do\n    \n  end\nend"
      }
    },
    {
      "title": "Substring with Concatenation of All Words",
      "problem_id": "30",
      "frontend_id": "30",
      "difficulty": "Hard",
      "problem_slug": "substring-with-concatenation-of-all-words",
      "topics": [
        "Hash Table",
        "String",
        "Sliding Window"
      ],
      "description": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated string is a string that exactly contains all the strings of any permutation of words concatenated.\nReturn an array of the starting indices of all the concatenated substrings in s. You can return the answer in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation:\nThe substring starting at 0 is \"barfoo\" . It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words . The substring starting at 9 is \"foobar\" . It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words .",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation:\nThere is no concatenated substring.",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation:\nThe substring starting at 6 is \"foobarthe\" . It is the concatenation of [\"foo\",\"bar\",\"the\"] . The substring starting at 9 is \"barthefoo\" . It is the concatenation of [\"bar\",\"the\",\"foo\"] . The substring starting at 12 is \"thefoobar\" . It is the concatenation of [\"the\",\"foo\",\"bar\"] .",
          "images": []
        }
      ],
      "constraints": [
        "1 <= s.length <= 104",
        "1 <= words.length <= 5000",
        "1 <= words[i].length <= 30",
        "s and words[i] consist of lowercase English letters."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        ",
        "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findSubstring(char* s, char** words, int wordsSize, int* returnSize) {\n    \n}",
        "csharp": "public class Solution {\n    public IList<int> FindSubstring(string s, string[] words) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    \n};",
        "typescript": "function findSubstring(s: string, words: string[]): number[] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String[] $words\n     * @return Integer[]\n     */\n    function findSubstring($s, $words) {\n        \n    }\n}",
        "swift": "class Solution {\n    func findSubstring(_ s: String, _ words: [String]) -> [Int] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun findSubstring(s: String, words: Array<String>): List<Int> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<int> findSubstring(String s, List<String> words) {\n    \n  }\n}",
        "golang": "func findSubstring(s string, words []string) []int {\n    \n}",
        "ruby": "# @param {String} s\n# @param {String[]} words\n# @return {Integer[]}\ndef find_substring(s, words)\n    \nend",
        "scala": "object Solution {\n    def findSubstring(s: String, words: Array[String]): List[Int] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn find_substring(s: String, words: Vec<String>) -> Vec<i32> {\n        \n    }\n}",
        "racket": "(define/contract (find-substring s words)\n  (-> string? (listof string?) (listof exact-integer?))\n  )",
        "erlang": "-spec find_substring(S :: unicode:unicode_binary(), Words :: [unicode:unicode_binary()]) -> [integer()].\nfind_substring(S, Words) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec find_substring(s :: String.t, words :: [String.t]) :: [integer]\n  def find_substring(s, words) do\n    \n  end\nend"
      }
    },
    {
      "title": "Next Permutation",
      "problem_id": "31",
      "frontend_id": "31",
      "difficulty": "Medium",
      "problem_slug": "next-permutation",
      "topics": [
        "Array",
        "Two Pointers"
      ],
      "description": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\nGiven an array of integers nums, find the next permutation of nums.\nThe replacement must be in place and use only constant extra memory.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums = [1,2,3]\nOutput: [1,3,2]",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [3,2,1]\nOutput: [1,2,3]",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: nums = [1,1,5]\nOutput: [1,5,1]",
          "images": []
        }
      ],
      "constraints": [
        "1 <= nums.length <= 100",
        "0 <= nums[i] <= 100"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        \n    }\n};",
        "java": "class Solution {\n    public void nextPermutation(int[] nums) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        ",
        "c": "void nextPermutation(int* nums, int numsSize) {\n    \n}",
        "csharp": "public class Solution {\n    public void NextPermutation(int[] nums) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar nextPermutation = function(nums) {\n    \n};",
        "typescript": "/**\n Do not return anything, modify nums in-place instead.\n */\nfunction nextPermutation(nums: number[]): void {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return NULL\n     */\n    function nextPermutation(&$nums) {\n        \n    }\n}",
        "swift": "class Solution {\n    func nextPermutation(_ nums: inout [Int]) {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun nextPermutation(nums: IntArray): Unit {\n        \n    }\n}",
        "dart": "class Solution {\n  void nextPermutation(List<int> nums) {\n    \n  }\n}",
        "golang": "func nextPermutation(nums []int)  {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @return {Void} Do not return anything, modify nums in-place instead.\ndef next_permutation(nums)\n    \nend",
        "scala": "object Solution {\n    def nextPermutation(nums: Array[Int]): Unit = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn next_permutation(nums: &mut Vec<i32>) {\n        \n    }\n}"
      },
      "solution": "[TOC]\n\n## Video Solution\n---## Solution Article\n\n---\n\n### Approach 1: Brute Force\n\n**Algorithm**\n\nIn this approach, we find out every possible permutation of list formed by the elements of the given array and find out the permutation which is\njust larger than the given one. But this one will be a very naive approach, since it requires us to find out every possible permutation\n which will take really long time and the implementation is complex.\n Thus, this approach is not acceptable at all. Hence, we move on directly to the correct approach.\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n!)$$. Total possible permutations is $$n!$$.\n* Space complexity : $$O(n)$$. Since an array will be used to store the permutations.---\n\n### Approach 2: Single Pass Approach\n\n**Algorithm**\n\nFirst, we observe that for any given sequence that is in descending order, no next larger permutation is possible.\n For example, no next permutation is possible for the following array:\n ```\n [9, 5, 4, 3, 1]\n ```\n\nWe need to find the first pair of two successive numbers $$a[i]$$ and $$a[i-1]$$, from the right, which satisfy\n $$a[i] > a[i-1]$$. Now, no rearrangements to the right of $$a[i-1]$$ can create a larger permutation since that subarray consists of numbers in descending order.\n Thus, we need to rearrange the numbers to the right of $$a[i-1]$$ including itself.\n\nNow, what kind of rearrangement will produce the next larger number? We want to create the permutation just larger than the current one. Therefore, we need to replace the number $$a[i-1]$$ with the number which is just larger than itself among the numbers lying to its right section, say $$a[j]$$.\n\n![ Next Permutation ](https://leetcode.com/media/original_images/31_nums_graph.png)\n\nWe swap the numbers $$a[i-1]$$ and $$a[j]$$. We now have the correct number at index $$i-1$$. But still the current permutation isn't the permutation\n    that we are looking for. We need the smallest permutation that can be formed by using the numbers only to the right of $$a[i-1]$$. Therefore, we need to place those\n     numbers in ascending order to get their smallest permutation.\n\nBut, recall that while scanning the numbers from the right, we simply kept decrementing the index\n      until we found the pair $$a[i]$$ and $$a[i-1]$$ where,  $$a[i] > a[i-1]$$. Thus, all numbers to the right of $$a[i-1]$$ were already sorted in descending order.\n      Furthermore, swapping $$a[i-1]$$ and $$a[j]$$ didn't change that order.\n      Therefore, we simply need to reverse the numbers following $$a[i-1]$$ to get the next smallest lexicographic permutation.\n\nThe following animation will make things clearer:\n\n![Next Permutation](https://leetcode.com/media/original_images/31_Next_Permutation.gif)**Complexity Analysis**\n\nLet $n$ be the size of the `nums` array.\n\n- Time complexity: $O(n)$\n\n   The first `while` loop runs at most $n$ iterations, decrementing the variable `i` as it searches for the first decreasing element from the right. In the worst case, it checks all elements, so it takes $O(n)$ time.\n    \n   The second `while` loop also runs at most $n$ iterations, decrementing the variable `j` as it searches for the smallest element larger than `nums[i]`. Similarly, it can take $O(n)$ time.\n    \n   The `reverse` function is called on a portion of the array, from index `i + 1` to the end. In the worst case, this can cover the entire array, leading to a time complexity of $O(n)$.\n    \n   The `swap` function runs in constant time, $O(1)$, since it only exchanges two elements.\n    \n    Therefore, the overall time complexity is $O(n)$.\n\n- Space complexity: $O(1)$\n\n   The function operates in-place on the `nums` array, meaning no extra space is used for storing additional data.\n    \n   Only a few constant space variables (`i`, `j`, and `temp`) are used.\n    \n   The built-in `swap` and `reverse` functions do not require additional space beyond what is already present in the input array.\n\n    Hence, the space complexity is $O(1)$."
    },
    {
      "title": "Longest Valid Parentheses",
      "problem_id": "32",
      "frontend_id": "32",
      "difficulty": "Hard",
      "problem_slug": "longest-valid-parentheses",
      "topics": [
        "String",
        "Dynamic Programming",
        "Stack"
      ],
      "description": "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: s = \"(()\"\nOutput: 2\nExplanation: The longest valid parentheses substring is \"()\".",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: s = \")()())\"\nOutput: 4\nExplanation: The longest valid parentheses substring is \"()()\".",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: s = \"\"\nOutput: 0",
          "images": []
        }
      ],
      "constraints": [
        "0 <= s.length <= 3 * 104",
        "s[i] is '(', or ')'."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        \n    }\n};",
        "java": "class Solution {\n    public int longestValidParentheses(String s) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        ",
        "c": "int longestValidParentheses(char* s) {\n    \n}",
        "csharp": "public class Solution {\n    public int LongestValidParentheses(string s) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar longestValidParentheses = function(s) {\n    \n};",
        "typescript": "function longestValidParentheses(s: string): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function longestValidParentheses($s) {\n        \n    }\n}",
        "swift": "class Solution {\n    func longestValidParentheses(_ s: String) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun longestValidParentheses(s: String): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int longestValidParentheses(String s) {\n    \n  }\n}",
        "golang": "func longestValidParentheses(s string) int {\n    \n}",
        "ruby": "# @param {String} s\n# @return {Integer}\ndef longest_valid_parentheses(s)\n    \nend",
        "scala": "object Solution {\n    def longestValidParentheses(s: String): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn longest_valid_parentheses(s: String) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (longest-valid-parentheses s)\n  (-> string? exact-integer?)\n  )",
        "erlang": "-spec longest_valid_parentheses(S :: unicode:unicode_binary()) -> integer().\nlongest_valid_parentheses(S) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec longest_valid_parentheses(s :: String.t) :: integer\n  def longest_valid_parentheses(s) do\n    \n  end\nend"
      }
    },
    {
      "title": "Search in Rotated Sorted Array",
      "problem_id": "33",
      "frontend_id": "33",
      "difficulty": "Medium",
      "problem_slug": "search-in-rotated-sorted-array",
      "topics": [
        "Array",
        "Binary Search"
      ],
      "description": "There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: nums = [1], target = 0\nOutput: -1",
          "images": []
        }
      ],
      "constraints": [
        "1 <= nums.length <= 5000",
        "-104 <= nums[i] <= 104",
        "All values of nums are unique.",
        "nums is an ascending array that is possibly rotated.",
        "-104 <= target <= 104"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        \n    }\n};",
        "java": "class Solution {\n    public int search(int[] nums, int target) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        ",
        "c": "int search(int* nums, int numsSize, int target) {\n    \n}",
        "csharp": "public class Solution {\n    public int Search(int[] nums, int target) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    \n};",
        "typescript": "function search(nums: number[], target: number): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer\n     */\n    function search($nums, $target) {\n        \n    }\n}",
        "swift": "class Solution {\n    func search(_ nums: [Int], _ target: Int) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun search(nums: IntArray, target: Int): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int search(List<int> nums, int target) {\n    \n  }\n}",
        "golang": "func search(nums []int, target int) int {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer}\ndef search(nums, target)\n    \nend",
        "scala": "object Solution {\n    def search(nums: Array[Int], target: Int): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (search nums target)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
        "erlang": "-spec search(Nums :: [integer()], Target :: integer()) -> integer().\nsearch(Nums, Target) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec search(nums :: [integer], target :: integer) :: integer\n  def search(nums, target) do\n    \n  end\nend"
      }
    },
    {
      "title": "Find First and Last Position of Element in Sorted Array",
      "problem_id": "34",
      "frontend_id": "34",
      "difficulty": "Medium",
      "problem_slug": "find-first-and-last-position-of-element-in-sorted-array",
      "topics": [
        "Array",
        "Binary Search"
      ],
      "description": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1, -1].\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: nums = [], target = 0\nOutput: [-1,-1]",
          "images": []
        }
      ],
      "constraints": [
        "0 <= nums.length <= 105",
        "-109 <= nums[i] <= 109",
        "nums is a non-decreasing array.",
        "-109 <= target <= 109"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        \n    }\n};",
        "java": "class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        ",
        "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* searchRange(int* nums, int numsSize, int target, int* returnSize) {\n    \n}",
        "csharp": "public class Solution {\n    public int[] SearchRange(int[] nums, int target) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar searchRange = function(nums, target) {\n    \n};",
        "typescript": "function searchRange(nums: number[], target: number): number[] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer[]\n     */\n    function searchRange($nums, $target) {\n        \n    }\n}",
        "swift": "class Solution {\n    func searchRange(_ nums: [Int], _ target: Int) -> [Int] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun searchRange(nums: IntArray, target: Int): IntArray {\n        \n    }\n}",
        "dart": "class Solution {\n  List<int> searchRange(List<int> nums, int target) {\n    \n  }\n}",
        "golang": "func searchRange(nums []int, target int) []int {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer[]}\ndef search_range(nums, target)\n    \nend",
        "scala": "object Solution {\n    def searchRange(nums: Array[Int], target: Int): Array[Int] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\n        \n    }\n}",
        "racket": "(define/contract (search-range nums target)\n  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))\n  )",
        "erlang": "-spec search_range(Nums :: [integer()], Target :: integer()) -> [integer()].\nsearch_range(Nums, Target) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec search_range(nums :: [integer], target :: integer) :: [integer]\n  def search_range(nums, target) do\n    \n  end\nend"
      }
    },
    {
      "title": "Search Insert Position",
      "problem_id": "35",
      "frontend_id": "35",
      "difficulty": "Easy",
      "problem_slug": "search-insert-position",
      "topics": [
        "Array",
        "Binary Search"
      ],
      "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums = [1,3,5,6], target = 5\nOutput: 2",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [1,3,5,6], target = 2\nOutput: 1",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: nums = [1,3,5,6], target = 7\nOutput: 4",
          "images": []
        }
      ],
      "constraints": [
        "1 <= nums.length <= 104",
        "-104 <= nums[i] <= 104",
        "nums contains distinct values sorted in ascending order.",
        "-104 <= target <= 104"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        \n    }\n};",
        "java": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        ",
        "c": "int searchInsert(int* nums, int numsSize, int target) {\n    \n}",
        "csharp": "public class Solution {\n    public int SearchInsert(int[] nums, int target) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    \n};",
        "typescript": "function searchInsert(nums: number[], target: number): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer\n     */\n    function searchInsert($nums, $target) {\n        \n    }\n}",
        "swift": "class Solution {\n    func searchInsert(_ nums: [Int], _ target: Int) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun searchInsert(nums: IntArray, target: Int): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int searchInsert(List<int> nums, int target) {\n    \n  }\n}",
        "golang": "func searchInsert(nums []int, target int) int {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer}\ndef search_insert(nums, target)\n    \nend",
        "scala": "object Solution {\n    def searchInsert(nums: Array[Int], target: Int): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn search_insert(nums: Vec<i32>, target: i32) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (search-insert nums target)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )",
        "erlang": "-spec search_insert(Nums :: [integer()], Target :: integer()) -> integer().\nsearch_insert(Nums, Target) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec search_insert(nums :: [integer], target :: integer) :: integer\n  def search_insert(nums, target) do\n    \n  end\nend"
      }
    },
    {
      "title": "Valid Sudoku",
      "problem_id": "36",
      "frontend_id": "36",
      "difficulty": "Medium",
      "problem_slug": "valid-sudoku",
      "topics": [
        "Array",
        "Hash Table",
        "Matrix"
      ],
      "description": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\nNote:\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: true",
          "images": [
            "https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: false\nExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.",
          "images": [
            "https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"
          ]
        }
      ],
      "constraints": [
        "board.length == 9",
        "board[i].length == 9",
        "board[i][j] is a digit 1-9 or '.'."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    bool isValidSudoku(vector<vector<char>>& board) {\n        \n    }\n};",
        "java": "class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        ",
        "c": "bool isValidSudoku(char** board, int boardSize, int* boardColSize) {\n    \n}",
        "csharp": "public class Solution {\n    public bool IsValidSudoku(char[][] board) {\n        \n    }\n}",
        "javascript": "/**\n * @param {character[][]} board\n * @return {boolean}\n */\nvar isValidSudoku = function(board) {\n    \n};",
        "typescript": "function isValidSudoku(board: string[][]): boolean {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String[][] $board\n     * @return Boolean\n     */\n    function isValidSudoku($board) {\n        \n    }\n}",
        "swift": "class Solution {\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun isValidSudoku(board: Array<CharArray>): Boolean {\n        \n    }\n}",
        "dart": "class Solution {\n  bool isValidSudoku(List<List<String>> board) {\n    \n  }\n}",
        "golang": "func isValidSudoku(board [][]byte) bool {\n    \n}",
        "ruby": "# @param {Character[][]} board\n# @return {Boolean}\ndef is_valid_sudoku(board)\n    \nend",
        "scala": "object Solution {\n    def isValidSudoku(board: Array[Array[Char]]): Boolean = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\n        \n    }\n}",
        "racket": "(define/contract (is-valid-sudoku board)\n  (-> (listof (listof char?)) boolean?)\n  )",
        "erlang": "-spec is_valid_sudoku(Board :: [[char()]]) -> boolean().\nis_valid_sudoku(Board) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec is_valid_sudoku(board :: [[char]]) :: boolean\n  def is_valid_sudoku(board) do\n    \n  end\nend"
      }
    },
    {
      "title": "Sudoku Solver",
      "problem_id": "37",
      "frontend_id": "37",
      "difficulty": "Hard",
      "problem_slug": "sudoku-solver",
      "topics": [
        "Array",
        "Hash Table",
        "Backtracking",
        "Matrix"
      ],
      "description": "Write a program to solve a Sudoku puzzle by filling the empty cells.\nA sudoku solution must satisfy all of the following rules:\nThe '.' character indicates empty cells.\nExample 1:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\nExplanation: The input board is shown above and the only valid solution is shown below:",
          "images": [
            "https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"
          ]
        }
      ],
      "constraints": [
        "board.length == 9",
        "board[i].length == 9",
        "board[i][j] is a digit or '.'.",
        "It is guaranteed that the input board has only one solution."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    void solveSudoku(vector<vector<char>>& board) {\n        \n    }\n};",
        "java": "class Solution {\n    public void solveSudoku(char[][] board) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        ",
        "c": "void solveSudoku(char** board, int boardSize, int* boardColSize) {\n    \n}",
        "csharp": "public class Solution {\n    public void SolveSudoku(char[][] board) {\n        \n    }\n}",
        "javascript": "/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar solveSudoku = function(board) {\n    \n};",
        "typescript": "/**\n Do not return anything, modify board in-place instead.\n */\nfunction solveSudoku(board: string[][]): void {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String[][] $board\n     * @return NULL\n     */\n    function solveSudoku(&$board) {\n        \n    }\n}",
        "swift": "class Solution {\n    func solveSudoku(_ board: inout [[Character]]) {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun solveSudoku(board: Array<CharArray>): Unit {\n        \n    }\n}",
        "dart": "class Solution {\n  void solveSudoku(List<List<String>> board) {\n    \n  }\n}",
        "golang": "func solveSudoku(board [][]byte)  {\n    \n}",
        "ruby": "# @param {Character[][]} board\n# @return {Void} Do not return anything, modify board in-place instead.\ndef solve_sudoku(board)\n    \nend",
        "scala": "object Solution {\n    def solveSudoku(board: Array[Array[Char]]): Unit = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn solve_sudoku(board: &mut Vec<Vec<char>>) {\n        \n    }\n}"
      }
    },
    {
      "title": "Count and Say",
      "problem_id": "38",
      "frontend_id": "38",
      "difficulty": "Medium",
      "problem_slug": "count-and-say",
      "topics": [
        "String"
      ],
      "description": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\nRun-length encoding (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string \"3322251\" we replace \"33\" with \"23\", replace \"222\" with \"32\", replace \"5\" with \"15\" and replace \"1\" with \"11\". Thus the compressed string becomes \"23321511\".\nGiven a positive integer n, return the nth element of the count-and-say sequence.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "countAndSay(1) = \"1\"\ncountAndSay(2) = RLE of \"1\" = \"11\"\ncountAndSay(3) = RLE of \"11\" = \"21\"\ncountAndSay(4) = RLE of \"21\" = \"1211\"",
          "images": []
        }
      ],
      "constraints": [
        "1 <= n <= 30"
      ],
      "follow_ups": [],
      "hints": [
        "Create a helper function that maps an integer to pairs of its digits and their frequencies. For example, if you call this function with \"223314444411\", then it maps it to an array of pairs [[2,2], [3,2], [1,1], [4,5], [1, 2]].",
        "Create another helper function that takes the array of pairs and creates a new integer. For example, if you call this function with [[2,2], [3,2], [1,1], [4,5], [1, 2]], it should create \"22\"+\"23\"+\"11\"+\"54\"+\"21\" = \"2223115421\".",
        "Now, with the two helper functions, you can start with \"1\" and call the two functions alternatively n-1 times. The answer is the last integer you will obtain."
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    string countAndSay(int n) {\n        \n    }\n};",
        "java": "class Solution {\n    public String countAndSay(int n) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        ",
        "c": "char* countAndSay(int n) {\n    \n}",
        "csharp": "public class Solution {\n    public string CountAndSay(int n) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number} n\n * @return {string}\n */\nvar countAndSay = function(n) {\n    \n};",
        "typescript": "function countAndSay(n: number): string {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return String\n     */\n    function countAndSay($n) {\n        \n    }\n}",
        "swift": "class Solution {\n    func countAndSay(_ n: Int) -> String {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun countAndSay(n: Int): String {\n        \n    }\n}",
        "dart": "class Solution {\n  String countAndSay(int n) {\n    \n  }\n}",
        "golang": "func countAndSay(n int) string {\n    \n}",
        "ruby": "# @param {Integer} n\n# @return {String}\ndef count_and_say(n)\n    \nend",
        "scala": "object Solution {\n    def countAndSay(n: Int): String = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn count_and_say(n: i32) -> String {\n        \n    }\n}",
        "racket": "(define/contract (count-and-say n)\n  (-> exact-integer? string?)\n  )",
        "erlang": "-spec count_and_say(N :: integer()) -> unicode:unicode_binary().\ncount_and_say(N) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec count_and_say(n :: integer) :: String.t\n  def count_and_say(n) do\n    \n  end\nend"
      }
    },
    {
      "title": "Combination Sum",
      "problem_id": "39",
      "frontend_id": "39",
      "difficulty": "Medium",
      "problem_slug": "combination-sum",
      "topics": [
        "Array",
        "Backtracking"
      ],
      "description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: candidates = [2], target = 1\nOutput: []",
          "images": []
        }
      ],
      "constraints": [
        "1 <= candidates.length <= 30",
        "2 <= candidates[i] <= 40",
        "All elements of candidates are distinct.",
        "1 <= target <= 40"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        ",
        "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** combinationSum(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes) {\n    \n}",
        "csharp": "public class Solution {\n    public IList<IList<int>> CombinationSum(int[] candidates, int target) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum = function(candidates, target) {\n    \n};",
        "typescript": "function combinationSum(candidates: number[], target: number): number[][] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $candidates\n     * @param Integer $target\n     * @return Integer[][]\n     */\n    function combinationSum($candidates, $target) {\n        \n    }\n}",
        "swift": "class Solution {\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun combinationSum(candidates: IntArray, target: Int): List<List<Int>> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<List<int>> combinationSum(List<int> candidates, int target) {\n    \n  }\n}",
        "golang": "func combinationSum(candidates []int, target int) [][]int {\n    \n}",
        "ruby": "# @param {Integer[]} candidates\n# @param {Integer} target\n# @return {Integer[][]}\ndef combination_sum(candidates, target)\n    \nend",
        "scala": "object Solution {\n    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn combination_sum(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        \n    }\n}",
        "racket": "(define/contract (combination-sum candidates target)\n  (-> (listof exact-integer?) exact-integer? (listof (listof exact-integer?)))\n  )",
        "erlang": "-spec combination_sum(Candidates :: [integer()], Target :: integer()) -> [[integer()]].\ncombination_sum(Candidates, Target) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec combination_sum(candidates :: [integer], target :: integer) :: [[integer]]\n  def combination_sum(candidates, target) do\n    \n  end\nend"
      }
    },
    {
      "title": "Combination Sum II",
      "problem_id": "40",
      "frontend_id": "40",
      "difficulty": "Medium",
      "problem_slug": "combination-sum-ii",
      "topics": [
        "Array",
        "Backtracking"
      ],
      "description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\nEach number in candidates may only be used once in the combination.\nNote: The solution set must not contain duplicate combinations.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]",
          "images": []
        }
      ],
      "constraints": [
        "1 <= candidates.length <= 100",
        "1 <= candidates[i] <= 50",
        "1 <= target <= 30"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        ",
        "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes) {\n    \n}",
        "csharp": "public class Solution {\n    public IList<IList<int>> CombinationSum2(int[] candidates, int target) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum2 = function(candidates, target) {\n    \n};",
        "typescript": "function combinationSum2(candidates: number[], target: number): number[][] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $candidates\n     * @param Integer $target\n     * @return Integer[][]\n     */\n    function combinationSum2($candidates, $target) {\n        \n    }\n}",
        "swift": "class Solution {\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun combinationSum2(candidates: IntArray, target: Int): List<List<Int>> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<List<int>> combinationSum2(List<int> candidates, int target) {\n    \n  }\n}",
        "golang": "func combinationSum2(candidates []int, target int) [][]int {\n    \n}",
        "ruby": "# @param {Integer[]} candidates\n# @param {Integer} target\n# @return {Integer[][]}\ndef combination_sum2(candidates, target)\n    \nend",
        "scala": "object Solution {\n    def combinationSum2(candidates: Array[Int], target: Int): List[List[Int]] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn combination_sum2(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        \n    }\n}",
        "racket": "(define/contract (combination-sum2 candidates target)\n  (-> (listof exact-integer?) exact-integer? (listof (listof exact-integer?)))\n  )",
        "erlang": "-spec combination_sum2(Candidates :: [integer()], Target :: integer()) -> [[integer()]].\ncombination_sum2(Candidates, Target) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec combination_sum2(candidates :: [integer], target :: integer) :: [[integer]]\n  def combination_sum2(candidates, target) do\n    \n  end\nend"
      },
      "solution": "[TOC]  \n\n## Solution\n\n---\n\n### Overview\n\nThis is one of the problems in the series of combination sums. All these problems can be solved with the same backtracking algorithm.\n\nWe recommend trying these similar problems before tackling this one: [Combination Sum](https://leetcode.com/problems/combination-sum/description/) and [Combination Sum III](https://leetcode.com/problems/combination-sum-iii/description/), which are arguably easier and one can tweak the solution a bit to solve this problem.\n\nWe also listed some follow-up problems at the end of the article if you are interested in exploring the bactracking algorithm further.\n\n---\n\n### Approach: Backtracking\n\n#### Intuition\n\nIn this problem, we need to generate unique combinations with the given sum value. In the worst case, we might need to generate the sum of all combinations in the array. Backtracking can be effectively used to generate all the possible combinations recursively. Backtracking incrementally builds candidates to the solutions and abandons a candidate (backtracks) as soon as it determines that this candidate can't lead to a final solution. For example, in the given problem, we can discard the candidate solution when it exceeds the sum value, provided the array contains non-negative values. Refer to this [backtracking explore card](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/) to read more about backtracking.\n\nUsing backtracking, we could incrementally build the combinations. When we find the current combination is not valid, we backtrack and try another option. For the first option, we add the current array element to the current combination array and move this combination to the next index recursively. Similarly, for the second option, we remove the element from the current combination array and move this combination to the next index. Therefore, for every index, we explored two possibilities of including and excluding that value and calculated the combination sum of the maintained combination array. If the desired sum is reached, we can append the list to the answer list. To demonstrate the idea, we showcase how it works with a concrete example in the following tree:\n\n![fig](../Figures/40/40.png)\n\nAre there any optimizations to reduce the backtracking calls? Since we need to return unique combinations, we can group equal values of the array together. The simplest way to group all elements together is by sorting them. Now, suppose the frequency of an element is `freq`, and you need to make backtracking calls for all its possible frequencies between `0` and `freq`, then we can simply pick them from the beginning of its group in the sorted array.\n\n#### Algorithm\n\n- Create a list `list` to store all the unique combinations that sum up to the target.\n- Sort the `candidates` array to handle duplicates and facilitate the backtracking process.\n- Call the `backtrack` function with the following parameters:\n  - `answer`: List to store the final combinations.\n  - `tempList`: Temporary list to store the current combination.\n  - `candidates`: Input array of numbers.\n  - `totalLeft`: Remaining sum to reach the target.\n  - `index`: Starting index for the current recursion.\n\n- Within the `backtrack` function:\n  - If `totalLeft` is less than 0, return immediately (invalid path).\n  - If `totalLeft` equals 0:\n    - Add a copy of `tempList` to `answer` (valid combination found).\n  - Otherwise:\n    - Iterate over `candidates` starting from `index`:\n      - Skip duplicate numbers by checking if `candidates[i] == candidates[i - 1]` for `i > index`.\n      - Add `candidates[i]` to `tempList`.\n      - Recursively call `backtrack` with:\n        - Updated `totalLeft` reduced by `candidates[i]`.\n        - Updated `index` as `i + 1` to avoid reusing the same element.\n      - Remove the last element from `tempList` to backtrack and explore other possibilities.\n\n- Return `list` containing all unique combinations after the recursive calls complete.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the number of $candidates$ in the array.\n\n- Time complexity: $O(2^N)$\n\n    In the worst case, our algorithm will exhaust all possible combinations from the input array. Again, in the worst case, let us assume that each number is unique. The number of combinations for an array of size $N$ would be $2^N$, i.e. each number is included or excluded in a combination. \n    \n    Additionally, it takes $O(N)$ time to build a counter table out of the input array.\n    \n    Therefore, the overall time complexity of the algorithm is dominated by the backtracking process, which is $O(2^N)$.\n\n    You must think about how the solution passes the test cases when the value of $N$ goes up to 100. [Pruning](https://en.wikipedia.org/wiki/Decision_tree_pruning) is the process of writing some additional conditions within our recursion code that help us to reduce the size of our recursion trees by removing redundant sections. For example, in this problem, the maximum value of any `candidates` element is given by 50, whereas the maximum `target` value is 30. So, we can stop the recursion when the value of candidates exceeds the `target` value. Sorting the array is another way to prune the recursion tree. Checkout the image for an explanation:\n\n    ![fig](../Figures/40/image.png)\n   \n- Space complexity: $O(N)$\n   \n    We first create a `tempList`, which in the worst case will consume $O(N)$ space to keep track of the combinations. In addition, we apply recursion in the algorithm, which will incur additional memory consumption in the function call stack. In the worst case, the stack will pile up to $O(N)$ space.\n\n    To sum up, the overall space complexity of the algorithm is $O(N)$.\n\n    Note: we did not take into account the space needed to hold the final results of the combination in the above analysis.\n\n---\n\nHere are a series of problems you can solve, with some tweaks of the backtracking algorithm presented in this article.\n\n[Subsets](https://leetcode.com/problems/subsets/description/)\n[Subsets II](https://leetcode.com/problems/subsets-ii/description/)\n[Permutations](https://leetcode.com/problems/permutations/description/)\n[Permutations II](https://leetcode.com/problems/permutations-ii/description/)\n[Combinations](https://leetcode.com/problems/combinations/description/)\n[Combination Sum](https://leetcode.com/problems/combination-sum/description/)\n[Combination Sum III](https://leetcode.com/problems/combination-sum-iii/description/)\n[Palindrome Partition](https://leetcode.com/problems/palindrome-partitioning/description/)\n\n---"
    },
    {
      "title": "First Missing Positive",
      "problem_id": "41",
      "frontend_id": "41",
      "difficulty": "Hard",
      "problem_slug": "first-missing-positive",
      "topics": [
        "Array",
        "Hash Table"
      ],
      "description": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.\nYou must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums = [1,2,0]\nOutput: 3\nExplanation: The numbers in the range [1,2] are all in the array.",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [3,4,-1,1]\nOutput: 2\nExplanation: 1 is in the array but 2 is missing.",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: nums = [7,8,9,11,12]\nOutput: 1\nExplanation: The smallest positive integer 1 is missing.",
          "images": []
        }
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "-231 <= nums[i] <= 231 - 1"
      ],
      "follow_ups": [],
      "hints": [
        "Think about how you would solve the problem in non-constant space.  Can you apply that logic to the existing space?",
        "We don't care about duplicates or non-positive integers",
        "Remember that O(2n) = O(n)"
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        \n    }\n};",
        "java": "class Solution {\n    public int firstMissingPositive(int[] nums) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        ",
        "c": "int firstMissingPositive(int* nums, int numsSize) {\n    \n}",
        "csharp": "public class Solution {\n    public int FirstMissingPositive(int[] nums) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar firstMissingPositive = function(nums) {\n    \n};",
        "typescript": "function firstMissingPositive(nums: number[]): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function firstMissingPositive($nums) {\n        \n    }\n}",
        "swift": "class Solution {\n    func firstMissingPositive(_ nums: [Int]) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun firstMissingPositive(nums: IntArray): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int firstMissingPositive(List<int> nums) {\n    \n  }\n}",
        "golang": "func firstMissingPositive(nums []int) int {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef first_missing_positive(nums)\n    \nend",
        "scala": "object Solution {\n    def firstMissingPositive(nums: Array[Int]): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn first_missing_positive(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (first-missing-positive nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
        "erlang": "-spec first_missing_positive(Nums :: [integer()]) -> integer().\nfirst_missing_positive(Nums) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec first_missing_positive(nums :: [integer]) :: integer\n  def first_missing_positive(nums) do\n    \n  end\nend"
      },
      "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nThe task is to find the smallest positive integer that is not present in `nums`.\n\nNote that positive integers are greater than zero.\n\nLet's discuss the two main cases:\n\n**1. No Missing Integer in `nums`:**\n\n| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n|---|---|---|---|---|---|---|---|---|\n\n`nums` contains `9` elements. The smallest missing positive integer is `10`.\n\nFor an array of length `n`, if the array contains all of the integers in the range `1` to `n`, the smallest missing positive integer is `n + 1`.\n\n**2. Missing Integer in `nums`:**\n\n|-10 | 1 | 2 | 2 | 3 | 4 | 6 | 6 | 8 |\n|----|---|---|---|---|---|---|---|---|\n\n`nums` contains `9` elements. The smallest missing positive integer is `5`.\n\nFor an array of length `n`, if the array does not contain all of the integers in the range `1` to `n`, the smallest missing positive integer is the first integer missing from that range.\n\nLet's also discuss the constraints:\n\n> You must implement an algorithm that runs in $O(n)$ time and uses $O(1)$ auxiliary space.\n\n**1. Time Complexity:**\n\nHint number three reminds us that $O(2n) = O(n)$. While we know that one does not equal two, $O$ notation describes an algorithm's limiting behavior as the input size grows toward infinity.\n\n**2. Space Complexity:**\n\nThe optimized approaches in this article use in-place solutions. Does in-place mean a constant space complexity? By [definition](https://en.wikipedia.org/wiki/In-place_algorithm), an in-place algorithm transforms the input using no auxiliary data structures proportional to the input size. An in-place algorithm does not necessarily mean constant space complexity; for example, an in-place recursive algorithm uses the recursion stack, so the space is not constant.\n\nThe problem specifically asks us to use constant *auxiliary* space, so in-place solutions meet this criterion.\n\n---\n\n### Approach 1: Boolean Array\n\n#### Intuition\n\nWe can solve the problem by iterating through the numbers `1` to `n`, and use linear search to determine whether each number is in the array. The first number we cannot find is the smallest missing integer. This approach would result in a quadratic time complexity.\n\nWe need to determine whether an element is in the array in constant time. Array indexing provides constant lookup time. We need to check the existence of a relatively small range of values, positive numbers between `1` and `n`, so we can use an array like a hash table by using the index as a key and the value as a presence indicator. The default value is `false`, which represents a missing number, and we set the value to `true` for keys that exist in `nums`. Numbers not in the range `1` to `n` are not relevant in the search for the first missing positive, so we do not mark them in the `seen` array.\n\nTo solve the problem, we can create an array of size `n + 1`. For each positive number less than `n` in `nums`, we set `seen[num]` to `true`. Then, we iterate through the integers `1` to `n` and return the first number that is not marked as seen in the array. If the array contains all of the elements `1` to `n`, we return `n + 1`.\n\n> **Note:** This approach does not meet the problem constraint of solving the problem using constant auxiliary space. It is included to make the solution accessible, and it can provide valuable background for solving the problem within the space constraints. Other approaches that do not meet the time and/or space constraints are not included as they are less relevant to understanding the following approaches.\n\n#### Algorithm\n\n1. Initialize a variable `n` to the length of `nums`.\n\n2. Initialize an array `seen` to size `n + 1`.\n\n3. Mark the elements in `nums` as seen in the array `seen`.\n\n    - For each `num` in `nums`, if `num` is greater than `0` and less than or equal to `n`, set `seen[num]` to `true`.\n\n4. Find the smallest missing positive number:\n\n    - For `i` from `1` to `n`, If `seen[i]` is not `true`, return `i`, the smallest missing integer.\n\n5. If `seen` contains all elements `1` to `n`, return `n + 1` as the smallest missing positive number.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of `nums`.\n\n* Time complexity: $O(n)$\n\n    Marking the values from `nums` in `seen` takes $O(n)$.\n\n    We check for values `1` to `n` in `seen`, which takes $O(n)$.\n\n    The total time complexity will be $O(2n)$, which we can simplify to $O(n)$.\n\n* Space complexity: $O(n)$\n\n    We initialize the array `seen`, which is size `n + 1`, so the space complexity is $O(n)$.\n\n---\n\n### Approach 2: Index as a Hash Key\n\n#### Intuition\n\n**Data Clean Up**\n\nOur search for the first missing positive focuses on the elements with values `1` through `n`. Negative numbers, zeros, and numbers larger than `n` are not relevant. Let's replace all these with `1`s. \n\n![max_first](../Figures/41/41_replace.png)\n\nTo ensure that the first missing positive is not `1`, we also have to track whether `1` exists in the original array.\n\n**Solving In-Place**\n\nNow we have an array that contains only positive numbers in a range from `1` to `n`, and the goal is to find the first missing positive in linear time and constant auxiliary space. \n\nIn the above approach, using the `seen` array introduced extra space. We can utilize `nums` itself to track which positive integers occur in the array since the range of numbers we have now is the same as the length of the array. We can use the index as a hash key for a positive number, and the sign of the element as a presence indicator.\n\nFor example, the negative sign of `nums[5]` means that the number `5` is present in `nums`. The positive sign of `nums[6]` means that the number `6` is not present (missing) in `nums`.\n\n![max_first](../Figures/41/41_true_solution.png)\n\nTo determine the smallest missing positive, we traverse the array, check each element value `value`, and change the sign of element `nums[value]` to negative to mark the number `value` as present in `nums`. We must be careful with duplicates and ensure that the sign is changed only once.\n\n> **Interview Tip: In-place Algorithms**\n>\n> This approach modifies the input by changing values of `nums`. In-place algorithms overwrite the input to save space, but sometimes this can cause problems.\n>\n> Here are a couple of situations where an in-place algorithm might not be suitable.\n>\n> 1. The algorithm needs to run in a multi-threaded environment, without exclusive access to the array. Other threads might need to read the array too, and might not expect it to be modified.\n>\n> 2. Even if there is only a single thread, or the algorithm has exclusive access to the array while running, the array might need to be reused later or by another thread once the lock has been released.\n>\n> In an interview, you should always check whether the interviewer minds you overwriting the input. Be ready to explain the pros and cons of doing so if asked!\n\n#### Algorithm\n\n1. Initialize a variable `n` to the length of `nums`, and a boolean `contains1` to `false`.\n\n2. Traverse `nums`, check whether `1` occurs, and replace negative numbers, zeros, and numbers larger than `n` with `1`. For each element in nums:\n\n    - If the element equals `1`, set `contains1` to `true`.\n    - If the element is less than or equal to `0` or greater than `n`, replace it with `1`.\n\n3. If the original `nums` array does not contain `1`, return `1`.\n\n4. Traverse `nums` using a `for` loop from `i` equals `0` to `n`. When `value` is encountered, flip the sign of the number at index `value` to negative to indicate that it is present in the array. Use absolute value to prevent duplicate occurrences of `value` from flipping the sign back to positive.\n    - Set an integer `value` to the absolute value of `nums[i]`.\n    - If `value` equals `n`, we use index `0` to save information about the presence of the number `n` since index `n` is not available. Set `nums[0]` to the negative of the absolute value of `nums[0]`.\n    - Otherwise, we use index `value` to store information about the presence of the number `value`. Set `nums[value]` to the negative of the absolute value of `nums[value]`.\n\n5. Find the smallest missing positive number:\n\n    - Iterate through the integers `1` to `n` using iterator `i`. If `nums[i]` is positive, return `i`.\n\n6. If `nums[0]` is greater than `0` return `n`.\n\n7. If `nums` contains all elements `1` to `n`, return `n + 1` as the smallest missing positive number.\n\n!?!../Documents/41_LIS.json:1000,589!?!\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of `nums`,\n\n* Time complexity: $O(n)$\n\n    We traverse `nums` using a `for` loop three separate times, so the time complexity is $O(n)$.\n\n* Space complexity: $O(n)$\n\n    We modify the array `nums` and use it to determine the answer, so the space complexity is $O(n)$.\n\n    `nums` is the input array, so the *auxiliary* space used is $O(1)$.\n\n---\n\n### Approach 3: Cycle Sort\n\n#### Intuition\n\nIn the first approach, we discussed that we can solve the problem by iterating through the numbers `1` to `n` and searching for each in the array. If `nums` were sorted, this search process could be done in linear time. The built-in sorting functions in most major languages use linear or logarithmic auxiliary space. We need a way to sort the array in-place, in constant time.\n\nThe numbers we need to check for are in the range `1` to `n`, so we can utilize [cycle sort](https://en.wikipedia.org/wiki/Cycle_sort). Cycle sort is a sorting algorithm that can sort a given sequence in a range from `a` to `n` by putting each element at the index that corresponds to its value.\n\n`nums` is a zero-indexed array, so an element with the value `x` will be located at index `x - 1`. For example, `1` goes at index `0` in the array, `2` goes at index `1`, and `100` goes at index `99`. \n\nFor each element `x` in `nums`, if it is a positive integer between `1` and `n`, we place it at index `nums[x - 1]`. Elements smaller than `1` or larger than `n` will reside at indexes that do not have a corresponding value in `nums`.\n\nThen, to determine the smallest positive integer, we iterate through `nums`, and return the first element that is not equal to its index plus one.\n\nIf we iterate through the whole sorted array without returning a value, the array consists of the sequence of numbers `1` through `n`, so we return `n + 1`.\n\n> **Notes:** \n>   - This approach modifies the input. It changes the order of `nums`, but not the values of `nums`. In-place algorithms overwrite the input to save space, but sometimes this can cause problems. Always check with your interviewer before modifying the input.\n>\n>   - We use a simplified version of cycle sort because it is not a problem if the duplicate of a value is not in the correct position.\n\n#### Algorithm\n\n1. Initialize a variable `n` to the length of `nums`.\n\n2. Use cycle sort to place positive elements smaller than `n` at the correct index.\n\n    - Initialize a variable `i` to `0`.\n    - Iterate through the elements in `nums`:\n        - Set a variable `correctIdx` to `nums[i] - 1`.\n        - If the `nums[i]` is greater than zero, less than or equal to `n`, and does not equal `nums[correctIdx]`, swap the element at `nums[i]` with the element at `nums[correctIdx]`.\n        - Otherwise, increment `i`.\n\n3. Iterate through sorted `nums` and return the smallest missing positive number.\n\n    - For each element in `nums`, if `nums[i]` does not equal `i + 1`, return `i + 1`, the smallest missing positive number.\n\n4. Return `n + 1`, the smallest missing positive number when each number in `nums` is in the correct position.\n\n!?!../Documents/41/41_slideshow.json:960,540!?!\n\n#### Implementation> **Note:** The variable `correctIdx` is included in the Python3 and Java implementations for readability. The C++ version directly uses `nums[i] - 1` to prevent integer overflow.\n\n#### Complexity Analysis\n\nLet $n$ be the length of `nums`.\n\n* Time complexity: $O(n)$\n\n    We loop through the elements in `nums` once, swapping elements to sort the array. Swapping takes constant time. Sorting `nums` using cycle sort takes $O(n)$ time. \n    \n    Iterating through the sorted array and finding the first missing positive can take up to $O(n)$. \n    \n    The total time complexity is $O(2n)$, which simplifies to $O(n)$.\n\n\n* Space complexity: $O(n)$\n\n    We modify the array `nums` and use it to determine the answer, so the space complexity is $O(n)$.\n\n    `nums` is the input array, so the *auxiliary* space used is $O(1)$.\n\n---"
    },
    {
      "title": "Trapping Rain Water",
      "problem_id": "42",
      "frontend_id": "42",
      "difficulty": "Hard",
      "problem_slug": "trapping-rain-water",
      "topics": [
        "Array",
        "Two Pointers",
        "Dynamic Programming",
        "Stack",
        "Monotonic Stack"
      ],
      "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.",
          "images": [
            "https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: height = [4,2,0,3,2,5]\nOutput: 9",
          "images": [
            "https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png"
          ]
        }
      ],
      "constraints": [
        "n == height.length",
        "1 <= n <= 2 * 104",
        "0 <= height[i] <= 105"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int trap(vector<int>& height) {\n        \n    }\n};",
        "java": "class Solution {\n    public int trap(int[] height) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        ",
        "c": "int trap(int* height, int heightSize) {\n    \n}",
        "csharp": "public class Solution {\n    public int Trap(int[] height) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} height\n * @return {number}\n */\nvar trap = function(height) {\n    \n};",
        "typescript": "function trap(height: number[]): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $height\n     * @return Integer\n     */\n    function trap($height) {\n        \n    }\n}",
        "swift": "class Solution {\n    func trap(_ height: [Int]) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun trap(height: IntArray): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int trap(List<int> height) {\n    \n  }\n}",
        "golang": "func trap(height []int) int {\n    \n}",
        "ruby": "# @param {Integer[]} height\n# @return {Integer}\ndef trap(height)\n    \nend",
        "scala": "object Solution {\n    def trap(height: Array[Int]): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn trap(height: Vec<i32>) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (trap height)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
        "erlang": "-spec trap(Height :: [integer()]) -> integer().\ntrap(Height) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec trap(height :: [integer]) :: integer\n  def trap(height) do\n    \n  end\nend"
      }
    },
    {
      "title": "Multiply Strings",
      "problem_id": "43",
      "frontend_id": "43",
      "difficulty": "Medium",
      "problem_slug": "multiply-strings",
      "topics": [
        "Math",
        "String",
        "Simulation"
      ],
      "description": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"",
          "images": []
        }
      ],
      "constraints": [
        "1 <= num1.length, num2.length <= 200",
        "num1 and num2 consist of digits only.",
        "Both num1 and num2 do not contain any leading zero, except the number 0 itself."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        \n    }\n};",
        "java": "class Solution {\n    public String multiply(String num1, String num2) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        ",
        "c": "char* multiply(char* num1, char* num2) {\n    \n}",
        "csharp": "public class Solution {\n    public string Multiply(string num1, string num2) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\nvar multiply = function(num1, num2) {\n    \n};",
        "typescript": "function multiply(num1: string, num2: string): string {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $num1\n     * @param String $num2\n     * @return String\n     */\n    function multiply($num1, $num2) {\n        \n    }\n}",
        "swift": "class Solution {\n    func multiply(_ num1: String, _ num2: String) -> String {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun multiply(num1: String, num2: String): String {\n        \n    }\n}",
        "dart": "class Solution {\n  String multiply(String num1, String num2) {\n    \n  }\n}",
        "golang": "func multiply(num1 string, num2 string) string {\n    \n}",
        "ruby": "# @param {String} num1\n# @param {String} num2\n# @return {String}\ndef multiply(num1, num2)\n    \nend",
        "scala": "object Solution {\n    def multiply(num1: String, num2: String): String = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn multiply(num1: String, num2: String) -> String {\n        \n    }\n}",
        "racket": "(define/contract (multiply num1 num2)\n  (-> string? string? string?)\n  )",
        "erlang": "-spec multiply(Num1 :: unicode:unicode_binary(), Num2 :: unicode:unicode_binary()) -> unicode:unicode_binary().\nmultiply(Num1, Num2) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec multiply(num1 :: String.t, num2 :: String.t) :: String.t\n  def multiply(num1, num2) do\n    \n  end\nend"
      },
      "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nWe are given two non-negative integers that are represented as strings and asked to return the product of the two integers, also in the form of a string. There are a few subtle challenges and edge cases that we must consider to solve this problem.  So, before determining how to multiply two numbers in string format, let's first consider a simpler variation of the problem: adding two numbers in string format.  \nWe can add two numbers represented as strings by adding digits from the given numbers in each place.  The sum of two digits must be between 0 and 18. The ones place is added to the result while the tens place is carried and summed with the next pair of digits. When summing two numbers, the carried digit will always be zero or one. This process can be repeated for each digit, as shown below.\n\n![image](../Figures/43/Slide31.JPG)\n\nWhy does learning how to add two integers represented as strings help us solve this problem? As we will soon see, addition is a subproblem of multiplication. Thus we will need to be able to solve the problem of adding two numbers as strings before we can solve the problem of multiplying two numbers as strings.\n\nIf this type of problem is new to you and you would like to practice by solving similar problems, we have provided the list below: \n1. [66. Plus One](https://leetcode.com/problems/plus-one/)      \n2. [67. Add Binary](https://leetcode.com/problems/add-binary/)      \n3. [415. Add Strings](https://leetcode.com/problems/add-strings/)  \n4. [989. Add to Array-Form of Integer](https://leetcode.com/problems/add-to-array-form-of-integer/)     \n\n\n---\n\n### Approach 1: Elementary Math\n\n#### Intuition\n\nOur goal is to multiply two integer numbers that are represented as strings. However, we are not allowed to use a built-in BigInteger library or convert the inputs to integers directly. So how can we multiply the two input strings? We can try to break the problem down into manageable chunks, as is done in elementary mathematics.  Thus, we will focus on one digit at a time, just like in the addition example, except here we will be multiplying both numbers digit by digit.  \n\n**Now, let's recall the process for multiplying two numbers.**      \nWe take the ones place digit of the second number, then multiply it with all digits of the first number consequently going backward, and write the result. We need to remember about carry as well. Note that for multiplication, carry may be any digit between 0 and 8.\n\n![image](../Figures/43/Slide1.JPG)Then we take the tens place digit of the second number and multiply it with all digits of the first number.  Since we used the tens place digit, we will multiply this result by 10.  Then we write this result below the previous result, signifying that we will **add** it to the previous result later.\n\n![image](../Figures/43/Slide2.JPG)Then we continue the same way with hundreds place digit, then with thousands place digit of the second number, and so on, until we have visited every digit in the second number.\n\n![image](../Figures/43/Slide3.JPG)As is evident from the above diagram, this process is equivalent to multiplying each digit of the second number by the entire first number and appending zeros at the end of each intermediate result based on the place in the second number that the digit came from.\nThen we add all the results together to get the final product of the first and second numbers.\n\n![image](../Figures/43/Slide4.JPG)Let's look at an example. Consider $$123 * 456$$, it can be written as,\n\n$$\\implies (123 * (6 + 50 + 400))$$      \n$$\\implies (123 * 6) + (123 * 50) + (123 * 400)$$     \n$$\\implies (123 * 6) + (123 * 5 * 10) + (123 * 4 * 100)$$     \n \n$$\\implies \\Sigma \\space ( firstNumber * j^{th} \\space digit \\space of \\space secondNumber * 10^{(index \\space j \\space of \\space digit \\space counting \\space from \\space the \\space end)} )$$      \n\nThe results of the multiplication of each digit of the second number with the first number can be stored in an array of strings, and then we can add all these strings to get the final product.     \n\n#### Algorithm\n\nMultiplication of both numbers starts from the ones place digit (the right-most digit), so we should start our multiplication from index `num2.size() - 1` and go to index `0`.  Alternatively, we can reverse both inputs and iterate from index `0` to index `num2.size() - 1`.\n\nFor each digit in `num2` that we multiply by `num1` we will get a new intermediate result.  This intermediate result (`currentResult`) will be stored in a list, string, or StringBuilder, depending on the language of choice.  To calculate each intermediate result, we will start by inserting the appropriate number of zeros according to the current digit's place in the second number (i.e. if it is the hundreds place, we append 2 zeros).  Then we will perform the multiplication step as demonstrated in the above diagrams. During this step, we will insert the lower place digits into the `currentResult` before the higher place digits.  Because we are pushing the lower place digits first and always appending to the end, our result will be in reverse order, so once the multiplication and addition steps are complete, we will need to reverse `answer` before returning.\n\nLet's walk through the steps one by one:\n\n1. Reverse both numbers.\n2. For each digit in `secondNumber`:\n    - Keep a `carry` variable, initially equal to `0`.\n    - Initialize `currentResult` array beginning with the appropriate number of zeros according to the place of the `secondNumber` digit.\n    - For each digit in `firstNumber`:\n        - Multiply the `secondNumber`'s digit and the `firstNumber`'s digit and add `carry` to the `multiplication`.\n        - Take the remainder of `multiplication` with `10` to get the last digit.\n        - Append the last digit to the `currentResult`.\n        - Divide `multiplication` by `10` to get the new value for `carry`.\n    - Append the remaining value for `carry` (if any) to the `currentResult`.\n    - Push the `currentResult` into the `results` array.\n3. Compute the cumulative sum over all the obtained arrays using the `ans` as an answer.\n4. Reverse `ans` and return it.\n\n!?!../Documents/43/slideshow1.json:960,540!?!\n\n#### Implementation#### Complexity Analysis\n\nHere $$N$$ and $$M$$ are the number of digits in `num1` and `num2` respectively.\n\n* Time complexity: $$O(M^2 + M \\cdot N)$$.\n\n  During multiplication, we perform $$N$$ operations for each of the $$M$$ digits of the second number; this requires $$O(M \\cdot N)$$ time. Then we add each of the $$M$$ multiplication results (of length $$O(N + M)$$) to the answer string; this requires $$O(M \\cdot (M + N))$$ time.\n   \n  > When we multiply a number with one digit, the result's maximum length can be at most one more than the number's length _(We can see that when we multiply the max integer of `d` digits, i.e., `9...99` with `9`)_ and there can be at most (M-1) zeroes initially appended to the result. Hence, each result is of order $$O(N + M)$$.\n   \n  Summing the results requires iterating over the length of the current answer for each result.  Since the length of two numbers multiplied together cannot be longer than the sum of the lengths of the two numbers, iterating over each digit in the answer will take $$O(M + N)$$ time and we will do so $$M - 1$$ times (for all but one of the $$M$$ results). So this step takes $$O(M \\cdot (M + N))$$ time.  \n   \n  Finally, reversing the answer will require $$O(M + N)$$ time. Taking all steps into consideration, the total time complexity is $$O(M^2 + M \\cdot N)$$.\n\n* Space complexity: $$O(M^2 + M \\cdot N)$$.     \n\n  We store each result of multiplication for each digit of `num2` with `num1` in the results array. Each multiplication result can have at most $$N + M$$ length, and there will be $$M$$ such results. Thus the space complexity is $$O(M \\cdot (M + N))$$.---\n\n### Approach 2: Elementary math using less intermediate space\n\n#### Intuition\n\nNotice that we are storing the multiplication result for every digit in `num2`. If we know the maximum size of the answer array ahead of time, we can add each multiplication result directly to the final answer. Thus, we can avoid using the extra space required by the `results` array.\n\nFirst, let's determine what the maximum size of the answer array would be.\n\nTry a few test cases on your own, multiply two numbers, count how many digits are in the result, and compare that to the number of digits in each number.  Notice that whenever two numbers with the number of digits $$N$$ and $$M$$ are multiplied, the result never exceeds $$(N+M)$$ digits. \n\nWe could readily accept thatnum1.length + num2.length ≥ (num1 · num2).lengthwithout rigorous proof. However, it never hurts to verify a relationship that was derived from observation before accepting it as a fact. Don't worry, you will not be expected to provide a proof like this during the interview, hence you can skip it if you want.The proof that the length of the product of two numbers is always less than or equal to the sum of lengths of the two numbers is as follows: (click to show/hide)> A number $$n$$ has digits, $$ d = 1 + \\lfloor log_{10}(n) \\rfloor $$.  \n   \nIts proof is:   \n> Suppose that $$n$$ has $$d$$ digits, then $$ 10^{d-1} \\leq n < 10^{d} $$, because $$ 10^{d} $$ is the smallest integer with $$d+1$$ digits.       \nNow take log base 10, then the inequality becomes $$ (d-1) \\leq \\log_{10}(n) < d $$.      \nNow everything between the range $$(d-1, \\space d)$$ is decimal part, so taking floor of $$ \\log_{10}(n) $$ we can eliminate all the decimal part and get, $$ (d-1) = \\lfloor \\log_{10}(n) \\rfloor $$.Thus, $$d = \\lfloor \\log_{10}(n) \\rfloor + 1$$.Let $$firstNumber$$ have $$N$$ digits and $$secondNumber$$ have $$M$$ digits.      \n\nLet $$product = firstNumber \\cdot secondNumber$$ have $$X$$ digits. So, number of digits in $$product$$ is,      \n           \n$$  \\implies X = 1 + \\lfloor log_{10}(result) \\rfloor   $$         \n$$  \\implies X = 1 + \\lfloor log_{10}(firstNumber \\cdot secondNumber) \\rfloor   $$         \n$$  \\implies X = 1 + \\lfloor log_{10}(firstNumber) + log_{10}(secondNumber) \\rfloor $$> A real number $$a$$ can have two parts in it, integral $$(I)$$ and fractional $$(F)$$. $$a = I_{a} + F_{a}$$.    \n\nNow, let's say we have two real numbers $$a = I_{a} + F_{a} $$ and $$b = I_{b} + F_{b}$$.$$ \\lfloor a + b \\rfloor = \\lfloor I_{a} + F_{a} + I_{b} + F_{b} \\rfloor = I_{a} + I_{b} + \\lfloor F_{a} + F_{b} \\rfloor $$     \n$$ F_{a}, F_{b} $$ are fractional parts both always less than 1.           \n$$ 0 \\leq F_{a} + F_{b} < 2 $$.      \n$$ 0 \\leq \\lfloor F_{a} + F_{b} \\rfloor <= 1 $$.> So, $$ I_{a} + I_{b} \\leq \\lfloor a + b \\rfloor \\leq  I_{a} + I_{b} + 1$$.But, $$ \\lfloor a \\rfloor + \\lfloor b \\rfloor = \\lfloor I_{a} + F_{a} \\rfloor + \\lfloor I_{b} + F_{b} \\rfloor = I_{a} + I_{b} + \\lfloor F_{a} \\rfloor + \\lfloor F_{b} \\rfloor $$     \n$$ F_{a}, F_{b} $$ are fractional parts both always less than $$ 1 $$.        \n$$ 0 \\leq F_{a}, \\space F_{b} < 1 $$.          \nHence, $$ \\lfloor F_{a} \\rfloor + \\lfloor F_{b} \\rfloor = 0 $$.> So, $$ \\lfloor a \\rfloor + \\lfloor b \\rfloor = I_{a} + I_{b} $$. \n\n> Hence we can conclude here that,> $$ \\lfloor a \\rfloor + \\lfloor b \\rfloor \\leq \\lfloor a + b \\rfloor \\leq \\lfloor a \\rfloor + \\lfloor b \\rfloor + 1 $$Number of digits in,\n$$ firstNumber = N, \\space secondNumber = M, \\space product = X $$If $$ a = log_{10}(firstNumber) $$ and $$ b = log_{10}(secondNumber) $$.     \n\n$$ N = \\lfloor log_{10} (firstNumber) \\rfloor + 1 = \\lfloor a \\rfloor + 1$$     \n$$ M = \\lfloor log_{10} (secondNumber) \\rfloor + 1 = \\lfloor b \\rfloor + 1$$     \n$$ X = \\lfloor log_{10} (firstNumber) + log_{10} (secondNumber) \\rfloor + 1 = \\lfloor a + b \\rfloor + 1$$$$ \\lfloor a \\rfloor = N - 1, \\space  \\lfloor b \\rfloor = M - 1, \\space  \\lfloor a + b \\rfloor = X - 1,  $$as, $$ \\lfloor a \\rfloor + \\lfloor b \\rfloor \\leq \\lfloor a + b \\rfloor \\leq \\lfloor a \\rfloor + \\lfloor b \\rfloor + 1 $$  \n\n$$ \\implies (N-1) + (M-1) \\leq (X - 1) \\leq (N-1) + (M-1) + 1 $$       \n$$ \\implies (N + M - 1) \\leq X \\leq (N + M) $$ \n\n> Hence, $$X$$ can never exceed $$ (N + M) $$.So an answer string of size $$N + M$$ is guaranteed to be large enough to hold our final result.  Let's create one and initialize all of its values as zero.\nInstead of storing all results of multiplication of each digit of $$num2$$ with $$num1$$ like we did in Approach 1, we can directly add the current result to the answer string.      \n\n#### Algorithm\n\n1. Reverse both numbers.\n2. Initialize `ans` array with $$(N+M)$$ zeros.\n3. For each digit in `secondNumber`:\n    - Keep a `carry` variable, initially equal to `0`.\n    - Initialize an array (`currentResult`) that begins with some zeros based on the place of the digit in `secondNumber`.\n    - For each digit of `firstNumber`:\n        - Multiply `secondNumber's` digit and `firstNumber's` digit and add previous `carry` to the `multiplication`.\n        - Take the remainder of `multiplication` with `10` to get the last digit.\n        - Append the last digit to `currentResult` array.\n        - Divide the `multiplication` by `10` to obtain the new value for `carry`.\n    - After iterating over each digit in the first number, if `carry` is not zero, append `carry` to the `currentResult`.\n    - Add `currentResult` to the `ans`.\n4. If the last digit in `ans` is zero, before reversing `ans`, we must pop the zero from `ans`. Otherwise, there would be a leading zero in the final answer.\n5. Reverse `ans` and return it.\n\n!?!../Documents/43/slideshow2.json:960,540!?!\n\n#### Implementation#### Complexity Analysis\n\nHere $$N$$ and $$M$$ are the number of elements in num 1 and num 2 strings.\n\n* Time complexity: $$O(M \\cdot (N+M))$$.     \n   - During multiplication, we perform `N` operations for each of the `M` digits of the second number, so we need $$O(M \\cdot N)$$ time for it.     \n   - We add the multiplication result to the `ans` string that has a length of $$N+M$$. There will be $$M$$ such additions since we have $$M$$ multiplication results. Therefore, the time consumed here will be $$O(M \\cdot (N+M))$$.\n   - It takes linear time to reverse the strings.\n   - Overall, this solution takes $$O(M \\cdot N + M \\cdot (N+M) + M + N) = O(M \\cdot (N+M))$$ time.\n\n* Space complexity: $$O(N + M)$$.     \n   - The answer string and multiplication results will have at most $$N + M$$ length.---\n\n### Approach 3: Sum the products from all pairs of digits\n\n#### Intuition\n\nAs we have seen in the previous approaches, when we multiply two digits, one from the first number and one from the second number, then their product will have some zeros appended at the end. The number of zeros depends on the place of each digit, and (as demonstrated in the image below) when the result is added to the answer, the trailing zeros do not affect the answer (because any number plus zero is itself).\nSo it is not necessary for us to append zeros at the end of each result before adding the result to the final answer. Instead, we can directly add the multiplication result at the place where the least significant digit will shift to after to appending some zeros.  \n\nAs an example, when we multiply two tens place digits, two zeros are appended at the end of the multiplication result, and the result will be added at the hundreds place in the final answer. One more example for clarity, if we multiplied a digit in the thousands place (3 trailing zeros) by a digit in the hundreds place (2 trailing zeros), the product will have 5 trailing zeros (the sum of trailing zeros of each digit) so the result will only affect the hundred thousands place and the millions place in the final answer.  \n\n![image](../Figures/43/Slide32.JPG)In the previous solution, including the extra zeros was quite costly.  For instance, `multiplyOneDigit` stored these extra zeros for every intermediate result which required an additional $$O(N)$$ space and time for each multiplication, where $$N$$ is the number of digits in `num2`.  Furthermore, every time we called `multiplyOneDigit` we added the result to the current `answer`.  This involved iterating over all $$M + N$$ digits in answer each time we added a new result to the current answer. So let's get a better idea of how we can solve this problem without iterating over all the extra zeros.\n\nTake a moment to study the above example.  Notice that we multiply each digit in `num2` by each digit in `num1` just like before. Each time we will get a 2-digit result with some zeros after it. Since we know how many zeros will follow the product of the two digits based on their places, we know which two places in `answer` to update.  So, instead of updating all $$M + N$$ elements in `answer` for each of the $$N$$ digits in `num2`, we only need to update $$2$$ digits in `answer` for each of the $$M \\cdot N$$ pairs of digits.  The above example highlights the two digits from each result that we will add to the answer and the below example shows precisely how this will be done.\n\nThus, for each pair of digits, we multiply them together to get a 2-digit result. The ones place of the result will be added at the correct position in `answer` (based on the place of each of the digits). The tens place of the result will be added to the next place in `answer`. This step is effectively the same as carrying the tens place digit in the previous approaches.\n\nNote that the `answer` array will be reversed just like before. So when we multiply a digit in the $$i^{th}$$ place of the first number by a digit in the $$j^{th}$$ place of the second number, then the ones place of the result will add to the $$(i+j)^{th}$$ place in the final answer and the tens place of the result (carry) will be added to the $$(i+j+1)^{th}$$ place in the final answer. \n\n\n#### Algorithm\n\n1. Reverse both numbers.\n2. Initialize `answer` with $$N + M$$ zeros.\n3. For each digit at position `i` in `secondNumber`:\n    - For each digit at position `j` in `firstNumber`:\n        - Multiply the digit from `secondNumber` by the digit from `firstNumber` and add previously carried value to the `multiplication` result.  The previously carried value can be found at position `i + j` in the `answer`.\n        - Take the remainder of `multiplication` with `10` to get the ones place digit of the `multiplication` result.\n        - Put the last digit at current position (position `i + j`) in `answer`.\n        - Divide the `multiplication` by `10` to get the new value for carry and add it to `answer` at the next position.  Note, the next position is located at `(i + j + 1)`.\n4. If the last digit in `answer` is zero, before reversing `answer`, we must pop the zero from `answer`. Otherwise, there would be a leading zero in the final answer.\n5. Reverse `answer` and return it.\n\n!?!../Documents/43/slideshow3.json:960,540!?!\n\n#### Implementation#### Complexity Analysis\n\nHere $$N$$ and $$M$$ are the number of digits in `num1` and `num2` respectively.\n\n* Time complexity: $$O(M \\cdot N)$$.     \n\n  During multiplication, we perform `N` operations for each of the `M` digits of the second number, so we need $$M \\cdot N$$ time for it.\n\n* Space complexity: $$O(M + N)$$.     \n\n  The space used to store the output is not included in the space complexity. However, because strings are immutable in Python, Java, and Javascript, a temporary data structure, using $$O(M + N)$$ space, is required to store the answer while it is updated.\n  \n  On the other hand, in C++, strings are mutable, so we do not need a temporary data structure to store answer and can update answer directly.  Thus, the C++ approach is a constant space solution."
    },
    {
      "title": "Wildcard Matching",
      "problem_id": "44",
      "frontend_id": "44",
      "difficulty": "Hard",
      "problem_slug": "wildcard-matching",
      "topics": [
        "String",
        "Dynamic Programming",
        "Greedy",
        "Recursion"
      ],
      "description": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\nThe matching should cover the entire input string (not partial).\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: s = \"aa\", p = \"*\"\nOutput: true\nExplanation: '*' matches any sequence.",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: s = \"cb\", p = \"?a\"\nOutput: false\nExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.",
          "images": []
        }
      ],
      "constraints": [
        "0 <= s.length, p.length <= 2000",
        "s contains only lowercase English letters.",
        "p contains only lowercase English letters, '?' or '*'."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        \n    }\n};",
        "java": "class Solution {\n    public boolean isMatch(String s, String p) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        ",
        "c": "bool isMatch(char* s, char* p) {\n    \n}",
        "csharp": "public class Solution {\n    public bool IsMatch(string s, string p) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} s\n * @param {string} p\n * @return {boolean}\n */\nvar isMatch = function(s, p) {\n    \n};",
        "typescript": "function isMatch(s: string, p: string): boolean {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String $p\n     * @return Boolean\n     */\n    function isMatch($s, $p) {\n        \n    }\n}",
        "swift": "class Solution {\n    func isMatch(_ s: String, _ p: String) -> Bool {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun isMatch(s: String, p: String): Boolean {\n        \n    }\n}",
        "dart": "class Solution {\n  bool isMatch(String s, String p) {\n    \n  }\n}",
        "golang": "func isMatch(s string, p string) bool {\n    \n}",
        "ruby": "# @param {String} s\n# @param {String} p\n# @return {Boolean}\ndef is_match(s, p)\n    \nend",
        "scala": "object Solution {\n    def isMatch(s: String, p: String): Boolean = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn is_match(s: String, p: String) -> bool {\n        \n    }\n}",
        "racket": "(define/contract (is-match s p)\n  (-> string? string? boolean?)\n  )",
        "erlang": "-spec is_match(S :: unicode:unicode_binary(), P :: unicode:unicode_binary()) -> boolean().\nis_match(S, P) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec is_match(s :: String.t, p :: String.t) :: boolean\n  def is_match(s, p) do\n    \n  end\nend"
      }
    },
    {
      "title": "Jump Game II",
      "problem_id": "45",
      "frontend_id": "45",
      "difficulty": "Medium",
      "problem_slug": "jump-game-ii",
      "topics": [
        "Array",
        "Dynamic Programming",
        "Greedy"
      ],
      "description": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\nReturn the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [2,3,0,1,4]\nOutput: 2",
          "images": []
        }
      ],
      "constraints": [
        "1 <= nums.length <= 104",
        "0 <= nums[i] <= 1000",
        "It's guaranteed that you can reach nums[n - 1]."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int jump(vector<int>& nums) {\n        \n    }\n};",
        "java": "class Solution {\n    public int jump(int[] nums) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        ",
        "c": "int jump(int* nums, int numsSize) {\n    \n}",
        "csharp": "public class Solution {\n    public int Jump(int[] nums) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar jump = function(nums) {\n    \n};",
        "typescript": "function jump(nums: number[]): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function jump($nums) {\n        \n    }\n}",
        "swift": "class Solution {\n    func jump(_ nums: [Int]) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun jump(nums: IntArray): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int jump(List<int> nums) {\n    \n  }\n}",
        "golang": "func jump(nums []int) int {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef jump(nums)\n    \nend",
        "scala": "object Solution {\n    def jump(nums: Array[Int]): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn jump(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (jump nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
        "erlang": "-spec jump(Nums :: [integer()]) -> integer().\njump(Nums) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec jump(nums :: [integer]) :: integer\n  def jump(nums) do\n    \n  end\nend"
      }
    },
    {
      "title": "Permutations",
      "problem_id": "46",
      "frontend_id": "46",
      "difficulty": "Medium",
      "problem_slug": "permutations",
      "topics": [
        "Array",
        "Backtracking"
      ],
      "description": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [0,1]\nOutput: [[0,1],[1,0]]",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: nums = [1]\nOutput: [[1]]",
          "images": []
        }
      ],
      "constraints": [
        "1 <= nums.length <= 6",
        "-10 <= nums[i] <= 10",
        "All the integers of nums are unique."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        ",
        "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\n    \n}",
        "csharp": "public class Solution {\n    public IList<IList<int>> Permute(int[] nums) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permute = function(nums) {\n    \n};",
        "typescript": "function permute(nums: number[]): number[][] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[][]\n     */\n    function permute($nums) {\n        \n    }\n}",
        "swift": "class Solution {\n    func permute(_ nums: [Int]) -> [[Int]] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun permute(nums: IntArray): List<List<Int>> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<List<int>> permute(List<int> nums) {\n    \n  }\n}",
        "golang": "func permute(nums []int) [][]int {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @return {Integer[][]}\ndef permute(nums)\n    \nend",
        "scala": "object Solution {\n    def permute(nums: Array[Int]): List[List[Int]] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn permute(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        \n    }\n}",
        "racket": "(define/contract (permute nums)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)))\n  )",
        "erlang": "-spec permute(Nums :: [integer()]) -> [[integer()]].\npermute(Nums) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec permute(nums :: [integer]) :: [[integer]]\n  def permute(nums) do\n    \n  end\nend"
      }
    },
    {
      "title": "Permutations II",
      "problem_id": "47",
      "frontend_id": "47",
      "difficulty": "Medium",
      "problem_slug": "permutations-ii",
      "topics": [
        "Array",
        "Backtracking",
        "Sorting"
      ],
      "description": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "images": []
        }
      ],
      "constraints": [
        "1 <= nums.length <= 8",
        "-10 <= nums[i] <= 10"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        ",
        "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** permuteUnique(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\n    \n}",
        "csharp": "public class Solution {\n    public IList<IList<int>> PermuteUnique(int[] nums) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permuteUnique = function(nums) {\n    \n};",
        "typescript": "function permuteUnique(nums: number[]): number[][] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[][]\n     */\n    function permuteUnique($nums) {\n        \n    }\n}",
        "swift": "class Solution {\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun permuteUnique(nums: IntArray): List<List<Int>> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<List<int>> permuteUnique(List<int> nums) {\n    \n  }\n}",
        "golang": "func permuteUnique(nums []int) [][]int {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @return {Integer[][]}\ndef permute_unique(nums)\n    \nend",
        "scala": "object Solution {\n    def permuteUnique(nums: Array[Int]): List[List[Int]] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        \n    }\n}",
        "racket": "(define/contract (permute-unique nums)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)))\n  )",
        "erlang": "-spec permute_unique(Nums :: [integer()]) -> [[integer()]].\npermute_unique(Nums) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec permute_unique(nums :: [integer]) :: [[integer]]\n  def permute_unique(nums) do\n    \n  end\nend"
      },
      "solution": "[TOC]\n\n## Solution\n\n---\n### Overview\n\nAs the name of the problem suggests, this problem is an extension of the [Permutation](https://leetcode.com/problems/permutations/) problem.\nThe problem is different from the previous permutation problem on the condition that the input array can contain **_duplicates_**.\n\nThe key to solve the problem is still the **_backtracking_** algorithm.\nHowever, we need some adaptation to ensure that the _enumerated_ solutions generated from our backtracking exploration do not have any duplicates.\n\n>As a reminder, **[backtracking](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/)** is a general algorithm for finding all (or some) solutions to some problems with constraints.\nIt incrementally builds candidates to the solutions, and abandons a candidate as soon as it determines that the candidate cannot possibly lead to a solution.\n\nIn this article, we will present a yet another backtracking solution to solve the problem.\n\n---\n### Approach 1: Backtracking with Groups of Numbers\n\n**Intuition**\n\nFirst of all, let us review the general idea of permutation with an example.\n\nGiven the input array `[1, 1, 2]`, to generate a permutation of the array, we could follow the _Depth-First Search_ (DFS) approach, or more precisely the backtracking technique as one will see later.\n\n>The idea is that we pick the numbers one by one. For a permutation of length $$N$$, we would then need $$N$$ stages to generate a valid permutation.\nAt each stage, we need to pick one number into the permutation, out of the remaining available numbers.\nLater at the same stage, we will try out all available choices.\nBy trying out, we progressively build up candidates to the solution, and revert each choice with another alternative until there is no more choice.\n\nLet us walk through the example with paper and pencil, as follows:\n\n- Given the input of `[1, 1, 2]`, at the first stage, we have 2 choices to pick a number as the first number in the final permutation, _i.e._ `1` and `2`.\nSuppose that we pick the number `1`, now the remaining numbers would become `[1, 2]`.\n**Note:** The reason that we have only 2 choices instead of 3, is that there is a duplicate in the given input.\nPicking any of the duplicate numbers as the first number of the permutation would lead us to the same permutation at the end.\nShould the numbers in the array be all unique, we would then have the same number of choices as the length of the array. \n\n- At the second stage, we now then have again 2 choices, _i.e._ `[1, 2]`. \nLet us pick again the number `1`, which leaves us the only remaining number `2`.\n\n- Now at the third stage, we have only one candidate number left, _i.e._ `[2]`. We then pick the last remaining number, which leads to a final permutation sequence of `[1, 1, 2]`.\n\n- Moreover, we need to **_revisit_** each of the above stages, and make a different choice in order to try out all possibilities.\nThe reversion of the choices is what we call __*backtracking*__.\n\nWe illustrate all potential exploration in the following graph where each node represents a choice at a specific stage:\n\n![permutation tree](../Figures/47/47_permutations.png)\n\n>A key insight to avoid generating any **_redundant_** permutation is that at each step rather than viewing each number as a candidate, we consider each **_unique_** number as the true candidate.\nFor instance, at the very beginning, given in the input of `[1, 1, 2]`, we have only two true candidates instead of three.\n\n\n**Algorithm**\n\nGiven the above insight, in order to find out all the unique numbers at each stage, we can build a **_hash table_** (denoted as `counter`), with each unique number as the key and its occurrence as the corresponding value.\n\nTo implement the algorithm, first we define a function called `backtrack(comb, counter)` which generates all permutations, starting from the current combination (`comb`) and the remaining numbers (`counter`).\n\nOnce the function is implemented, it suffices to invoke the function with the initial empty combination and the hash table we built out of the input array, to solve the problem.\n\nHere are some sample implementations.**Note:** for a backtracking algorithm, usually there are some explorations that would lead to a *dead end*, and we have to abandon those explorations in the middle.\n\nHowever, due to the specificity of this problem and our exploration strategy, each exploration will result in a valid permutation, _i.e._ none of the efforts is in vain.\nThis insight would prove to be useful in the following complexity analysis.\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of the input array.\nHence, the number of permutations would be at maximum $$N!$$, _i.e._ $$N \\cdot (N-1) \\cdot (N-2) ... 1$$, when each number in the array is unique.\n\n- Time Complexity: $$\\mathcal{O}\\big(\\sum_{k = 1}^{N}{P(N, k)}\\big)$$ where $$P(N, k) = \\frac{N!}{(N - k)!} = N (N - 1) ... (N - k + 1)$$\nis so-called [_k-permutations_of_N_ or _partial permutation_](https://en.wikipedia.org/wiki/Permutation#k-permutations_of_n). \n\n    - As one can see in the exploration graph we have shown earlier, the execution of the backtracking algorithm will unfold itself as a tree, where each node is an invocation of the recursive function `backtrack(comb, counter)`.\n    The total number of steps to complete the exploration is _exactly_ the number of nodes in the tree.\n    Therefore, the time complexity of the algorithm is linked directly with the size of the tree.\n\n    - It now boils down to estimating the number of nodes in the tree.\n    As we know now, each level of the tree corresponds to a specific _stage_ of the exploration.\n    At each stage, the number of candidates to explore is **bounded**.\n    For instance, at the first stage, _at most_ we would have $$N$$ candidates to explore, _i.e._ the number of nodes at this level would be $$N$$.\n    Moving on to the next stage, for each of the nodes in the first stage, we would have $$N-1$$ child nodes. Therefore, the number of nodes at this stage would be $$N \\cdot (N-1)$$.\n    So on and so forwards.\n\n    ![number of nodes](../Figures/47/47_number_of_nodes.png)\n\n    - By summing up all the nodes across the stages, we would then obtain the total number of nodes as $$\\sum_{k = 1}^{N}{P(N, k)}$$ where $$P(N, k) = \\frac{N!}{(N - k)!} = N (N - 1) ... (N - k + 1)$$.\n    As a result, the exact time complexity of the algorithm is $$\\mathcal{O}\\big(\\sum_{k = 1}^{N}{P(N, k)}\\big)$$.\n\n    - The above complexity might appear a bit too abstract to comprehend.\n    Here we could provide another __*loose upper bound*__ on the complexity.\n\n    - It takes $$N$$ steps to generate a single permutation. Since there are in total $$N!$$ possible permutations, at most it would take us $$N \\cdot N!$$ steps to generate all permutations, simply assuming that there is no overlapping effort (which is not true).\n\n\n- Space Complexity: $$\\mathcal{O}(N)$$\n\n    - First of all, we build a hash table out of the input numbers. In the worst case where each number is unique, we would need $$\\mathcal{O}(N)$$ space for the table.\n\n    - Since we applied recursion in the algorithm which consumes some extra space in the function call stack, we would need another $$\\mathcal{O}(N)$$ space for the recursion.\n\n    - During the exploration, we keep a candidate of permutation along the way, which takes yet another $$\\mathcal{O}(N)$$.\n\n    - To sum up, the total space complexity would be $$\\mathcal{O}(N) + \\mathcal{O}(N) + \\mathcal{O}(N) = \\mathcal{O}(N)$$.\n\n    - **Note**, we did not take into account the space needed to hold the results. Otherwise, the space complexity would become $$\\mathcal{O}(N \\cdot N!)$$.\n\n\n---"
    },
    {
      "title": "Rotate Image",
      "problem_id": "48",
      "frontend_id": "48",
      "difficulty": "Medium",
      "problem_slug": "rotate-image",
      "topics": [
        "Array",
        "Math",
        "Matrix"
      ],
      "description": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]",
          "images": [
            "https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
          "images": [
            "https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg"
          ]
        }
      ],
      "constraints": [
        "n == matrix.length == matrix[i].length",
        "1 <= n <= 20",
        "-1000 <= matrix[i][j] <= 1000"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        \n    }\n};",
        "java": "class Solution {\n    public void rotate(int[][] matrix) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        ",
        "c": "void rotate(int** matrix, int matrixSize, int* matrixColSize) {\n    \n}",
        "csharp": "public class Solution {\n    public void Rotate(int[][] matrix) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nvar rotate = function(matrix) {\n    \n};",
        "typescript": "/**\n Do not return anything, modify matrix in-place instead.\n */\nfunction rotate(matrix: number[][]): void {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[][] $matrix\n     * @return NULL\n     */\n    function rotate(&$matrix) {\n        \n    }\n}",
        "swift": "class Solution {\n    func rotate(_ matrix: inout [[Int]]) {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun rotate(matrix: Array<IntArray>): Unit {\n        \n    }\n}",
        "dart": "class Solution {\n  void rotate(List<List<int>> matrix) {\n    \n  }\n}",
        "golang": "func rotate(matrix [][]int)  {\n    \n}",
        "ruby": "# @param {Integer[][]} matrix\n# @return {Void} Do not return anything, modify matrix in-place instead.\ndef rotate(matrix)\n    \nend",
        "scala": "object Solution {\n    def rotate(matrix: Array[Array[Int]]): Unit = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {\n        \n    }\n}"
      }
    },
    {
      "title": "Group Anagrams",
      "problem_id": "49",
      "frontend_id": "49",
      "difficulty": "Medium",
      "problem_slug": "group-anagrams",
      "topics": [
        "Array",
        "Hash Table",
        "String",
        "Sorting"
      ],
      "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\nExplanation:",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: strs = [\"\"]\nOutput: [[\"\"]]",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: strs = [\"a\"]\nOutput: [[\"a\"]]",
          "images": []
        }
      ],
      "constraints": [
        "1 <= strs.length <= 104",
        "0 <= strs[i].length <= 100",
        "strs[i] consists of lowercase English letters."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        ",
        "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nchar*** groupAnagrams(char** strs, int strsSize, int* returnSize, int** returnColumnSizes) {\n    \n}",
        "csharp": "public class Solution {\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string[]} strs\n * @return {string[][]}\n */\nvar groupAnagrams = function(strs) {\n    \n};",
        "typescript": "function groupAnagrams(strs: string[]): string[][] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String[] $strs\n     * @return String[][]\n     */\n    function groupAnagrams($strs) {\n        \n    }\n}",
        "swift": "class Solution {\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun groupAnagrams(strs: Array<String>): List<List<String>> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<List<String>> groupAnagrams(List<String> strs) {\n    \n  }\n}",
        "golang": "func groupAnagrams(strs []string) [][]string {\n    \n}",
        "ruby": "# @param {String[]} strs\n# @return {String[][]}\ndef group_anagrams(strs)\n    \nend",
        "scala": "object Solution {\n    def groupAnagrams(strs: Array[String]): List[List[String]] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\n        \n    }\n}",
        "racket": "(define/contract (group-anagrams strs)\n  (-> (listof string?) (listof (listof string?)))\n  )",
        "erlang": "-spec group_anagrams(Strs :: [unicode:unicode_binary()]) -> [[unicode:unicode_binary()]].\ngroup_anagrams(Strs) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec group_anagrams(strs :: [String.t]) :: [[String.t]]\n  def group_anagrams(strs) do\n    \n  end\nend"
      }
    },
    {
      "title": "Pow(x, n)",
      "problem_id": "50",
      "frontend_id": "50",
      "difficulty": "Medium",
      "problem_slug": "powx-n",
      "topics": [
        "Math",
        "Recursion"
      ],
      "description": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: x = 2.00000, n = 10\nOutput: 1024.00000",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: x = 2.10000, n = 3\nOutput: 9.26100",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: x = 2.00000, n = -2\nOutput: 0.25000\nExplanation: 2-2 = 1/22 = 1/4 = 0.25",
          "images": []
        }
      ],
      "constraints": [
        "-100.0 < x < 100.0",
        "-231 <= n <= 231-1",
        "n is an integer.",
        "Either x is not zero or n > 0.",
        "-104 <= xn <= 104"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    double myPow(double x, int n) {\n        \n    }\n};",
        "java": "class Solution {\n    public double myPow(double x, int n) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        ",
        "c": "double myPow(double x, int n) {\n    \n}",
        "csharp": "public class Solution {\n    public double MyPow(double x, int n) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number} x\n * @param {number} n\n * @return {number}\n */\nvar myPow = function(x, n) {\n    \n};",
        "typescript": "function myPow(x: number, n: number): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Float $x\n     * @param Integer $n\n     * @return Float\n     */\n    function myPow($x, $n) {\n        \n    }\n}",
        "swift": "class Solution {\n    func myPow(_ x: Double, _ n: Int) -> Double {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun myPow(x: Double, n: Int): Double {\n        \n    }\n}",
        "dart": "class Solution {\n  double myPow(double x, int n) {\n    \n  }\n}",
        "golang": "func myPow(x float64, n int) float64 {\n    \n}",
        "ruby": "# @param {Float} x\n# @param {Integer} n\n# @return {Float}\ndef my_pow(x, n)\n    \nend",
        "scala": "object Solution {\n    def myPow(x: Double, n: Int): Double = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn my_pow(x: f64, n: i32) -> f64 {\n        \n    }\n}",
        "racket": "(define/contract (my-pow x n)\n  (-> flonum? exact-integer? flonum?)\n  )",
        "erlang": "-spec my_pow(X :: float(), N :: integer()) -> float().\nmy_pow(X, N) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec my_pow(x :: float, n :: integer) :: float\n  def my_pow(x, n) do\n    \n  end\nend"
      }
    },
    {
      "title": "N-Queens",
      "problem_id": "51",
      "frontend_id": "51",
      "difficulty": "Hard",
      "problem_slug": "n-queens",
      "topics": [
        "Array",
        "Backtracking"
      ],
      "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: n = 4\nOutput: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above",
          "images": [
            "https://assets.leetcode.com/uploads/2020/11/13/queens.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: n = 1\nOutput: [[\"Q\"]]",
          "images": [
            "https://assets.leetcode.com/uploads/2020/11/13/queens.jpg"
          ]
        }
      ],
      "constraints": [
        "1 <= n <= 9"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<vector<string>> solveNQueens(int n) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<List<String>> solveNQueens(int n) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        ",
        "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nchar*** solveNQueens(int n, int* returnSize, int** returnColumnSizes) {\n    \n}",
        "csharp": "public class Solution {\n    public IList<IList<string>> SolveNQueens(int n) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number} n\n * @return {string[][]}\n */\nvar solveNQueens = function(n) {\n    \n};",
        "typescript": "function solveNQueens(n: number): string[][] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return String[][]\n     */\n    function solveNQueens($n) {\n        \n    }\n}",
        "swift": "class Solution {\n    func solveNQueens(_ n: Int) -> [[String]] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun solveNQueens(n: Int): List<List<String>> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<List<String>> solveNQueens(int n) {\n    \n  }\n}",
        "golang": "func solveNQueens(n int) [][]string {\n    \n}",
        "ruby": "# @param {Integer} n\n# @return {String[][]}\ndef solve_n_queens(n)\n    \nend",
        "scala": "object Solution {\n    def solveNQueens(n: Int): List[List[String]] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn solve_n_queens(n: i32) -> Vec<Vec<String>> {\n        \n    }\n}",
        "racket": "(define/contract (solve-n-queens n)\n  (-> exact-integer? (listof (listof string?)))\n  )",
        "erlang": "-spec solve_n_queens(N :: integer()) -> [[unicode:unicode_binary()]].\nsolve_n_queens(N) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec solve_n_queens(n :: integer) :: [[String.t]]\n  def solve_n_queens(n) do\n    \n  end\nend"
      }
    },
    {
      "title": "N-Queens II",
      "problem_id": "52",
      "frontend_id": "52",
      "difficulty": "Hard",
      "problem_slug": "n-queens-ii",
      "topics": [
        "Backtracking"
      ],
      "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to the n-queens puzzle.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: n = 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown.",
          "images": [
            "https://assets.leetcode.com/uploads/2020/11/13/queens.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: n = 1\nOutput: 1",
          "images": [
            "https://assets.leetcode.com/uploads/2020/11/13/queens.jpg"
          ]
        }
      ],
      "constraints": [
        "1 <= n <= 9"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int totalNQueens(int n) {\n        \n    }\n};",
        "java": "class Solution {\n    public int totalNQueens(int n) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        ",
        "c": "int totalNQueens(int n) {\n    \n}",
        "csharp": "public class Solution {\n    public int TotalNQueens(int n) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number} n\n * @return {number}\n */\nvar totalNQueens = function(n) {\n    \n};",
        "typescript": "function totalNQueens(n: number): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function totalNQueens($n) {\n        \n    }\n}",
        "swift": "class Solution {\n    func totalNQueens(_ n: Int) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun totalNQueens(n: Int): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int totalNQueens(int n) {\n    \n  }\n}",
        "golang": "func totalNQueens(n int) int {\n    \n}",
        "ruby": "# @param {Integer} n\n# @return {Integer}\ndef total_n_queens(n)\n    \nend",
        "scala": "object Solution {\n    def totalNQueens(n: Int): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn total_n_queens(n: i32) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (total-n-queens n)\n  (-> exact-integer? exact-integer?)\n  )",
        "erlang": "-spec total_n_queens(N :: integer()) -> integer().\ntotal_n_queens(N) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec total_n_queens(n :: integer) :: integer\n  def total_n_queens(n) do\n    \n  end\nend"
      }
    },
    {
      "title": "Maximum Subarray",
      "problem_id": "53",
      "frontend_id": "53",
      "difficulty": "Medium",
      "problem_slug": "maximum-subarray",
      "topics": [
        "Array",
        "Divide and Conquer",
        "Dynamic Programming"
      ],
      "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.",
          "images": []
        }
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "-104 <= nums[i] <= 104"
      ],
      "follow_ups": [
        "If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle."
      ],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        \n    }\n};",
        "java": "class Solution {\n    public int maxSubArray(int[] nums) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        ",
        "c": "int maxSubArray(int* nums, int numsSize) {\n    \n}",
        "csharp": "public class Solution {\n    public int MaxSubArray(int[] nums) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function(nums) {\n    \n};",
        "typescript": "function maxSubArray(nums: number[]): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maxSubArray($nums) {\n        \n    }\n}",
        "swift": "class Solution {\n    func maxSubArray(_ nums: [Int]) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun maxSubArray(nums: IntArray): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int maxSubArray(List<int> nums) {\n    \n  }\n}",
        "golang": "func maxSubArray(nums []int) int {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef max_sub_array(nums)\n    \nend",
        "scala": "object Solution {\n    def maxSubArray(nums: Array[Int]): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn max_sub_array(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (max-sub-array nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
        "erlang": "-spec max_sub_array(Nums :: [integer()]) -> integer().\nmax_sub_array(Nums) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec max_sub_array(nums :: [integer]) :: integer\n  def max_sub_array(nums) do\n    \n  end\nend"
      }
    },
    {
      "title": "Spiral Matrix",
      "problem_id": "54",
      "frontend_id": "54",
      "difficulty": "Medium",
      "problem_slug": "spiral-matrix",
      "topics": [
        "Array",
        "Matrix",
        "Simulation"
      ],
      "description": "Given an m x n matrix, return all elements of the matrix in spiral order.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]",
          "images": [
            "https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]",
          "images": [
            "https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg"
          ]
        }
      ],
      "constraints": [
        "m == matrix.length",
        "n == matrix[i].length",
        "1 <= m, n <= 10",
        "-100 <= matrix[i][j] <= 100"
      ],
      "follow_ups": [],
      "hints": [
        "Well for some problems, the best way really is to come up with some algorithms for simulation. Basically, you need to simulate what the problem asks us to do.",
        "We go boundary by boundary and move inwards. That is the essential operation. First row, last column, last row, first column, and then we move inwards by 1 and repeat. That's all. That is all the simulation that we need.",
        "Think about when you want to switch the progress on one of the indexes. If you progress on i out of [i, j], you'll shift in the same column. Similarly, by changing values for j, you'd be shifting in the same row.\r\nAlso, keep track of the end of a boundary so that you can move inwards and then keep repeating. It's always best to simulate edge cases like a single column or a single row to see if anything breaks or not."
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        ",
        "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) {\n    \n}",
        "csharp": "public class Solution {\n    public IList<int> SpiralOrder(int[][] matrix) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\nvar spiralOrder = function(matrix) {\n    \n};",
        "typescript": "function spiralOrder(matrix: number[][]): number[] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[][] $matrix\n     * @return Integer[]\n     */\n    function spiralOrder($matrix) {\n        \n    }\n}",
        "swift": "class Solution {\n    func spiralOrder(_ matrix: [[Int]]) -> [Int] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun spiralOrder(matrix: Array<IntArray>): List<Int> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<int> spiralOrder(List<List<int>> matrix) {\n    \n  }\n}",
        "golang": "func spiralOrder(matrix [][]int) []int {\n    \n}",
        "ruby": "# @param {Integer[][]} matrix\n# @return {Integer[]}\ndef spiral_order(matrix)\n    \nend",
        "scala": "object Solution {\n    def spiralOrder(matrix: Array[Array[Int]]): List[Int] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn spiral_order(matrix: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}",
        "racket": "(define/contract (spiral-order matrix)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?))\n  )",
        "erlang": "-spec spiral_order(Matrix :: [[integer()]]) -> [integer()].\nspiral_order(Matrix) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec spiral_order(matrix :: [[integer]]) :: [integer]\n  def spiral_order(matrix) do\n    \n  end\nend"
      }
    },
    {
      "title": "Jump Game",
      "problem_id": "55",
      "frontend_id": "55",
      "difficulty": "Medium",
      "problem_slug": "jump-game",
      "topics": [
        "Array",
        "Dynamic Programming",
        "Greedy"
      ],
      "description": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.",
          "images": []
        }
      ],
      "constraints": [
        "1 <= nums.length <= 104",
        "0 <= nums[i] <= 105"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        \n    }\n};",
        "java": "class Solution {\n    public boolean canJump(int[] nums) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        ",
        "c": "bool canJump(int* nums, int numsSize) {\n    \n}",
        "csharp": "public class Solution {\n    public bool CanJump(int[] nums) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canJump = function(nums) {\n    \n};",
        "typescript": "function canJump(nums: number[]): boolean {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Boolean\n     */\n    function canJump($nums) {\n        \n    }\n}",
        "swift": "class Solution {\n    func canJump(_ nums: [Int]) -> Bool {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun canJump(nums: IntArray): Boolean {\n        \n    }\n}",
        "dart": "class Solution {\n  bool canJump(List<int> nums) {\n    \n  }\n}",
        "golang": "func canJump(nums []int) bool {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @return {Boolean}\ndef can_jump(nums)\n    \nend",
        "scala": "object Solution {\n    def canJump(nums: Array[Int]): Boolean = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn can_jump(nums: Vec<i32>) -> bool {\n        \n    }\n}",
        "racket": "(define/contract (can-jump nums)\n  (-> (listof exact-integer?) boolean?)\n  )",
        "erlang": "-spec can_jump(Nums :: [integer()]) -> boolean().\ncan_jump(Nums) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec can_jump(nums :: [integer]) :: boolean\n  def can_jump(nums) do\n    \n  end\nend"
      }
    },
    {
      "title": "Merge Intervals",
      "problem_id": "56",
      "frontend_id": "56",
      "difficulty": "Medium",
      "problem_slug": "merge-intervals",
      "topics": [
        "Array",
        "Sorting"
      ],
      "description": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.",
          "images": []
        }
      ],
      "constraints": [
        "1 <= intervals.length <= 104",
        "intervals[i].length == 2",
        "0 <= starti <= endi <= 104"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        \n    }\n};",
        "java": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        ",
        "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes) {\n    \n}",
        "csharp": "public class Solution {\n    public int[][] Merge(int[][] intervals) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[][]} intervals\n * @return {number[][]}\n */\nvar merge = function(intervals) {\n    \n};",
        "typescript": "function merge(intervals: number[][]): number[][] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[][] $intervals\n     * @return Integer[][]\n     */\n    function merge($intervals) {\n        \n    }\n}",
        "swift": "class Solution {\n    func merge(_ intervals: [[Int]]) -> [[Int]] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun merge(intervals: Array<IntArray>): Array<IntArray> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<List<int>> merge(List<List<int>> intervals) {\n    \n  }\n}",
        "golang": "func merge(intervals [][]int) [][]int {\n    \n}",
        "ruby": "# @param {Integer[][]} intervals\n# @return {Integer[][]}\ndef merge(intervals)\n    \nend",
        "scala": "object Solution {\n    def merge(intervals: Array[Array[Int]]): Array[Array[Int]] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn merge(intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        \n    }\n}",
        "racket": "(define/contract (merge intervals)\n  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)))\n  )",
        "erlang": "-spec merge(Intervals :: [[integer()]]) -> [[integer()]].\nmerge(Intervals) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec merge(intervals :: [[integer]]) :: [[integer]]\n  def merge(intervals) do\n    \n  end\nend"
      },
      "solution": "[TOC]\n\n## Video Solution\n---## Solution Article\n\n---\n\n### Approach 1: Connected Components\n\n**Intuition**\n\nIf we draw a graph (with intervals as nodes) that contains undirected edges between all pairs of intervals that overlap, then all intervals in each *connected component* of the graph can be merged into a single interval.\n\n**Algorithm**\n\nWith the above intuition in mind, we can represent the graph as an adjacency list, inserting directed edges in both directions to simulate undirected edges. Then, to determine which connected component each node is in, we perform graph traversals from arbitrary unvisited nodes until all nodes have been visited. To do this efficiently, we store visited nodes in a `Set`, allowing for constant time containment checks and insertion. Finally, we consider each connected component, merging all of its intervals by constructing a new `Interval` with `start` equal to the minimum start among them and `end` equal to the maximum end.\n\nThis algorithm is correct simply because it is basically the brute force solution. We compare every interval to every other interval, so we know exactly which intervals overlap. The reason for the connected component search is that two intervals may not directly overlap, but might overlap indirectly via a third interval. See the example below to see this more clearly.\n\n![Components Example](../Figures/56/component.png)\n\nAlthough (1, 5) and (6, 10) do not directly overlap, either would overlap with the other if first merged with (4, 7). There are two connected components, so if we merge their nodes, we expect to get the following two merged intervals:\n\n(1, 10), (15, 20)**Complexity Analysis**\n\n* Time complexity : $$O(n^2)$$\n\n    Building the graph costs $$O(V + E) = O(V) + O(E) = O(n) + O(n^2) = O(n^2)$$ time, as in the worst case all intervals are mutually overlapping. Traversing the graph has the same cost (although it might appear higher at first) because our `visited` set guarantees that each node will be visited exactly once. Finally, because each node is part of exactly one component, the merge step costs $$O(V) = O(n)$$ time. This all adds up as follows:\n\n    $$\n        O(n^2) + O(n^2) + O(n) = O(n^2)\n    $$\n\n* Space complexity : $$O(n^2)$$\n\n    As previously mentioned, in the worst case, all intervals are mutually overlapping, so there will be an edge for every pair of intervals. Therefore, the memory footprint is quadratic in the input size.---\n\n### Approach 2: Sorting\n\n**Intuition**\n\nIf we sort the intervals by their `start` value, then each set of intervals that can be merged will appear as a contiguous \"run\" in the sorted list.\n\n**Algorithm**\n\nFirst, we sort the list as described. Then, we insert the first interval into our `merged` list and continue considering each interval in turn as follows: If the current interval begins *after* the previous interval ends, then they do not overlap and we can append the current interval to `merged`. Otherwise, they do overlap, and we merge them by updating the `end` of the previous interval if it is less than the `end` of the current interval.\n\nA simple proof by contradiction shows that this algorithm always produces the correct answer. First, suppose that the algorithm at some point fails to merge two intervals that should be merged. This would imply that there exists some triple of indices $$i$$, $$j$$, and $$k$$ in a list of intervals $$\\text{ints}$$ such that $$i < j < k$$ and ($$\\text{ints[i]}$$, $$\\text{ints[k]}$$) can be merged, but neither ($$\\text{ints[i]}$$, $$\\text{ints[j]}$$) nor ($$\\text{ints[j]}$$, $$\\text{ints[k]}$$) can be merged. From this scenario follow several inequalities:\n\n$$\n\\begin{aligned}\n    \\text{ints[i].end} < \\text{ints[j].start} \\\\\n    \\text{ints[j].end} < \\text{ints[k].start} \\\\\n    \\text{ints[i].end} \\geq \\text{ints[k].start} \\\\\n\\end{aligned}\n$$\n\nWe can chain these inequalities (along with the following inequality, implied by the well-formedness of the intervals: $$\\text{ints[j].start} \\leq \\text{ints[j].end}$$) to demonstrate a contradiction:\n\n$$\n\\begin{aligned}\n    \\text{ints[i].end} < \\text{ints[j].start} \\leq \\text{ints[j].end} < \\text{ints[k].start} \\\\\n    \\text{ints[i].end} \\geq \\text{ints[k].start}\n\\end{aligned}\n$$\n\nTherefore, all mergeable intervals must occur in a contiguous run of the sorted list.\n\n![Sorting Example](../Figures/56/sort.png)\n\n\nConsider the example above, where the intervals are sorted, and then all mergeable intervals form contiguous blocks.**Complexity Analysis**\n\n* Time complexity : $$O(n\\log{}n)$$\n\n    Other than the `sort` invocation, we do a simple linear scan of the list, so the runtime is dominated by the $$O(n\\log{}n)$$ complexity of sorting.\n\n* Space complexity : $$O(\\log N)$$ (or $$O(n)$$)\n\n    If we can sort `intervals` in place, we do not need more than constant additional space, although the sorting itself takes $$O(\\log n)$$ space. Otherwise, we must allocate linear space to store a copy of `intervals` and sort that."
    },
    {
      "title": "Insert Interval",
      "problem_id": "57",
      "frontend_id": "57",
      "difficulty": "Medium",
      "problem_slug": "insert-interval",
      "topics": [
        "Array"
      ],
      "description": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\nReturn intervals after the insertion.\nNote that you don't need to modify intervals in-place. You can make a new array and return it.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].",
          "images": []
        }
      ],
      "constraints": [
        "0 <= intervals.length <= 104",
        "intervals[i].length == 2",
        "0 <= starti <= endi <= 105",
        "intervals is sorted by starti in ascending order.",
        "newInterval.length == 2",
        "0 <= start <= end <= 105"
      ],
      "follow_ups": [],
      "hints": [
        "Intervals Array is sorted. Can you use Binary Search to find the correct position to insert the new Interval.?",
        "Can you try merging the overlapping intervals while inserting the new interval?",
        "This can be done by comparing the end of the last interval with the start of the new interval and vice versa."
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        \n    }\n};",
        "java": "class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        ",
        "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** insert(int** intervals, int intervalsSize, int* intervalsColSize, int* newInterval, int newIntervalSize, int* returnSize, int** returnColumnSizes) {\n    \n}",
        "csharp": "public class Solution {\n    public int[][] Insert(int[][] intervals, int[] newInterval) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[][]} intervals\n * @param {number[]} newInterval\n * @return {number[][]}\n */\nvar insert = function(intervals, newInterval) {\n    \n};",
        "typescript": "function insert(intervals: number[][], newInterval: number[]): number[][] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[][] $intervals\n     * @param Integer[] $newInterval\n     * @return Integer[][]\n     */\n    function insert($intervals, $newInterval) {\n        \n    }\n}",
        "swift": "class Solution {\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun insert(intervals: Array<IntArray>, newInterval: IntArray): Array<IntArray> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<List<int>> insert(List<List<int>> intervals, List<int> newInterval) {\n    \n  }\n}",
        "golang": "func insert(intervals [][]int, newInterval []int) [][]int {\n    \n}",
        "ruby": "# @param {Integer[][]} intervals\n# @param {Integer[]} new_interval\n# @return {Integer[][]}\ndef insert(intervals, new_interval)\n    \nend",
        "scala": "object Solution {\n    def insert(intervals: Array[Array[Int]], newInterval: Array[Int]): Array[Array[Int]] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\n        \n    }\n}",
        "racket": "(define/contract (insert intervals newInterval)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?) (listof (listof exact-integer?)))\n  )",
        "erlang": "-spec insert(Intervals :: [[integer()]], NewInterval :: [integer()]) -> [[integer()]].\ninsert(Intervals, NewInterval) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec insert(intervals :: [[integer]], new_interval :: [integer]) :: [[integer]]\n  def insert(intervals, new_interval) do\n    \n  end\nend"
      },
      "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given a sorted list of non-overlapping `intervals` and a `newInterval`. The task is to insert the `newInterval` into the `intervals` while maintaining sorted order and ensuring no overlapping intervals. If there is any overlap, the overlapping intervals should be merged. In the end, return the intervals list with the addition of the new intervals.\n\nTwo key observations are crucial for this problem:\n1. The given intervals are already sorted in ascending order based on the start values.\n2. Initially, the intervals are non-overlapping, but inserting a new interval might lead to overlaps that need resolution by merging while maintaining sorted order.\n\nTo solve this problem, we break it into three cases when comparing the current interval with the new interval:\nCase 1. The current interval ends before the new interval starts.\nCase 2. There is an overlap, and the intervals need merging.\nCase 3. The current interval starts after the new interval ends.\n\nA visual representation below illustrates all three scenarios:\n\n![img](../Figures/57_re/1.png)\n\n\nNow let us consider the given problem description example with `intervals` and a `newInterval`:\n```\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\n```\n\nThe first interval starts at 1 and ends at 3, while the second interval starts at 6 and ends at 9. The goal is to insert the `newInterval` into the existing list of `intervals`, maintaining sorted order.\n\nUpon analysis, we observe that the `newInterval` [2, 5] overlaps with the first interval [1, 3] because 2 is less than 3. Now, since we know the intervals need to be merged, we must ensure the merged interval covers the entire overlapping region.\n\nTo achieve this, we take the maximum of the end of the first interval and the end of the new interval, as well as the minimum of the start of the first interval and the start of the new interval. Therefore, the merged interval becomes `[min(1, 2), max(3, 5)] = [1, 5]`.\n\nMoving on to the second interval [6, 9], its starting point (6) comes after the new interval's ending point (5). There is no overlap between them. Therefore, the second interval remains unchanged.\n\n\n| Original Intervals | New Interval | Action                     | Resulting Intervals |\n|-------------------- |--------------|---------------------------- |----------------------|\n|      [1,3]          |   [2,5]      | New interval overlaps with the first interval [1,3]. Merge intervals by taking [min(1, 2), max(3, 5)] = [1, 5]. |      [1,5]           |\n|      [6,9]          |              | No overlap with the new interval [2,5]. Interval remains unchanged. |      [6,9]           |\n\nIn conclusion, the final result is [[1, 5], [6, 9]], representing the intervals after inserting and merging the new interval [2, 5].\n\nIn a concrete business context, this problem may be presented as follows: Suppose we have an array representing video watch times, where each segment consists of the start and stop times of a user watching a video. The task is to calculate the total number of unique minutes watched across all the video segments. This is fundamentally the same question.\n\n> We recommend solving [Merge Intervals](https://leetcode.com/problems/merge-intervals/) problem before attempting this question, as it provides valuable insights into pattern recognition. This question is an extension of the Merge Intervals concept, building upon the same principles.\n\n---\n\n### Approach 1: Linear Search\n\n#### Intuition\n\nWe can do a linear search by iterating through all the intervals and checking which one of the three conditions the intervals fall under:\n\n1. **No Overlaps before Merging:**\n   - This occurs when the current interval ends before the new interval starts.\n\n2. **Overlapping and Merging:**\n   - This occurs when the starting point of the current interval is less than or equal to the ending point of the new interval (`newInterval[1]`), indicating an overlap. We can merge the current interval with the new interval by updating the start and end values of the new interval.\n\n3. **No Overlapping after Merging:**\n   - This occurs when the current interval starts after the new interval ends.\n\n##### 1. Identifying Non-Overlapping Intervals Before Merging:\nWe iterate through all intervals, checking whether the endpoint of the current interval (`intervals[i][1]`) is less than the starting point of the new interval (`newInterval[0]`). If this condition holds true, it indicates there is no overlap before merging, and we add the current interval to the result.\n\n##### 2. Identifying and Merging Overlapping Intervals:\nDuring the iteration, we identify overlap by comparing the endpoint of the new interval (`newInterval[1]`) with the starting point of the current interval (`intervals[i][0]`). When an overlap is detected, we merge the intervals by updating the start and end values of the new interval. The index (`i`) is then incremented to move to the next interval. After merging, the new interval is added to the result.\n\n##### 3. Identifying Non-Overlapping Intervals After Merging:\nAs we have already added the non-overlapping intervals before `newInterval` and merged overlapping ones, the remaining intervals after are guaranteed not to overlap with the newly merged interval. We simply add these remaining intervals to the result.\n\nThe following slideshow illustrates how the linear search algorithm is employed:\n\n!?!../Documents/57/57_LS.json:945,480!?!\n\n#### Algorithm\n\n- Initialize variables `n` and `i` to store the size of intervals and the current index, respectively, and an empty array `res` to store the result.\n- Case 1: No Overlap Before Insertion:\n    - Loop through intervals while `i` is less than `n` and the current interval's endpoint (`intervals[i][1]`) is less than the new interval's start point (`newInterval[0]`).\n    - Add the current interval from intervals to the `res` array.\n    - Increment `i` to move to the next interval.\n- Case 2: Overlap and Merge:\n    - Loop through intervals while `i` is less than `n` and the new interval's endpoint (`newInterval[1]`) is greater than or equal to the current interval's start point (`intervals[i][0]`).\n    - Update the newInterval's start point to the minimum of its current start and the current interval's start.\n    - Update the newInterval's endpoint to the maximum of its current end and the current interval's end.\n    - This essentially merges overlapping intervals into a single larger interval.\n    - Increment `i` to move to the next interval.\n- Add the updated `newInterval` to the `res` array, representing the merged interval.\n- Case 3: No overlap after insertion:\n    - Loop through the remaining intervals (from index `i`) and add them to the `res` array.\n        - This includes intervals that occur after the new interval and those that don't overlap, as they have already been correctly inserted in the previous iterations (previous two cases).\n- Return the `res` array containing all intervals with the new interval inserted correctly.\n\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the number of intervals.\n\n* Time complexity: $O(N)$\n\n    We iterate through the intervals once, and each interval is considered and processed only once.\n\n* Space complexity: $O(1)$\n\n    We only use the result (`res`) array to store output, so this could be considered $O(1)$.\n\n---\n\n### Approach 2: Binary Search\n\n#### Intuition\n\nTo apply binary search to a problem, a crucial requirement is that the input should have a monotonically increasing or decreasing nature. In our given scenario, it is explicitly stated that the input is already sorted with respect to the start value, indicating a monotonically increasing order. Therefore, we can confidently consider applying binary search.\n\n##### 1. Finding the Insertion Position\nAs the intervals are sorted by start value, we perform a binary search comparing the starting point of the current interval (`intervals[mid][0]`) with the starting point of the new interval (`target`). If `intervals[mid][0]` is less than the target, it indicates that the insertion point should be to the right of the current position. Consequently, we update `left` to `mid + 1`. If it's greater, the insertion point should be to the left, so we update `right` to `mid - 1`. This process continues until `left` becomes greater than `right`, revealing the correct insertion position.\n\n##### 2. Handling Merging\n1. If `res` is empty or the end of the last interval in `res` is less than the starting point of the current interval, it indicates there is no overlap before merging. The current interval is directly added to `res` in such cases.\n2. If an overlap is detected, signifying the need for merging, the current interval is merged with the last interval in `res`. The end of the last interval in `res` is updated to the maximum of its current end and the end of the current interval.\n\nThe following slideshow illustrates how the binary search algorithm is employed:\n\n!?!../Documents/57/57_BS.json:930,315!?!\n\n#### Algorithm\n\n- If `intervals` is empty, it means there are no existing intervals, so we can simply return a array containing the `newInterval`.\n- Perform a binary search to find the correct position to insert the new interval in the `intervals` array. It updates the values of `left` and `right` based on the comparison of the target value with the first element of the interval at the middle index.\n    - Initialize the variables `target` with the starting point of `newInterval` (i.e., `newInterval[0]`), `left` with 0, and `right` with `n - 1` to define the search space in the `intervals` array.\n    - Perform a binary search by repeatedly dividing the search space in half until `left` is greater than `right`.\n    - Calculate the middle index `mid` as the average of `left` and `right`.\n    - If the start of the interval at index `mid` is less than the target value, update `left` to `mid + 1` to search the right half of the search space. Otherwise, update `right` to `mid - 1` to search the left half of the search space.\n    - The search updates `left` and `right` until they converge to the correct position. Repeat until `left` is greater than `right`.\n- Use `intervals.insert(intervals.begin() + left, newInterval)` to insert the `newInterval` at the correct position.\n- Initialize an empty array `res` to store the result.\n- Iterate through the sorted intervals.\n    - Check if `res` is empty or if the end of the last interval in `res` is less than the start of the current interval. If either condition is true, add the current interval to `res`.\n    - If there is an overlap, update the endpoint of the last interval in `res` to cover the current interval. This step ensures that non-overlapping intervals are added directly, and overlapping intervals are merged.\n- The final merged and inserted intervals are stored in the `res` array, which is then returned.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the number of intervals.\n\n* Time complexity: $O(N)$\n\n    The binary search for finding the position to insert the `newInterval` has a time complexity of $O(\\log N)$. However, the insertion of the `newInterval` into the list may take $O(N)$ time in the worst case, as it could involve shifting elements within the list. Consequently, the overall time complexity is $O(N + \\log N)$, which simplifies to $O(N)$.\n\n* Space complexity: $O(N)$\n\n    We use the additional space to store the result (`res`) and perform calculations using `res,` so it does count towards the space complexity. In the worst case, the size of `res` will be proportional to the number of intervals in the input list."
    },
    {
      "title": "Length of Last Word",
      "problem_id": "58",
      "frontend_id": "58",
      "difficulty": "Easy",
      "problem_slug": "length-of-last-word",
      "topics": [
        "String"
      ],
      "description": "Given a string s consisting of words and spaces, return the length of the last word in the string.\nA word is a maximal substring consisting of non-space characters only.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: s = \"Hello World\"\nOutput: 5\nExplanation: The last word is \"World\" with length 5.",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: s = \"   fly me   to   the moon  \"\nOutput: 4\nExplanation: The last word is \"moon\" with length 4.",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: s = \"luffy is still joyboy\"\nOutput: 6\nExplanation: The last word is \"joyboy\" with length 6.",
          "images": []
        }
      ],
      "constraints": [
        "1 <= s.length <= 104",
        "s consists of only English letters and spaces ' '.",
        "There will be at least one word in s."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int lengthOfLastWord(string s) {\n        \n    }\n};",
        "java": "class Solution {\n    public int lengthOfLastWord(String s) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        ",
        "c": "int lengthOfLastWord(char* s) {\n    \n}",
        "csharp": "public class Solution {\n    public int LengthOfLastWord(string s) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLastWord = function(s) {\n    \n};",
        "typescript": "function lengthOfLastWord(s: string): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function lengthOfLastWord($s) {\n        \n    }\n}",
        "swift": "class Solution {\n    func lengthOfLastWord(_ s: String) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun lengthOfLastWord(s: String): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int lengthOfLastWord(String s) {\n    \n  }\n}",
        "golang": "func lengthOfLastWord(s string) int {\n    \n}",
        "ruby": "# @param {String} s\n# @return {Integer}\ndef length_of_last_word(s)\n    \nend",
        "scala": "object Solution {\n    def lengthOfLastWord(s: String): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn length_of_last_word(s: String) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (length-of-last-word s)\n  (-> string? exact-integer?)\n  )",
        "erlang": "-spec length_of_last_word(S :: unicode:unicode_binary()) -> integer().\nlength_of_last_word(S) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec length_of_last_word(s :: String.t) :: integer\n  def length_of_last_word(s) do\n    \n  end\nend"
      }
    },
    {
      "title": "Spiral Matrix II",
      "problem_id": "59",
      "frontend_id": "59",
      "difficulty": "Medium",
      "problem_slug": "spiral-matrix-ii",
      "topics": [
        "Array",
        "Matrix",
        "Simulation"
      ],
      "description": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: n = 3\nOutput: [[1,2,3],[8,9,4],[7,6,5]]",
          "images": [
            "https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: n = 1\nOutput: [[1]]",
          "images": [
            "https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg"
          ]
        }
      ],
      "constraints": [
        "1 <= n <= 20"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        \n    }\n};",
        "java": "class Solution {\n    public int[][] generateMatrix(int n) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        ",
        "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** generateMatrix(int n, int* returnSize, int** returnColumnSizes) {\n    \n}",
        "csharp": "public class Solution {\n    public int[][] GenerateMatrix(int n) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number} n\n * @return {number[][]}\n */\nvar generateMatrix = function(n) {\n    \n};",
        "typescript": "function generateMatrix(n: number): number[][] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer[][]\n     */\n    function generateMatrix($n) {\n        \n    }\n}",
        "swift": "class Solution {\n    func generateMatrix(_ n: Int) -> [[Int]] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun generateMatrix(n: Int): Array<IntArray> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<List<int>> generateMatrix(int n) {\n    \n  }\n}",
        "golang": "func generateMatrix(n int) [][]int {\n    \n}",
        "ruby": "# @param {Integer} n\n# @return {Integer[][]}\ndef generate_matrix(n)\n    \nend",
        "scala": "object Solution {\n    def generateMatrix(n: Int): Array[Array[Int]] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn generate_matrix(n: i32) -> Vec<Vec<i32>> {\n        \n    }\n}",
        "racket": "(define/contract (generate-matrix n)\n  (-> exact-integer? (listof (listof exact-integer?)))\n  )",
        "erlang": "-spec generate_matrix(N :: integer()) -> [[integer()]].\ngenerate_matrix(N) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec generate_matrix(n :: integer) :: [[integer]]\n  def generate_matrix(n) do\n    \n  end\nend"
      },
      "solution": "[TOC]\n\n## Solution\n\n---\n### Overview\n\nThere are various problems in spiral matrix series with some variations like [Spiral Matrix](https://leetcode.com/problems/spiral-matrix/) and [Spiral Matrix III](https://leetcode.com/problems/spiral-matrix-iii/).\n\nIn order to solve such questions, the core idea is to decode the underlying pattern. This can be done by simulating the pattern and finding a generic representation that would work for any given $$n$$.\nLet's discuss a few approaches.\n\n---\n### Approach 1: Traverse Layer by Layer in Spiral Form\n\n**Intuition**\n\nIf we try to build a pattern for a given $$n$$, we observe that the pattern repeats after completing one circular traversal around the matrix. Let's call this one circular traversal as  _layer_. We start traversing from the outer layer and move towards inner layers on every iteration.\n\n![img](../Figures/59/spiral_layers.png)\n\n**Algorithm**\n\nLet's devise an algorithm for the spiral traversal:\n\n-  We can observe that, for any given $$n$$, the total number of layers is given by :\n$$\\lfloor \\frac{n+1}{2} \\rfloor$$\nThis works for both even and odd $$n$$.\n\n_Example_\n\nFor $$n = 3$$, $$layers = 2$$\n\nFor $$n = 6$$, total $$layers = 3$$\n\n- Also, for each layer, we traverse in _at most_ 4 directions :\n\n\n![img](../Figures/59/spiral_traverse.png)\n\n\nIn every direction, either row or column remains constant and other parameter changes (increments/decrements).\n\n_Direction 1: From top left corner to top right corner._\n\nThe row remains constant as $$\\text{layer}$$ and column increments from $$\\text{layer}$$ to  $$n-\\text{layer}-1$$\n\n_Direction 2: From top right corner to the bottom right corner._\n\nThe column remains constant as $$n-layer-1$$ and row increments from\n$$\\text{layer}+1$$ to $$n-\\text{layer}$$.\n\n_Direction 3: From bottom right corner to bottom left corner._\n\nThe row remains constant as $$n-\\text{layer}-1$$ and column decrements from $$n-\\text{layer}-2$$ to $$\\text{layer}$$.\n\n_Direction 4: From bottom left corner to top left corner._\n\nThe column remains constant as $$\\text{layer}$$ and column decrements from $$n-\\text{layer}-2$$ to $$\\text{layer}+1$$.\n\nThis process repeats $$(n+1)/2$$ times until all layers are traversed.\n\n![img](../Figures/59/spiral_detailed_fix.png)**Complexity Analysis**\n\n* Time Complexity: $$\\mathcal{O}(n^2)$$. Here, $$n$$ is given input and we are iterating over $$n\\cdot n$$ matrix in spiral form.\n* Space Complexity: $$\\mathcal{O}(1)$$  We use constant extra space for storing $$cnt$$.\n\n---\n### Approach 2: Optimized spiral traversal\n\n**Intuition**\n\nOur main aim is to walk in a spiral form and fill the array in a particular pattern. In the previous approach, we used a separate loop for each direction. Here, we discuss another optimized to achieve the same result.\n\n**Algorithm**\n\n- We have to walk in 4 directions forming a layer. We use an array $$dir$$ that stores the changes in $$x$$ and $$y$$ co-ordinates in each direction.\n\n_Example_\n\nIn left to right walk ( _direction #1_ ), $$x$$ co-ordinates remains same and $$y$$ increments ($$x = 0$$, $$y = 1$$).\n\nIn right to left walk ( _direction #3_ ), $$x$$ remains same and $$y$$ decrements ($$x = 0$$, $$y = -1$$).\n\nUsing this intuition, we pre-define an array $$dir$$ having $$x$$ and $$y$$ co-ordinate changes for each direction. There are a total of 4 directions as discussed in the previous approach.\n\n- The $$\\text{row}$$ and $$col$$ variables represent the current $$x$$ and $$y$$ co-ordinates respectively. It updates based on the direction in which we are moving.\n\n_How do we know when we have to change the direction?_\n\nWhen we find the next row or column in a particular direction has a non-zero value, we are sure it is already traversed and we change the direction.\n\nLet $$d$$ be the current direction index. We go to next direction in array $$dir$$ using $$(d+ 1) \\% 4$$. Using this we could go back to direction 1 after completing one circular traversal from direction 1 to direction 4 .\n\n> It must be noted that we use `floorMod` in Java instead of modulo $$\\%$$ to handle mod of negative numbers. This is required because row and column values might go negative and using $$\\%$$ won't give desired results in such cases.**Complexity Analysis**\n\n* Time Complexity: $$\\mathcal{O}(n^2)$$. Here, $$n$$ is given input and we are iterating over $$n\\cdot n$$ matrix in spiral form.\n* Space Complexity: $$\\mathcal{O}(1)$$  We use constant extra space for storing $$cnt$$."
    },
    {
      "title": "Permutation Sequence",
      "problem_id": "60",
      "frontend_id": "60",
      "difficulty": "Hard",
      "problem_slug": "permutation-sequence",
      "topics": [
        "Math",
        "Recursion"
      ],
      "description": "The set [1, 2, 3, ..., n] contains a total of n! unique permutations.\nBy listing and labeling all of the permutations in order, we get the following sequence for n = 3:\nGiven n and k, return the kth permutation sequence.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: n = 3, k = 3\nOutput: \"213\"",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: n = 4, k = 9\nOutput: \"2314\"",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: n = 3, k = 1\nOutput: \"123\"",
          "images": []
        }
      ],
      "constraints": [
        "1 <= n <= 9",
        "1 <= k <= n!"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    string getPermutation(int n, int k) {\n        \n    }\n};",
        "java": "class Solution {\n    public String getPermutation(int n, int k) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        ",
        "c": "char* getPermutation(int n, int k) {\n    \n}",
        "csharp": "public class Solution {\n    public string GetPermutation(int n, int k) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number} n\n * @param {number} k\n * @return {string}\n */\nvar getPermutation = function(n, k) {\n    \n};",
        "typescript": "function getPermutation(n: number, k: number): string {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $k\n     * @return String\n     */\n    function getPermutation($n, $k) {\n        \n    }\n}",
        "swift": "class Solution {\n    func getPermutation(_ n: Int, _ k: Int) -> String {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun getPermutation(n: Int, k: Int): String {\n        \n    }\n}",
        "dart": "class Solution {\n  String getPermutation(int n, int k) {\n    \n  }\n}",
        "golang": "func getPermutation(n int, k int) string {\n    \n}",
        "ruby": "# @param {Integer} n\n# @param {Integer} k\n# @return {String}\ndef get_permutation(n, k)\n    \nend",
        "scala": "object Solution {\n    def getPermutation(n: Int, k: Int): String = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn get_permutation(n: i32, k: i32) -> String {\n        \n    }\n}",
        "racket": "(define/contract (get-permutation n k)\n  (-> exact-integer? exact-integer? string?)\n  )",
        "erlang": "-spec get_permutation(N :: integer(), K :: integer()) -> unicode:unicode_binary().\nget_permutation(N, K) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec get_permutation(n :: integer, k :: integer) :: String.t\n  def get_permutation(n, k) do\n    \n  end\nend"
      }
    },
    {
      "title": "Rotate List",
      "problem_id": "61",
      "frontend_id": "61",
      "difficulty": "Medium",
      "problem_slug": "rotate-list",
      "topics": [
        "Linked List",
        "Two Pointers"
      ],
      "description": "Given the head of a linked list, rotate the list to the right by k places.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: head = [1,2,3,4,5], k = 2\nOutput: [4,5,1,2,3]",
          "images": [
            "https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: head = [0,1,2], k = 4\nOutput: [2,0,1]",
          "images": [
            "https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg"
          ]
        }
      ],
      "constraints": [
        "The number of nodes in the list is in the range [0, 500].",
        "-100 <= Node.val <= 100",
        "0 <= k <= 2 * 109"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        \n    }\n};",
        "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        \n    }\n}",
        "python": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type k: int\n        :rtype: Optional[ListNode]\n        \"\"\"\n        ",
        "python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        ",
        "c": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* rotateRight(struct ListNode* head, int k) {\n    \n}",
        "csharp": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode RotateRight(ListNode head, int k) {\n        \n    }\n}",
        "javascript": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    \n};",
        "typescript": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n    \n};",
        "php": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @param Integer $k\n     * @return ListNode\n     */\n    function rotateRight($head, $k) {\n        \n    }\n}",
        "swift": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\n        \n    }\n}",
        "kotlin": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun rotateRight(head: ListNode?, k: Int): ListNode? {\n        \n    }\n}",
        "dart": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? rotateRight(ListNode? head, int k) {\n    \n  }\n}",
        "golang": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc rotateRight(head *ListNode, k int) *ListNode {\n    \n}",
        "ruby": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @param {Integer} k\n# @return {ListNode}\ndef rotate_right(head, k)\n    \nend",
        "scala": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def rotateRight(head: ListNode, k: Int): ListNode = {\n        \n    }\n}",
        "rust": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn rotate_right(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\n        \n    }\n}",
        "racket": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (rotate-right head k)\n  (-> (or/c list-node? #f) exact-integer? (or/c list-node? #f))\n  )",
        "erlang": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec rotate_right(Head :: #list_node{} | null, K :: integer()) -> #list_node{} | null.\nrotate_right(Head, K) ->\n  .",
        "elixir": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec rotate_right(head :: ListNode.t | nil, k :: integer) :: ListNode.t | nil\n  def rotate_right(head, k) do\n    \n  end\nend"
      }
    },
    {
      "title": "Unique Paths",
      "problem_id": "62",
      "frontend_id": "62",
      "difficulty": "Medium",
      "problem_slug": "unique-paths",
      "topics": [
        "Math",
        "Dynamic Programming",
        "Combinatorics"
      ],
      "description": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe test cases are generated so that the answer will be less than or equal to 2 * 109.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: m = 3, n = 7\nOutput: 28",
          "images": [
            "https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: m = 3, n = 2\nOutput: 3\nExplanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down",
          "images": [
            "https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png"
          ]
        }
      ],
      "constraints": [
        "1 <= m, n <= 100"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        \n    }\n};",
        "java": "class Solution {\n    public int uniquePaths(int m, int n) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        ",
        "c": "int uniquePaths(int m, int n) {\n    \n}",
        "csharp": "public class Solution {\n    public int UniquePaths(int m, int n) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function(m, n) {\n    \n};",
        "typescript": "function uniquePaths(m: number, n: number): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer $m\n     * @param Integer $n\n     * @return Integer\n     */\n    function uniquePaths($m, $n) {\n        \n    }\n}",
        "swift": "class Solution {\n    func uniquePaths(_ m: Int, _ n: Int) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun uniquePaths(m: Int, n: Int): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int uniquePaths(int m, int n) {\n    \n  }\n}",
        "golang": "func uniquePaths(m int, n int) int {\n    \n}",
        "ruby": "# @param {Integer} m\n# @param {Integer} n\n# @return {Integer}\ndef unique_paths(m, n)\n    \nend",
        "scala": "object Solution {\n    def uniquePaths(m: Int, n: Int): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn unique_paths(m: i32, n: i32) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (unique-paths m n)\n  (-> exact-integer? exact-integer? exact-integer?)\n  )",
        "erlang": "-spec unique_paths(M :: integer(), N :: integer()) -> integer().\nunique_paths(M, N) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec unique_paths(m :: integer, n :: integer) :: integer\n  def unique_paths(m, n) do\n    \n  end\nend"
      }
    },
    {
      "title": "Unique Paths II",
      "problem_id": "63",
      "frontend_id": "63",
      "difficulty": "Medium",
      "problem_slug": "unique-paths-ii",
      "topics": [
        "Array",
        "Dynamic Programming",
        "Matrix"
      ],
      "description": "You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nAn obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\nReturn the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe testcases are generated so that the answer will be less than or equal to 2 * 109.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: 2\nExplanation: There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right",
          "images": [
            "https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: obstacleGrid = [[0,1],[0,0]]\nOutput: 1",
          "images": [
            "https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg"
          ]
        }
      ],
      "constraints": [
        "m == obstacleGrid.length",
        "n == obstacleGrid[i].length",
        "1 <= m, n <= 100",
        "obstacleGrid[i][j] is 0 or 1."
      ],
      "follow_ups": [],
      "hints": [
        "Use dynamic programming since, from each cell, you can move to the right or down.",
        "assume dp[i][j] is the number of unique paths to reach (i, j). dp[i][j] = dp[i][j -1] + dp[i - 1][j]. Be careful when you encounter an obstacle. set its value in dp to 0."
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        \n    }\n};",
        "java": "class Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        ",
        "c": "int uniquePathsWithObstacles(int** obstacleGrid, int obstacleGridSize, int* obstacleGridColSize) {\n    \n}",
        "csharp": "public class Solution {\n    public int UniquePathsWithObstacles(int[][] obstacleGrid) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[][]} obstacleGrid\n * @return {number}\n */\nvar uniquePathsWithObstacles = function(obstacleGrid) {\n    \n};",
        "typescript": "function uniquePathsWithObstacles(obstacleGrid: number[][]): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[][] $obstacleGrid\n     * @return Integer\n     */\n    function uniquePathsWithObstacles($obstacleGrid) {\n        \n    }\n}",
        "swift": "class Solution {\n    func uniquePathsWithObstacles(_ obstacleGrid: [[Int]]) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun uniquePathsWithObstacles(obstacleGrid: Array<IntArray>): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int uniquePathsWithObstacles(List<List<int>> obstacleGrid) {\n    \n  }\n}",
        "golang": "func uniquePathsWithObstacles(obstacleGrid [][]int) int {\n    \n}",
        "ruby": "# @param {Integer[][]} obstacle_grid\n# @return {Integer}\ndef unique_paths_with_obstacles(obstacle_grid)\n    \nend",
        "scala": "object Solution {\n    def uniquePathsWithObstacles(obstacleGrid: Array[Array[Int]]): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn unique_paths_with_obstacles(obstacle_grid: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (unique-paths-with-obstacles obstacleGrid)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )",
        "erlang": "-spec unique_paths_with_obstacles(ObstacleGrid :: [[integer()]]) -> integer().\nunique_paths_with_obstacles(ObstacleGrid) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec unique_paths_with_obstacles(obstacle_grid :: [[integer]]) :: integer\n  def unique_paths_with_obstacles(obstacle_grid) do\n    \n  end\nend"
      }
    },
    {
      "title": "Minimum Path Sum",
      "problem_id": "64",
      "frontend_id": "64",
      "difficulty": "Medium",
      "problem_slug": "minimum-path-sum",
      "topics": [
        "Array",
        "Dynamic Programming",
        "Matrix"
      ],
      "description": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOutput: 7\nExplanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.",
          "images": [
            "https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: grid = [[1,2,3],[4,5,6]]\nOutput: 12",
          "images": [
            "https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg"
          ]
        }
      ],
      "constraints": [
        "m == grid.length",
        "n == grid[i].length",
        "1 <= m, n <= 200",
        "0 <= grid[i][j] <= 200"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        \n    }\n};",
        "java": "class Solution {\n    public int minPathSum(int[][] grid) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        ",
        "c": "int minPathSum(int** grid, int gridSize, int* gridColSize) {\n    \n}",
        "csharp": "public class Solution {\n    public int MinPathSum(int[][] grid) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minPathSum = function(grid) {\n    \n};",
        "typescript": "function minPathSum(grid: number[][]): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer\n     */\n    function minPathSum($grid) {\n        \n    }\n}",
        "swift": "class Solution {\n    func minPathSum(_ grid: [[Int]]) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun minPathSum(grid: Array<IntArray>): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int minPathSum(List<List<int>> grid) {\n    \n  }\n}",
        "golang": "func minPathSum(grid [][]int) int {\n    \n}",
        "ruby": "# @param {Integer[][]} grid\n# @return {Integer}\ndef min_path_sum(grid)\n    \nend",
        "scala": "object Solution {\n    def minPathSum(grid: Array[Array[Int]]): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn min_path_sum(grid: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (min-path-sum grid)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )",
        "erlang": "-spec min_path_sum(Grid :: [[integer()]]) -> integer().\nmin_path_sum(Grid) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec min_path_sum(grid :: [[integer]]) :: integer\n  def min_path_sum(grid) do\n    \n  end\nend"
      }
    },
    {
      "title": "Valid Number",
      "problem_id": "65",
      "frontend_id": "65",
      "difficulty": "Hard",
      "problem_slug": "valid-number",
      "topics": [
        "String"
      ],
      "description": "Given a string s, return whether s is a valid number.\n\nFor example, all the following are valid numbers: \"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\", while the following are not valid numbers: \"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\".\nFormally, a valid number is defined using one of the following definitions:\nAn integer number is defined with an optional sign '-' or '+' followed by digits.\nA decimal number is defined with an optional sign '-' or '+' followed by one of the following definitions:\nAn exponent is defined with an exponent notation 'e' or 'E' followed by an integer number.\nThe digits are defined as one or more digits.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: s = \"0\"\nOutput: true",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: s = \"e\"\nOutput: false",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: s = \".\"\nOutput: false",
          "images": []
        }
      ],
      "constraints": [
        "1 <= s.length <= 20",
        "s consists of only English letters (both uppercase and lowercase), digits (0-9), plus '+', minus '-', or dot '.'."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    bool isNumber(string s) {\n        \n    }\n};",
        "java": "class Solution {\n    public boolean isNumber(String s) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        ",
        "c": "bool isNumber(char* s) {\n    \n}",
        "csharp": "public class Solution {\n    public bool IsNumber(string s) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar isNumber = function(s) {\n    \n};",
        "typescript": "function isNumber(s: string): boolean {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Boolean\n     */\n    function isNumber($s) {\n        \n    }\n}",
        "swift": "class Solution {\n    func isNumber(_ s: String) -> Bool {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun isNumber(s: String): Boolean {\n        \n    }\n}",
        "dart": "class Solution {\n  bool isNumber(String s) {\n    \n  }\n}",
        "golang": "func isNumber(s string) bool {\n    \n}",
        "ruby": "# @param {String} s\n# @return {Boolean}\ndef is_number(s)\n    \nend",
        "scala": "object Solution {\n    def isNumber(s: String): Boolean = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn is_number(s: String) -> bool {\n        \n    }\n}",
        "racket": "(define/contract (is-number s)\n  (-> string? boolean?)\n  )",
        "erlang": "-spec is_number(S :: unicode:unicode_binary()) -> boolean().\nis_number(S) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec is_number(s :: String.t) :: boolean\n  def is_number(s) do\n    \n  end\nend"
      }
    },
    {
      "title": "Plus One",
      "problem_id": "66",
      "frontend_id": "66",
      "difficulty": "Easy",
      "problem_slug": "plus-one",
      "topics": [
        "Array",
        "Math"
      ],
      "description": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].",
          "images": []
        }
      ],
      "constraints": [
        "1 <= digits.length <= 100",
        "0 <= digits[i] <= 9",
        "digits does not contain any leading 0's."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        \n    }\n};",
        "java": "class Solution {\n    public int[] plusOne(int[] digits) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        ",
        "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* plusOne(int* digits, int digitsSize, int* returnSize) {\n    \n}",
        "csharp": "public class Solution {\n    public int[] PlusOne(int[] digits) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} digits\n * @return {number[]}\n */\nvar plusOne = function(digits) {\n    \n};",
        "typescript": "function plusOne(digits: number[]): number[] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $digits\n     * @return Integer[]\n     */\n    function plusOne($digits) {\n        \n    }\n}",
        "swift": "class Solution {\n    func plusOne(_ digits: [Int]) -> [Int] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun plusOne(digits: IntArray): IntArray {\n        \n    }\n}",
        "dart": "class Solution {\n  List<int> plusOne(List<int> digits) {\n    \n  }\n}",
        "golang": "func plusOne(digits []int) []int {\n    \n}",
        "ruby": "# @param {Integer[]} digits\n# @return {Integer[]}\ndef plus_one(digits)\n    \nend",
        "scala": "object Solution {\n    def plusOne(digits: Array[Int]): Array[Int] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn plus_one(digits: Vec<i32>) -> Vec<i32> {\n        \n    }\n}",
        "racket": "(define/contract (plus-one digits)\n  (-> (listof exact-integer?) (listof exact-integer?))\n  )",
        "erlang": "-spec plus_one(Digits :: [integer()]) -> [integer()].\nplus_one(Digits) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec plus_one(digits :: [integer]) :: [integer]\n  def plus_one(digits) do\n    \n  end\nend"
      }
    },
    {
      "title": "Add Binary",
      "problem_id": "67",
      "frontend_id": "67",
      "difficulty": "Easy",
      "problem_slug": "add-binary",
      "topics": [
        "Math",
        "String",
        "Bit Manipulation",
        "Simulation"
      ],
      "description": "Given two binary strings a and b, return their sum as a binary string.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: a = \"11\", b = \"1\"\nOutput: \"100\"",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: a = \"1010\", b = \"1011\"\nOutput: \"10101\"",
          "images": []
        }
      ],
      "constraints": [
        "1 <= a.length, b.length <= 104",
        "a and b consist only of '0' or '1' characters.",
        "Each string does not contain leading zeros except for the zero itself."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    string addBinary(string a, string b) {\n        \n    }\n};",
        "java": "class Solution {\n    public String addBinary(String a, String b) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        ",
        "c": "char* addBinary(char* a, char* b) {\n    \n}",
        "csharp": "public class Solution {\n    public string AddBinary(string a, string b) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} a\n * @param {string} b\n * @return {string}\n */\nvar addBinary = function(a, b) {\n    \n};",
        "typescript": "function addBinary(a: string, b: string): string {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $a\n     * @param String $b\n     * @return String\n     */\n    function addBinary($a, $b) {\n        \n    }\n}",
        "swift": "class Solution {\n    func addBinary(_ a: String, _ b: String) -> String {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun addBinary(a: String, b: String): String {\n        \n    }\n}",
        "dart": "class Solution {\n  String addBinary(String a, String b) {\n    \n  }\n}",
        "golang": "func addBinary(a string, b string) string {\n    \n}",
        "ruby": "# @param {String} a\n# @param {String} b\n# @return {String}\ndef add_binary(a, b)\n    \nend",
        "scala": "object Solution {\n    def addBinary(a: String, b: String): String = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn add_binary(a: String, b: String) -> String {\n        \n    }\n}",
        "racket": "(define/contract (add-binary a b)\n  (-> string? string? string?)\n  )",
        "erlang": "-spec add_binary(A :: unicode:unicode_binary(), B :: unicode:unicode_binary()) -> unicode:unicode_binary().\nadd_binary(A, B) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec add_binary(a :: String.t, b :: String.t) :: String.t\n  def add_binary(a, b) do\n    \n  end\nend"
      }
    },
    {
      "title": "Text Justification",
      "problem_id": "68",
      "frontend_id": "68",
      "difficulty": "Hard",
      "problem_slug": "text-justification",
      "topics": [
        "Array",
        "String",
        "Simulation"
      ],
      "description": "Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\nNote:\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\nOutput:\n[\n   \"This    is    an\",\n   \"example  of text\",\n   \"justification.  \"\n]",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\nOutput:\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]\nExplanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\nOutput:\n[\n  \"Science  is  what we\",\n  \"understand      well\",\n  \"enough to explain to\",\n  \"a  computer.  Art is\",\n  \"everything  else  we\",\n  \"do                  \"\n]",
          "images": []
        }
      ],
      "constraints": [
        "1 <= words.length <= 300",
        "1 <= words[i].length <= 20",
        "words[i] consists of only English letters and symbols.",
        "1 <= maxWidth <= 100",
        "words[i].length <= maxWidth"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        ",
        "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** fullJustify(char** words, int wordsSize, int maxWidth, int* returnSize) {\n    \n}",
        "csharp": "public class Solution {\n    public IList<string> FullJustify(string[] words, int maxWidth) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string[]} words\n * @param {number} maxWidth\n * @return {string[]}\n */\nvar fullJustify = function(words, maxWidth) {\n    \n};",
        "typescript": "function fullJustify(words: string[], maxWidth: number): string[] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String[] $words\n     * @param Integer $maxWidth\n     * @return String[]\n     */\n    function fullJustify($words, $maxWidth) {\n        \n    }\n}",
        "swift": "class Solution {\n    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun fullJustify(words: Array<String>, maxWidth: Int): List<String> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<String> fullJustify(List<String> words, int maxWidth) {\n    \n  }\n}",
        "golang": "func fullJustify(words []string, maxWidth int) []string {\n    \n}",
        "ruby": "# @param {String[]} words\n# @param {Integer} max_width\n# @return {String[]}\ndef full_justify(words, max_width)\n    \nend",
        "scala": "object Solution {\n    def fullJustify(words: Array[String], maxWidth: Int): List[String] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn full_justify(words: Vec<String>, max_width: i32) -> Vec<String> {\n        \n    }\n}",
        "racket": "(define/contract (full-justify words maxWidth)\n  (-> (listof string?) exact-integer? (listof string?))\n  )",
        "erlang": "-spec full_justify(Words :: [unicode:unicode_binary()], MaxWidth :: integer()) -> [unicode:unicode_binary()].\nfull_justify(Words, MaxWidth) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec full_justify(words :: [String.t], max_width :: integer) :: [String.t]\n  def full_justify(words, max_width) do\n    \n  end\nend"
      }
    },
    {
      "title": "Sqrt(x)",
      "problem_id": "69",
      "frontend_id": "69",
      "difficulty": "Easy",
      "problem_slug": "sqrtx",
      "topics": [
        "Math",
        "Binary Search"
      ],
      "description": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\nYou must not use any built-in exponent function or operator.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: x = 4\nOutput: 2\nExplanation: The square root of 4 is 2, so we return 2.",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: x = 8\nOutput: 2\nExplanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.",
          "images": []
        }
      ],
      "constraints": [
        "0 <= x <= 231 - 1"
      ],
      "follow_ups": [],
      "hints": [
        "Try exploring all integers. (Credits: @annujoshi)",
        "Use the sorted property of integers to reduced the search space. (Credits: @annujoshi)"
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int mySqrt(int x) {\n        \n    }\n};",
        "java": "class Solution {\n    public int mySqrt(int x) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        ",
        "c": "int mySqrt(int x) {\n    \n}",
        "csharp": "public class Solution {\n    public int MySqrt(int x) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number} x\n * @return {number}\n */\nvar mySqrt = function(x) {\n    \n};",
        "typescript": "function mySqrt(x: number): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer $x\n     * @return Integer\n     */\n    function mySqrt($x) {\n        \n    }\n}",
        "swift": "class Solution {\n    func mySqrt(_ x: Int) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun mySqrt(x: Int): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int mySqrt(int x) {\n    \n  }\n}",
        "golang": "func mySqrt(x int) int {\n    \n}",
        "ruby": "# @param {Integer} x\n# @return {Integer}\ndef my_sqrt(x)\n    \nend",
        "scala": "object Solution {\n    def mySqrt(x: Int): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn my_sqrt(x: i32) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (my-sqrt x)\n  (-> exact-integer? exact-integer?)\n  )",
        "erlang": "-spec my_sqrt(X :: integer()) -> integer().\nmy_sqrt(X) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec my_sqrt(x :: integer) :: integer\n  def my_sqrt(x) do\n    \n  end\nend"
      }
    },
    {
      "title": "Climbing Stairs",
      "problem_id": "70",
      "frontend_id": "70",
      "difficulty": "Easy",
      "problem_slug": "climbing-stairs",
      "topics": [
        "Math",
        "Dynamic Programming",
        "Memoization"
      ],
      "description": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step",
          "images": []
        }
      ],
      "constraints": [
        "1 <= n <= 45"
      ],
      "follow_ups": [],
      "hints": [
        "To reach nth step, what could have been your previous steps? (Think about the step sizes)"
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int climbStairs(int n) {\n        \n    }\n};",
        "java": "class Solution {\n    public int climbStairs(int n) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        ",
        "c": "int climbStairs(int n) {\n    \n}",
        "csharp": "public class Solution {\n    public int ClimbStairs(int n) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function(n) {\n    \n};",
        "typescript": "function climbStairs(n: number): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function climbStairs($n) {\n        \n    }\n}",
        "swift": "class Solution {\n    func climbStairs(_ n: Int) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun climbStairs(n: Int): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int climbStairs(int n) {\n    \n  }\n}",
        "golang": "func climbStairs(n int) int {\n    \n}",
        "ruby": "# @param {Integer} n\n# @return {Integer}\ndef climb_stairs(n)\n    \nend",
        "scala": "object Solution {\n    def climbStairs(n: Int): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn climb_stairs(n: i32) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (climb-stairs n)\n  (-> exact-integer? exact-integer?)\n  )",
        "erlang": "-spec climb_stairs(N :: integer()) -> integer().\nclimb_stairs(N) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec climb_stairs(n :: integer) :: integer\n  def climb_stairs(n) do\n    \n  end\nend"
      }
    },
    {
      "title": "Simplify Path",
      "problem_id": "71",
      "frontend_id": "71",
      "difficulty": "Medium",
      "problem_slug": "simplify-path",
      "topics": [
        "String",
        "Stack"
      ],
      "description": "You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Your task is to transform this absolute path into its simplified canonical path.\nThe rules of a Unix-style file system are as follows:\nThe simplified canonical path should follow these rules:\nReturn the simplified canonical path.\nExample 1:\nExample 2:\nExample 3:\nExample 4:\nExample 5:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: path = \"/home/\"\nOutput: \"/home\"\nExplanation:\nThe trailing slash should be removed.",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: path = \"/home//foo/\"\nOutput: \"/home/foo\"\nExplanation:\nMultiple consecutive slashes are replaced by a single one.",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: path = \"/home/user/Documents/../Pictures\"\nOutput: \"/home/user/Pictures\"\nExplanation:\nA double period \"..\" refers to the directory up a level (the parent directory).",
          "images": []
        },
        {
          "example_num": 4,
          "example_text": "Input: path = \"/../\"\nOutput: \"/\"\nExplanation:\nGoing one level up from the root directory is not possible.",
          "images": []
        },
        {
          "example_num": 5,
          "example_text": "Input: path = \"/.../a/../b/c/../d/./\"\nOutput: \"/.../b/d\"\nExplanation:\n\"...\" is a valid name for a directory in this problem.",
          "images": []
        }
      ],
      "constraints": [
        "1 <= path.length <= 3000",
        "path consists of English letters, digits, period '.', slash '/' or '_'.",
        "path is a valid absolute Unix path."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    string simplifyPath(string path) {\n        \n    }\n};",
        "java": "class Solution {\n    public String simplifyPath(String path) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        ",
        "c": "char* simplifyPath(char* path) {\n    \n}",
        "csharp": "public class Solution {\n    public string SimplifyPath(string path) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} path\n * @return {string}\n */\nvar simplifyPath = function(path) {\n    \n};",
        "typescript": "function simplifyPath(path: string): string {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $path\n     * @return String\n     */\n    function simplifyPath($path) {\n        \n    }\n}",
        "swift": "class Solution {\n    func simplifyPath(_ path: String) -> String {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun simplifyPath(path: String): String {\n        \n    }\n}",
        "dart": "class Solution {\n  String simplifyPath(String path) {\n    \n  }\n}",
        "golang": "func simplifyPath(path string) string {\n    \n}",
        "ruby": "# @param {String} path\n# @return {String}\ndef simplify_path(path)\n    \nend",
        "scala": "object Solution {\n    def simplifyPath(path: String): String = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn simplify_path(path: String) -> String {\n        \n    }\n}",
        "racket": "(define/contract (simplify-path path)\n  (-> string? string?)\n  )",
        "erlang": "-spec simplify_path(Path :: unicode:unicode_binary()) -> unicode:unicode_binary().\nsimplify_path(Path) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec simplify_path(path :: String.t) :: String.t\n  def simplify_path(path) do\n    \n  end\nend"
      }
    },
    {
      "title": "Edit Distance",
      "problem_id": "72",
      "frontend_id": "72",
      "difficulty": "Medium",
      "problem_slug": "edit-distance",
      "topics": [
        "String",
        "Dynamic Programming"
      ],
      "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')",
          "images": []
        }
      ],
      "constraints": [
        "0 <= word1.length, word2.length <= 500",
        "word1 and word2 consist of lowercase English letters."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        \n    }\n};",
        "java": "class Solution {\n    public int minDistance(String word1, String word2) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        ",
        "c": "int minDistance(char* word1, char* word2) {\n    \n}",
        "csharp": "public class Solution {\n    public int MinDistance(string word1, string word2) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nvar minDistance = function(word1, word2) {\n    \n};",
        "typescript": "function minDistance(word1: string, word2: string): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $word1\n     * @param String $word2\n     * @return Integer\n     */\n    function minDistance($word1, $word2) {\n        \n    }\n}",
        "swift": "class Solution {\n    func minDistance(_ word1: String, _ word2: String) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun minDistance(word1: String, word2: String): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int minDistance(String word1, String word2) {\n    \n  }\n}",
        "golang": "func minDistance(word1 string, word2 string) int {\n    \n}",
        "ruby": "# @param {String} word1\n# @param {String} word2\n# @return {Integer}\ndef min_distance(word1, word2)\n    \nend",
        "scala": "object Solution {\n    def minDistance(word1: String, word2: String): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn min_distance(word1: String, word2: String) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (min-distance word1 word2)\n  (-> string? string? exact-integer?)\n  )",
        "erlang": "-spec min_distance(Word1 :: unicode:unicode_binary(), Word2 :: unicode:unicode_binary()) -> integer().\nmin_distance(Word1, Word2) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec min_distance(word1 :: String.t, word2 :: String.t) :: integer\n  def min_distance(word1, word2) do\n    \n  end\nend"
      }
    },
    {
      "title": "Set Matrix Zeroes",
      "problem_id": "73",
      "frontend_id": "73",
      "difficulty": "Medium",
      "problem_slug": "set-matrix-zeroes",
      "topics": [
        "Array",
        "Hash Table",
        "Matrix"
      ],
      "description": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\nYou must do it in place.\nExample 1:\nExample 2:\nConstraints:\nFollow up:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]",
          "images": [
            "https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\nOutput: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
          "images": [
            "https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg"
          ]
        }
      ],
      "constraints": [
        "m == matrix.length",
        "n == matrix[0].length",
        "1 <= m, n <= 200",
        "-231 <= matrix[i][j] <= 231 - 1"
      ],
      "follow_ups": [],
      "hints": [
        "If any cell of the matrix has a zero we can record its row and column number using additional memory.\r\nBut if you don't want to use extra memory then you can manipulate the array instead. i.e. simulating exactly what the question says.",
        "Setting cell values to zero on the fly while iterating might lead to discrepancies. What if you use some other integer value as your marker?\r\nThere is still a better approach for this problem with O(1) space.",
        "We could have used 2 sets to keep a record of rows/columns which need to be set to zero. But for an O(1) space solution, you can use one of the rows and and one of the columns to keep track of this information.",
        "We can use the first cell of every row and column as a flag. This flag would determine whether a row or column has been set to zero."
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        \n    }\n};",
        "java": "class Solution {\n    public void setZeroes(int[][] matrix) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        ",
        "c": "void setZeroes(int** matrix, int matrixSize, int* matrixColSize) {\n    \n}",
        "csharp": "public class Solution {\n    public void SetZeroes(int[][] matrix) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nvar setZeroes = function(matrix) {\n    \n};",
        "typescript": "/**\n Do not return anything, modify matrix in-place instead.\n */\nfunction setZeroes(matrix: number[][]): void {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[][] $matrix\n     * @return NULL\n     */\n    function setZeroes(&$matrix) {\n        \n    }\n}",
        "swift": "class Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun setZeroes(matrix: Array<IntArray>): Unit {\n        \n    }\n}",
        "dart": "class Solution {\n  void setZeroes(List<List<int>> matrix) {\n    \n  }\n}",
        "golang": "func setZeroes(matrix [][]int)  {\n    \n}",
        "ruby": "# @param {Integer[][]} matrix\n# @return {Void} Do not return anything, modify matrix in-place instead.\ndef set_zeroes(matrix)\n    \nend",
        "scala": "object Solution {\n    def setZeroes(matrix: Array[Array[Int]]): Unit = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn set_zeroes(matrix: &mut Vec<Vec<i32>>) {\n        \n    }\n}"
      }
    },
    {
      "title": "Search a 2D Matrix",
      "problem_id": "74",
      "frontend_id": "74",
      "difficulty": "Medium",
      "problem_slug": "search-a-2d-matrix",
      "topics": [
        "Array",
        "Binary Search",
        "Matrix"
      ],
      "description": "You are given an m x n integer matrix matrix with the following two properties:\nGiven an integer target, return true if target is in matrix or false otherwise.\nYou must write a solution in O(log(m * n)) time complexity.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\nOutput: true",
          "images": [
            "https://assets.leetcode.com/uploads/2020/10/05/mat.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\nOutput: false",
          "images": [
            "https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg"
          ]
        }
      ],
      "constraints": [
        "m == matrix.length",
        "n == matrix[i].length",
        "1 <= m, n <= 100",
        "-104 <= matrix[i][j], target <= 104"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        \n    }\n};",
        "java": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        ",
        "c": "bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target) {\n    \n}",
        "csharp": "public class Solution {\n    public bool SearchMatrix(int[][] matrix, int target) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[][]} matrix\n * @param {number} target\n * @return {boolean}\n */\nvar searchMatrix = function(matrix, target) {\n    \n};",
        "typescript": "function searchMatrix(matrix: number[][], target: number): boolean {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[][] $matrix\n     * @param Integer $target\n     * @return Boolean\n     */\n    function searchMatrix($matrix, $target) {\n        \n    }\n}",
        "swift": "class Solution {\n    func searchMatrix(_ matrix: [[Int]], _ target: Int) -> Bool {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun searchMatrix(matrix: Array<IntArray>, target: Int): Boolean {\n        \n    }\n}",
        "dart": "class Solution {\n  bool searchMatrix(List<List<int>> matrix, int target) {\n    \n  }\n}",
        "golang": "func searchMatrix(matrix [][]int, target int) bool {\n    \n}",
        "ruby": "# @param {Integer[][]} matrix\n# @param {Integer} target\n# @return {Boolean}\ndef search_matrix(matrix, target)\n    \nend",
        "scala": "object Solution {\n    def searchMatrix(matrix: Array[Array[Int]], target: Int): Boolean = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {\n        \n    }\n}",
        "racket": "(define/contract (search-matrix matrix target)\n  (-> (listof (listof exact-integer?)) exact-integer? boolean?)\n  )",
        "erlang": "-spec search_matrix(Matrix :: [[integer()]], Target :: integer()) -> boolean().\nsearch_matrix(Matrix, Target) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec search_matrix(matrix :: [[integer]], target :: integer) :: boolean\n  def search_matrix(matrix, target) do\n    \n  end\nend"
      }
    },
    {
      "title": "Sort Colors",
      "problem_id": "75",
      "frontend_id": "75",
      "difficulty": "Medium",
      "problem_slug": "sort-colors",
      "topics": [
        "Array",
        "Two Pointers",
        "Sorting"
      ],
      "description": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library's sort function.\nExample 1:\nExample 2:\nConstraints:\nFollow up: Could you come up with a one-pass algorithm using only constant extra space?",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [2,0,1]\nOutput: [0,1,2]",
          "images": []
        }
      ],
      "constraints": [
        "n == nums.length",
        "1 <= n <= 300",
        "nums[i] is either 0, 1, or 2."
      ],
      "follow_ups": [
        "Could you come up with a one-pass algorithm using only constant extra space?"
      ],
      "hints": [
        "A rather straight forward solution is a two-pass algorithm using counting sort.",
        "Iterate the array counting number of 0's, 1's, and 2's.",
        "Overwrite array with the total number of 0's, then 1's and followed by 2's."
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        \n    }\n};",
        "java": "class Solution {\n    public void sortColors(int[] nums) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        ",
        "c": "void sortColors(int* nums, int numsSize) {\n    \n}",
        "csharp": "public class Solution {\n    public void SortColors(int[] nums) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar sortColors = function(nums) {\n    \n};",
        "typescript": "/**\n Do not return anything, modify nums in-place instead.\n */\nfunction sortColors(nums: number[]): void {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return NULL\n     */\n    function sortColors(&$nums) {\n        \n    }\n}",
        "swift": "class Solution {\n    func sortColors(_ nums: inout [Int]) {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun sortColors(nums: IntArray): Unit {\n        \n    }\n}",
        "dart": "class Solution {\n  void sortColors(List<int> nums) {\n    \n  }\n}",
        "golang": "func sortColors(nums []int)  {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @return {Void} Do not return anything, modify nums in-place instead.\ndef sort_colors(nums)\n    \nend",
        "scala": "object Solution {\n    def sortColors(nums: Array[Int]): Unit = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn sort_colors(nums: &mut Vec<i32>) {\n        \n    }\n}"
      }
    },
    {
      "title": "Minimum Window Substring",
      "problem_id": "76",
      "frontend_id": "76",
      "difficulty": "Hard",
      "problem_slug": "minimum-window-substring",
      "topics": [
        "Hash Table",
        "String",
        "Sliding Window"
      ],
      "description": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\nThe testcases will be generated such that the answer is unique.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you find an algorithm that runs in O(m + n) time?",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: s = \"a\", t = \"a\"\nOutput: \"a\"\nExplanation: The entire string s is the minimum window.",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: s = \"a\", t = \"aa\"\nOutput: \"\"\nExplanation: Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.",
          "images": []
        }
      ],
      "constraints": [
        "m == s.length",
        "n == t.length",
        "1 <= m, n <= 105",
        "s and t consist of uppercase and lowercase English letters."
      ],
      "follow_ups": [
        "Could you find an algorithm that runs in O(m + n) time?"
      ],
      "hints": [
        "Use two pointers to create a window of letters in s, which would have all the characters from t.",
        "Expand the right pointer until all the characters of t are covered.",
        "Once all the characters are covered, move the left pointer and ensure that all the characters are still covered to minimize the subarray size.",
        "Continue expanding the right and left pointers until you reach the end of s."
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    string minWindow(string s, string t) {\n        \n    }\n};",
        "java": "class Solution {\n    public String minWindow(String s, String t) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        ",
        "c": "char* minWindow(char* s, char* t) {\n    \n}",
        "csharp": "public class Solution {\n    public string MinWindow(string s, string t) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} s\n * @param {string} t\n * @return {string}\n */\nvar minWindow = function(s, t) {\n    \n};",
        "typescript": "function minWindow(s: string, t: string): string {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String $t\n     * @return String\n     */\n    function minWindow($s, $t) {\n        \n    }\n}",
        "swift": "class Solution {\n    func minWindow(_ s: String, _ t: String) -> String {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun minWindow(s: String, t: String): String {\n        \n    }\n}",
        "dart": "class Solution {\n  String minWindow(String s, String t) {\n    \n  }\n}",
        "golang": "func minWindow(s string, t string) string {\n    \n}",
        "ruby": "# @param {String} s\n# @param {String} t\n# @return {String}\ndef min_window(s, t)\n    \nend",
        "scala": "object Solution {\n    def minWindow(s: String, t: String): String = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn min_window(s: String, t: String) -> String {\n        \n    }\n}",
        "racket": "(define/contract (min-window s t)\n  (-> string? string? string?)\n  )",
        "erlang": "-spec min_window(S :: unicode:unicode_binary(), T :: unicode:unicode_binary()) -> unicode:unicode_binary().\nmin_window(S, T) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec min_window(s :: String.t, t :: String.t) :: String.t\n  def min_window(s, t) do\n    \n  end\nend"
      }
    },
    {
      "title": "Combinations",
      "problem_id": "77",
      "frontend_id": "77",
      "difficulty": "Medium",
      "problem_slug": "combinations",
      "topics": [
        "Backtracking"
      ],
      "description": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\nYou may return the answer in any order.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: n = 4, k = 2\nOutput: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nExplanation: There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: n = 1, k = 1\nOutput: [[1]]\nExplanation: There is 1 choose 1 = 1 total combination.",
          "images": []
        }
      ],
      "constraints": [
        "1 <= n <= 20",
        "1 <= k <= n"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> combine(int n, int k) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        ",
        "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** combine(int n, int k, int* returnSize, int** returnColumnSizes) {\n    \n}",
        "csharp": "public class Solution {\n    public IList<IList<int>> Combine(int n, int k) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number} n\n * @param {number} k\n * @return {number[][]}\n */\nvar combine = function(n, k) {\n    \n};",
        "typescript": "function combine(n: number, k: number): number[][] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $k\n     * @return Integer[][]\n     */\n    function combine($n, $k) {\n        \n    }\n}",
        "swift": "class Solution {\n    func combine(_ n: Int, _ k: Int) -> [[Int]] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun combine(n: Int, k: Int): List<List<Int>> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<List<int>> combine(int n, int k) {\n    \n  }\n}",
        "golang": "func combine(n int, k int) [][]int {\n    \n}",
        "ruby": "# @param {Integer} n\n# @param {Integer} k\n# @return {Integer[][]}\ndef combine(n, k)\n    \nend",
        "scala": "object Solution {\n    def combine(n: Int, k: Int): List[List[Int]] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn combine(n: i32, k: i32) -> Vec<Vec<i32>> {\n        \n    }\n}",
        "racket": "(define/contract (combine n k)\n  (-> exact-integer? exact-integer? (listof (listof exact-integer?)))\n  )",
        "erlang": "-spec combine(N :: integer(), K :: integer()) -> [[integer()]].\ncombine(N, K) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec combine(n :: integer, k :: integer) :: [[integer]]\n  def combine(n, k) do\n    \n  end\nend"
      }
    },
    {
      "title": "Subsets",
      "problem_id": "78",
      "frontend_id": "78",
      "difficulty": "Medium",
      "problem_slug": "subsets",
      "topics": [
        "Array",
        "Backtracking",
        "Bit Manipulation"
      ],
      "description": "Given an integer array nums of unique elements, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [0]\nOutput: [[],[0]]",
          "images": []
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10",
        "-10 <= nums[i] <= 10",
        "All the numbers of nums are unique."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        ",
        "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\n    \n}",
        "csharp": "public class Solution {\n    public IList<IList<int>> Subsets(int[] nums) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function(nums) {\n    \n};",
        "typescript": "function subsets(nums: number[]): number[][] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[][]\n     */\n    function subsets($nums) {\n        \n    }\n}",
        "swift": "class Solution {\n    func subsets(_ nums: [Int]) -> [[Int]] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun subsets(nums: IntArray): List<List<Int>> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<List<int>> subsets(List<int> nums) {\n    \n  }\n}",
        "golang": "func subsets(nums []int) [][]int {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @return {Integer[][]}\ndef subsets(nums)\n    \nend",
        "scala": "object Solution {\n    def subsets(nums: Array[Int]): List[List[Int]] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn subsets(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        \n    }\n}",
        "racket": "(define/contract (subsets nums)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)))\n  )",
        "erlang": "-spec subsets(Nums :: [integer()]) -> [[integer()]].\nsubsets(Nums) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec subsets(nums :: [integer]) :: [[integer]]\n  def subsets(nums) do\n    \n  end\nend"
      },
      "solution": "[TOC]\n\n## Video Solution\n---## Solution Article\n\n---\n\n### Overview: Solution Pattern\n\nLet us first review the problems of Permutations / Combinations / Subsets, since they are quite similar to each other and there are some common strategies to solve them.\n\nFirst, their solution space is often quite large:\n\n- [Permutations](https://en.wikipedia.org/wiki/Permutation#k-permutations_of_n): $$N!$$. \n\n- [Combinations](https://en.wikipedia.org/wiki/Combination#Number_of_k-combinations): $$C_N^k = \\frac{N!}{(N - k)! k!}$$\n\n- Subsets: $$2^N$$, since each element could be absent or present. \n\nGiven their exponential solution space, it is tricky to ensure that the generated solutions are _**complete**_ and _**non-redundant**_. It is essential to have a clear and easy-to-reason strategy.\n\nThere are generally three strategies to do it:\n\n- Iterative\n\n- Recursion/Backtracking\n\n- Lexicographic generation based on the mapping between binary bitmasks and the corresponding permutations / combinations / subsets.\n\nAs one would see later, the third method could be a good candidate for the interview because it simplifies the problem to the generation of binary numbers, therefore it is easy to implement and verify that no solution is missing.\n\nBesides, as a bonus, it generates lexicographically sorted output for the sorted inputs.\n\n\n---\n### Approach 1: Cascading\n\n#### Intuition\n\nLet's start from an empty subset in the output list. At each step, one takes a new integer into consideration and generates new subsets from the existing ones. \n\n![diff](../Figures/78/recursion.png)\n\n#### Implementation#### Complexity Analysis\n\n* Time complexity: $$\\mathcal{O}(N \\times 2^N)$$ to generate all subsets and then copy them into the output list. \n    \n* Space complexity: $$\\mathcal{O}(N \\times 2^N)$$. This is exactly the number of solutions for subsets multiplied by the number $$N$$ of elements to keep for each subset.  \n    - For a given number, it could be present or absent (_i.e._ binary choice) in a subset solution. As a result, for $$N$$ numbers, we would have in total $$2^N$$ choices (solutions).---\n### Approach 2: Backtracking\n\n#### Algorithm\n\n>Power set is all possible combinations of all possible _lengths_, from 0 to n.\n\nGiven the definition, the problem can also be interpreted as finding the _power set_ from a sequence.\n\nSo, this time let us loop over the length of combination, rather than the candidate numbers, and generate all combinations for a given length with the help of _backtracking_ technique.\n\n![diff](../Figures/78/combinations.png)\n\n>[Backtracking](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/) is an algorithm for finding all solutions by exploring all potential candidates. If the solution candidate turns out to be _not_ a solution (or at least not the _last_ one), the backtracking algorithm discards it by making some changes on the previous step, *i.e.* _backtracks_ and then tries again.\n\n![diff](../Figures/78/backtracking.png)\n\n#### Algorithm\n\nWe define a backtrack function named `backtrack(first, curr)` that takes the index of the first element to add and a current combination as arguments.\n\n- If the current combination is done, we add the combination to the final output.\n\n- Otherwise, we iterate over the indexes `i` from `first` to the length of the entire sequence `n`.\n\n    - Add integer `nums[i]` into the current combination `curr`.\n\n    - Proceed to add more integers into the combination: `backtrack(i + 1, curr)`.\n\n    - Backtrack by removing `nums[i]` from `curr`.\n\n#### Implementation#### Complexity Analysis\n\n* Time complexity: $$\\mathcal{O}(N \\times 2^N)$$ to generate all subsets and then copy them into the output list.\n \n* Space complexity: $$\\mathcal{O}(N)$$. We are using $$O(N)$$ space to maintain `curr`, and are modifying `curr` in-place with backtracking. Note that for space complexity analysis, we do not count space that is *only* used for the purpose of returning output, so the `output` array is ignored.\n\n\n---\n### Approach 3: Lexicographic (Binary Sorted) Subsets\n\n#### Intuition\n\nThe idea of this solution is originated from [Donald E. Knuth](https://www-cs-faculty.stanford.edu/~knuth/taocp.html).\n\n>The idea is that we map each subset to a bitmask of length n,\nwhere `1` on the i*th* position in bitmask means the presence of `nums[i]`\nin the subset, and `0` means its absence. \n\n![diff](../Figures/78/bitmask4.png)\n\nFor instance, the bitmask `0..00` (all zeros) corresponds to an empty subset, \nand the bitmask `1..11` (all ones) corresponds to the entire input array `nums`. \n\nHence to solve the initial problem, we just need to generate n bitmasks\nfrom `0..00` to `1..11`. \n\nIt might seem simple at first glance to generate binary numbers, but \nthe real problem here is how to deal with \n[zero left padding](https://en.wikipedia.org/wiki/Padding_(cryptography)#Zero_padding),\nbecause one has to generate bitmasks of fixed length, _i.e._ `001` and not just `1`.\nFor that one could use standard bit manipulation trick:or keep it simple stupid and shift iteration limits:#### Algorithm\n\n- Generate all possible binary bitmasks of length n.\n\n- Map a subset to each bitmask: \n`1` on the i*th* position in bitmask means the presence of `nums[i]`\nin the subset, and `0` means its absence. \n\n- Return output list.\n\n#### Implementation#### Complexity Analysis\n\n* Time complexity: $$\\mathcal{O}(N \\times 2^N)$$ to generate all subsets \nand then copy them into output list.\n    \n* Space complexity: $$\\mathcal{O}(N)$$ to store the bitset\nof length $$N$$. Note that for space complexity analysis, we do not count space that is *only* used for the purpose of returning output, so the `output` array is ignored."
    },
    {
      "title": "Word Search",
      "problem_id": "79",
      "frontend_id": "79",
      "difficulty": "Medium",
      "problem_slug": "word-search",
      "topics": [
        "Array",
        "String",
        "Backtracking",
        "Depth-First Search",
        "Matrix"
      ],
      "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you use search pruning to make your solution faster with a larger board?",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\nOutput: true",
          "images": [
            "https://assets.leetcode.com/uploads/2020/11/04/word2.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\nOutput: true",
          "images": [
            "https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg"
          ]
        },
        {
          "example_num": 3,
          "example_text": "Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\nOutput: false",
          "images": [
            "https://assets.leetcode.com/uploads/2020/10/15/word3.jpg"
          ]
        }
      ],
      "constraints": [
        "m == board.length",
        "n = board[i].length",
        "1 <= m, n <= 6",
        "1 <= word.length <= 15",
        "board and word consists of only lowercase and uppercase English letters."
      ],
      "follow_ups": [
        "Could you use search pruning to make your solution faster with a larger board?"
      ],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        \n    }\n};",
        "java": "class Solution {\n    public boolean exist(char[][] board, String word) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        ",
        "c": "bool exist(char** board, int boardSize, int* boardColSize, char* word) {\n    \n}",
        "csharp": "public class Solution {\n    public bool Exist(char[][] board, string word) {\n        \n    }\n}",
        "javascript": "/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nvar exist = function(board, word) {\n    \n};",
        "typescript": "function exist(board: string[][], word: string): boolean {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String[][] $board\n     * @param String $word\n     * @return Boolean\n     */\n    function exist($board, $word) {\n        \n    }\n}",
        "swift": "class Solution {\n    func exist(_ board: [[Character]], _ word: String) -> Bool {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun exist(board: Array<CharArray>, word: String): Boolean {\n        \n    }\n}",
        "dart": "class Solution {\n  bool exist(List<List<String>> board, String word) {\n    \n  }\n}",
        "golang": "func exist(board [][]byte, word string) bool {\n    \n}",
        "ruby": "# @param {Character[][]} board\n# @param {String} word\n# @return {Boolean}\ndef exist(board, word)\n    \nend",
        "scala": "object Solution {\n    def exist(board: Array[Array[Char]], word: String): Boolean = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn exist(board: Vec<Vec<char>>, word: String) -> bool {\n        \n    }\n}",
        "racket": "(define/contract (exist board word)\n  (-> (listof (listof char?)) string? boolean?)\n  )",
        "erlang": "-spec exist(Board :: [[char()]], Word :: unicode:unicode_binary()) -> boolean().\nexist(Board, Word) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec exist(board :: [[char]], word :: String.t) :: boolean\n  def exist(board, word) do\n    \n  end\nend"
      }
    },
    {
      "title": "Remove Duplicates from Sorted Array II",
      "problem_id": "80",
      "frontend_id": "80",
      "difficulty": "Medium",
      "problem_slug": "remove-duplicates-from-sorted-array-ii",
      "topics": [
        "Array",
        "Two Pointers"
      ],
      "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nIf all assertions pass, then your solution will be accepted.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "int[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
          "images": []
        }
      ],
      "constraints": [
        "1 <= nums.length <= 3 * 104",
        "-104 <= nums[i] <= 104",
        "nums is sorted in non-decreasing order."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        \n    }\n};",
        "java": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        ",
        "c": "int removeDuplicates(int* nums, int numsSize) {\n    \n}",
        "csharp": "public class Solution {\n    public int RemoveDuplicates(int[] nums) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    \n};",
        "typescript": "function removeDuplicates(nums: number[]): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function removeDuplicates(&$nums) {\n        \n    }\n}",
        "swift": "class Solution {\n    func removeDuplicates(_ nums: inout [Int]) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun removeDuplicates(nums: IntArray): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int removeDuplicates(List<int> nums) {\n    \n  }\n}",
        "golang": "func removeDuplicates(nums []int) int {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef remove_duplicates(nums)\n    \nend",
        "scala": "object Solution {\n    def removeDuplicates(nums: Array[Int]): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\n        \n    }\n}"
      }
    },
    {
      "title": "Search in Rotated Sorted Array II",
      "problem_id": "81",
      "frontend_id": "81",
      "difficulty": "Medium",
      "problem_slug": "search-in-rotated-sorted-array-ii",
      "topics": [
        "Array",
        "Binary Search"
      ],
      "description": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).\nBefore being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].\nGiven the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.\nYou must decrease the overall operation steps as much as possible.\nExample 1:\nExample 2:\nConstraints:\nFollow up: This problem is similar to Search in Rotated Sorted Array, but nums may contain duplicates. Would this affect the runtime complexity? How and why?",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false",
          "images": []
        }
      ],
      "constraints": [
        "1 <= nums.length <= 5000",
        "-104 <= nums[i] <= 104",
        "nums is guaranteed to be rotated at some pivot.",
        "-104 <= target <= 104"
      ],
      "follow_ups": [
        "This problem is similar to Search in Rotated Sorted Array, but nums may contain duplicates. Would this affect the runtime complexity? How and why?"
      ],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        \n    }\n};",
        "java": "class Solution {\n    public boolean search(int[] nums, int target) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        ",
        "c": "bool search(int* nums, int numsSize, int target) {\n    \n}",
        "csharp": "public class Solution {\n    public bool Search(int[] nums, int target) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {boolean}\n */\nvar search = function(nums, target) {\n    \n};",
        "typescript": "function search(nums: number[], target: number): boolean {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Boolean\n     */\n    function search($nums, $target) {\n        \n    }\n}",
        "swift": "class Solution {\n    func search(_ nums: [Int], _ target: Int) -> Bool {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun search(nums: IntArray, target: Int): Boolean {\n        \n    }\n}",
        "dart": "class Solution {\n  bool search(List<int> nums, int target) {\n    \n  }\n}",
        "golang": "func search(nums []int, target int) bool {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Boolean}\ndef search(nums, target)\n    \nend",
        "scala": "object Solution {\n    def search(nums: Array[Int], target: Int): Boolean = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn search(nums: Vec<i32>, target: i32) -> bool {\n        \n    }\n}",
        "racket": "(define/contract (search nums target)\n  (-> (listof exact-integer?) exact-integer? boolean?)\n  )",
        "erlang": "-spec search(Nums :: [integer()], Target :: integer()) -> boolean().\nsearch(Nums, Target) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec search(nums :: [integer], target :: integer) :: boolean\n  def search(nums, target) do\n    \n  end\nend"
      }
    },
    {
      "title": "Remove Duplicates from Sorted List II",
      "problem_id": "82",
      "frontend_id": "82",
      "difficulty": "Medium",
      "problem_slug": "remove-duplicates-from-sorted-list-ii",
      "topics": [
        "Linked List",
        "Two Pointers"
      ],
      "description": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: head = [1,2,3,3,4,4,5]\nOutput: [1,2,5]",
          "images": [
            "https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: head = [1,1,1,2,3]\nOutput: [2,3]",
          "images": [
            "https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg"
          ]
        }
      ],
      "constraints": [
        "The number of nodes in the list is in the range [0, 300].",
        "-100 <= Node.val <= 100",
        "The list is guaranteed to be sorted in ascending order."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        \n    }\n};",
        "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        \n    }\n}",
        "python": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        ",
        "python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        ",
        "c": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\n    \n}",
        "csharp": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode DeleteDuplicates(ListNode head) {\n        \n    }\n}",
        "javascript": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar deleteDuplicates = function(head) {\n    \n};",
        "typescript": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\n    \n};",
        "php": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function deleteDuplicates($head) {\n        \n    }\n}",
        "swift": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\n        \n    }\n}",
        "kotlin": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun deleteDuplicates(head: ListNode?): ListNode? {\n        \n    }\n}",
        "dart": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? deleteDuplicates(ListNode? head) {\n    \n  }\n}",
        "golang": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc deleteDuplicates(head *ListNode) *ListNode {\n    \n}",
        "ruby": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @return {ListNode}\ndef delete_duplicates(head)\n    \nend",
        "scala": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def deleteDuplicates(head: ListNode): ListNode = {\n        \n    }\n}",
        "rust": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        \n    }\n}",
        "racket": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (delete-duplicates head)\n  (-> (or/c list-node? #f) (or/c list-node? #f))\n  )",
        "erlang": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec delete_duplicates(Head :: #list_node{} | null) -> #list_node{} | null.\ndelete_duplicates(Head) ->\n  .",
        "elixir": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec delete_duplicates(head :: ListNode.t | nil) :: ListNode.t | nil\n  def delete_duplicates(head) do\n    \n  end\nend"
      }
    },
    {
      "title": "Remove Duplicates from Sorted List",
      "problem_id": "83",
      "frontend_id": "83",
      "difficulty": "Easy",
      "problem_slug": "remove-duplicates-from-sorted-list",
      "topics": [
        "Linked List"
      ],
      "description": "Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: head = [1,1,2]\nOutput: [1,2]",
          "images": [
            "https://assets.leetcode.com/uploads/2021/01/04/list1.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: head = [1,1,2,3,3]\nOutput: [1,2,3]",
          "images": [
            "https://assets.leetcode.com/uploads/2021/01/04/list2.jpg"
          ]
        }
      ],
      "constraints": [
        "The number of nodes in the list is in the range [0, 300].",
        "-100 <= Node.val <= 100",
        "The list is guaranteed to be sorted in ascending order."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        \n    }\n};",
        "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        \n    }\n}",
        "python": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        ",
        "python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        ",
        "c": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\n    \n}",
        "csharp": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode DeleteDuplicates(ListNode head) {\n        \n    }\n}",
        "javascript": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar deleteDuplicates = function(head) {\n    \n};",
        "typescript": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\n    \n};",
        "php": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function deleteDuplicates($head) {\n        \n    }\n}",
        "swift": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\n        \n    }\n}",
        "kotlin": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun deleteDuplicates(head: ListNode?): ListNode? {\n        \n    }\n}",
        "dart": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? deleteDuplicates(ListNode? head) {\n    \n  }\n}",
        "golang": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc deleteDuplicates(head *ListNode) *ListNode {\n    \n}",
        "ruby": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @return {ListNode}\ndef delete_duplicates(head)\n    \nend",
        "scala": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def deleteDuplicates(head: ListNode): ListNode = {\n        \n    }\n}",
        "rust": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        \n    }\n}",
        "racket": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (delete-duplicates head)\n  (-> (or/c list-node? #f) (or/c list-node? #f))\n  )",
        "erlang": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec delete_duplicates(Head :: #list_node{} | null) -> #list_node{} | null.\ndelete_duplicates(Head) ->\n  .",
        "elixir": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec delete_duplicates(head :: ListNode.t | nil) :: ListNode.t | nil\n  def delete_duplicates(head) do\n    \n  end\nend"
      }
    },
    {
      "title": "Largest Rectangle in Histogram",
      "problem_id": "84",
      "frontend_id": "84",
      "difficulty": "Hard",
      "problem_slug": "largest-rectangle-in-histogram",
      "topics": [
        "Array",
        "Stack",
        "Monotonic Stack"
      ],
      "description": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: heights = [2,1,5,6,2,3]\nOutput: 10\nExplanation: The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.",
          "images": [
            "https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: heights = [2,4]\nOutput: 4",
          "images": [
            "https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg"
          ]
        }
      ],
      "constraints": [
        "1 <= heights.length <= 105",
        "0 <= heights[i] <= 104"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        \n    }\n};",
        "java": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        ",
        "c": "int largestRectangleArea(int* heights, int heightsSize) {\n    \n}",
        "csharp": "public class Solution {\n    public int LargestRectangleArea(int[] heights) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} heights\n * @return {number}\n */\nvar largestRectangleArea = function(heights) {\n    \n};",
        "typescript": "function largestRectangleArea(heights: number[]): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $heights\n     * @return Integer\n     */\n    function largestRectangleArea($heights) {\n        \n    }\n}",
        "swift": "class Solution {\n    func largestRectangleArea(_ heights: [Int]) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun largestRectangleArea(heights: IntArray): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int largestRectangleArea(List<int> heights) {\n    \n  }\n}",
        "golang": "func largestRectangleArea(heights []int) int {\n    \n}",
        "ruby": "# @param {Integer[]} heights\n# @return {Integer}\ndef largest_rectangle_area(heights)\n    \nend",
        "scala": "object Solution {\n    def largestRectangleArea(heights: Array[Int]): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn largest_rectangle_area(heights: Vec<i32>) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (largest-rectangle-area heights)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
        "erlang": "-spec largest_rectangle_area(Heights :: [integer()]) -> integer().\nlargest_rectangle_area(Heights) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec largest_rectangle_area(heights :: [integer]) :: integer\n  def largest_rectangle_area(heights) do\n    \n  end\nend"
      }
    },
    {
      "title": "Maximal Rectangle",
      "problem_id": "85",
      "frontend_id": "85",
      "difficulty": "Hard",
      "problem_slug": "maximal-rectangle",
      "topics": [
        "Array",
        "Dynamic Programming",
        "Stack",
        "Matrix",
        "Monotonic Stack"
      ],
      "description": "Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 6\nExplanation: The maximal rectangle is shown in the above picture.",
          "images": [
            "https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: matrix = [[\"0\"]]\nOutput: 0",
          "images": [
            "https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg"
          ]
        },
        {
          "example_num": 3,
          "example_text": "Input: matrix = [[\"1\"]]\nOutput: 1",
          "images": [
            "https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg"
          ]
        }
      ],
      "constraints": [
        "rows == matrix.length",
        "cols == matrix[i].length",
        "1 <= row, cols <= 200",
        "matrix[i][j] is '0' or '1'."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n        \n    }\n};",
        "java": "class Solution {\n    public int maximalRectangle(char[][] matrix) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        ",
        "c": "int maximalRectangle(char** matrix, int matrixSize, int* matrixColSize) {\n    \n}",
        "csharp": "public class Solution {\n    public int MaximalRectangle(char[][] matrix) {\n        \n    }\n}",
        "javascript": "/**\n * @param {character[][]} matrix\n * @return {number}\n */\nvar maximalRectangle = function(matrix) {\n    \n};",
        "typescript": "function maximalRectangle(matrix: string[][]): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String[][] $matrix\n     * @return Integer\n     */\n    function maximalRectangle($matrix) {\n        \n    }\n}",
        "swift": "class Solution {\n    func maximalRectangle(_ matrix: [[Character]]) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun maximalRectangle(matrix: Array<CharArray>): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int maximalRectangle(List<List<String>> matrix) {\n    \n  }\n}",
        "golang": "func maximalRectangle(matrix [][]byte) int {\n    \n}",
        "ruby": "# @param {Character[][]} matrix\n# @return {Integer}\ndef maximal_rectangle(matrix)\n    \nend",
        "scala": "object Solution {\n    def maximalRectangle(matrix: Array[Array[Char]]): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn maximal_rectangle(matrix: Vec<Vec<char>>) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (maximal-rectangle matrix)\n  (-> (listof (listof char?)) exact-integer?)\n  )",
        "erlang": "-spec maximal_rectangle(Matrix :: [[char()]]) -> integer().\nmaximal_rectangle(Matrix) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec maximal_rectangle(matrix :: [[char]]) :: integer\n  def maximal_rectangle(matrix) do\n    \n  end\nend"
      }
    },
    {
      "title": "Partition List",
      "problem_id": "86",
      "frontend_id": "86",
      "difficulty": "Medium",
      "problem_slug": "partition-list",
      "topics": [
        "Linked List",
        "Two Pointers"
      ],
      "description": "Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: head = [1,4,3,2,5,2], x = 3\nOutput: [1,2,2,4,3,5]",
          "images": [
            "https://assets.leetcode.com/uploads/2021/01/04/partition.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: head = [2,1], x = 2\nOutput: [1,2]",
          "images": [
            "https://assets.leetcode.com/uploads/2021/01/04/partition.jpg"
          ]
        }
      ],
      "constraints": [
        "The number of nodes in the list is in the range [0, 200].",
        "-100 <= Node.val <= 100",
        "-200 <= x <= 200"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        \n    }\n};",
        "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode partition(ListNode head, int x) {\n        \n    }\n}",
        "python": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type x: int\n        :rtype: Optional[ListNode]\n        \"\"\"\n        ",
        "python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\n        ",
        "c": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* partition(struct ListNode* head, int x) {\n    \n}",
        "csharp": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode Partition(ListNode head, int x) {\n        \n    }\n}",
        "javascript": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} x\n * @return {ListNode}\n */\nvar partition = function(head, x) {\n    \n};",
        "typescript": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction partition(head: ListNode | null, x: number): ListNode | null {\n    \n};",
        "php": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @param Integer $x\n     * @return ListNode\n     */\n    function partition($head, $x) {\n        \n    }\n}",
        "swift": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func partition(_ head: ListNode?, _ x: Int) -> ListNode? {\n        \n    }\n}",
        "kotlin": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun partition(head: ListNode?, x: Int): ListNode? {\n        \n    }\n}",
        "dart": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? partition(ListNode? head, int x) {\n    \n  }\n}",
        "golang": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc partition(head *ListNode, x int) *ListNode {\n    \n}",
        "ruby": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @param {Integer} x\n# @return {ListNode}\ndef partition(head, x)\n    \nend",
        "scala": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def partition(head: ListNode, x: Int): ListNode = {\n        \n    }\n}",
        "rust": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn partition(head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\n        \n    }\n}",
        "racket": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (partition head x)\n  (-> (or/c list-node? #f) exact-integer? (or/c list-node? #f))\n  )",
        "erlang": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec partition(Head :: #list_node{} | null, X :: integer()) -> #list_node{} | null.\npartition(Head, X) ->\n  .",
        "elixir": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec partition(head :: ListNode.t | nil, x :: integer) :: ListNode.t | nil\n  def partition(head, x) do\n    \n  end\nend"
      }
    },
    {
      "title": "Scramble String",
      "problem_id": "87",
      "frontend_id": "87",
      "difficulty": "Hard",
      "problem_slug": "scramble-string",
      "topics": [
        "String",
        "Dynamic Programming"
      ],
      "description": "We can scramble a string s to get a string t using the following algorithm:\nGiven two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: s1 = \"abcde\", s2 = \"caebd\"\nOutput: false",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: s1 = \"a\", s2 = \"a\"\nOutput: true",
          "images": []
        }
      ],
      "constraints": [
        "s1.length == s2.length",
        "1 <= s1.length <= 30",
        "s1 and s2 consist of lowercase English letters."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    bool isScramble(string s1, string s2) {\n        \n    }\n};",
        "java": "class Solution {\n    public boolean isScramble(String s1, String s2) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        ",
        "c": "bool isScramble(char* s1, char* s2) {\n    \n}",
        "csharp": "public class Solution {\n    public bool IsScramble(string s1, string s2) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nvar isScramble = function(s1, s2) {\n    \n};",
        "typescript": "function isScramble(s1: string, s2: string): boolean {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $s1\n     * @param String $s2\n     * @return Boolean\n     */\n    function isScramble($s1, $s2) {\n        \n    }\n}",
        "swift": "class Solution {\n    func isScramble(_ s1: String, _ s2: String) -> Bool {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun isScramble(s1: String, s2: String): Boolean {\n        \n    }\n}",
        "dart": "class Solution {\n  bool isScramble(String s1, String s2) {\n    \n  }\n}",
        "golang": "func isScramble(s1 string, s2 string) bool {\n    \n}",
        "ruby": "# @param {String} s1\n# @param {String} s2\n# @return {Boolean}\ndef is_scramble(s1, s2)\n    \nend",
        "scala": "object Solution {\n    def isScramble(s1: String, s2: String): Boolean = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn is_scramble(s1: String, s2: String) -> bool {\n        \n    }\n}",
        "racket": "(define/contract (is-scramble s1 s2)\n  (-> string? string? boolean?)\n  )",
        "erlang": "-spec is_scramble(S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary()) -> boolean().\nis_scramble(S1, S2) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec is_scramble(s1 :: String.t, s2 :: String.t) :: boolean\n  def is_scramble(s1, s2) do\n    \n  end\nend"
      },
      "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach: Dynamic Programming\n\n#### Intuition\n\nWe have a recursive definition of scrambling a string `s`. First, we divide `s` into `x` and `y`. Then we either keep `s` as `x + y` or swap them and get `y + x`. After that, we scramble `x` and `y` independently. Let `x'` denote the scrambled `x` and `y'` denote the scrambled `y`. `s` will eventually become `x' + y'` or `y' + x'`.\n\n![split](../Figures/87/diagram2.drawio.png)\n\nHow do we check whether a given string `t` is a scrambled string of `s`? First, we choose an index and cut `s` into `x` and `y` (`s = x + y`). Then, we see if we can cut `t` into `x'` and `y'` (`t = x' + y'` if we do not swap or `t = y' + x'` if we do). Since verifying that `x'` is a scrambled `x` and `y'` is scrambled `y` are smaller subproblems, we will solve the problem using dynamic programming.\n\nWe have two strings `s1` and `s2`.\n\nFor each given dp state, we need 3 variables: `length`, `i`, and `j`.\n\nEach state will focus on two substrings. The first one will be a substring of `s1`, starting at index `i` with length equal to `length` - let's call this substring `s`. The second one will be a substring of `s2`, starting at index `j` with `length` - let's call this substring `t`.\n\nLet `dp[length][i][j]` be a boolean representing whether `t` is a scrambled version of `s`.\n\nThe base case, as defined by the problem is when `length = 1`. Here we do not have to split strings into smaller ones, so we can easily compare the corresponding characters: `dp[1][i][j]` is `true` when `s1[i]` equals `s2[j]`, and `false` otherwise.\n\nNow we need to write down the transitions of `dp`. We will use the following image as an example during the explanations.\n\n![split](../Figures/87/diagram.drawio.png)\n\nAt each state, we need to perform a split on `s1`. We will consider all possible splits. If we are currently considering a substring with a length of `length`, then we could perform a split at any index `newLength`, where `0 < newLength < length`. (Here, `newLength` represents the length of the left string after the split). A split gives us two new strings:\n\n- A substring of `s1` starting at index `i` and ending with index `i + newLength - 1`. This string has a length of `newLength` (Blue in the picture)\n\n- A substring of `s1` starting at index `i + newLength` and ending at index `i + length - 1`. This string has a length of `length - newLength`. (Yellow in the picture)\n\nFor each split, we have two cases:\n\n* Do not swap the blue and yellow parts. The corresponding substrings of `s2` must be scrambled versions of the substrings we just created by splitting `s1`. This means both `dp[newLength][i][j]` (representing the blue parts) and `dp[length - newLength][i + newLength][j + newLength]` (representing the yellow parts) must be true.\n* Swap the blue and yellow parts. As you can see in the image, this misaligns the blue and yellow parts between `s1` and `s2`, but we still need the parts to match (we still need the blue part of `s1` to be a scrambled version of the blue part of `s2`, same with the yellow part). What are the new starting indices? For blue, it's `s1` starting with `i` and `s2` starting with `j + length - newLength`. For yellow, it's `s1` starting with `i + newLength` and `s2` starting with `j`. Thus, we need both `dp[newLength][i][j+length-newLength]` and `dp[length-newLength][i+newLength][j]` to be `true`.\n\nNow we can formally write down the transitions. For `length > 1`, `dp[length][i][j]` is `true` if and only if for at least one `newLength` where `0 < newLength < length`:\n\n`(dp[newLength][i][j] && dp[length-newLength][i+newLength][j+newLength]) || (dp[newLength][i][j+length-newLength] && dp[length-newLength][i+newLength][j])` is `true`.\n\nLet `n` denote the length of the input strings. The answer to the problem is `dp[n][0][0]`, as starting at index `0` with length `n` is considering the entire input string.\n\n#### Algorithm\n\n1. Iterate `i` from `0` to `n-1`.\n\t* Iterate `j` from `0` to `n-1`.\n\t\t* Set `dp[1][i][j]` to the boolean value of `s1[i] == s2[j]`. (The base case of the DP).\n2. Iterate `length` from `2` to `n`.\n\t* Iterate `i` from `0` to `n + 1 - length`.\n\t\t* Iterate `j` from `0` to `n + 1 - length`.\n\t\t\t* Iterate `newLength` from `1` to `length - 1`.\n\t\t\t\t* If `dp[newLength][i][j] && dp[length-newLength][i+newLength][j+newLength]) || (dp[newLength][i][j+l-newLength] && dp[l-newLength][i+newLength][j]` is `true`, set `dp[length][i][j]` to `true`.\n3. Return `dp[n][0][0]`.\n\n#### Implementation#### Complexity Analysis\n\n* Time complexity: $O(n^4)$.\n\nWe have four nested for loops (for `length`, `i`, `j`, `newLength`), each doing $O(n)$ iterations.\n\n* Space complexity: $O(n^3)$.\n\nWe store the matrix `dp[n+1][n][n]` for dynamic programming."
    },
    {
      "title": "Merge Sorted Array",
      "problem_id": "88",
      "frontend_id": "88",
      "difficulty": "Easy",
      "problem_slug": "merge-sorted-array",
      "topics": [
        "Array",
        "Two Pointers",
        "Sorting"
      ],
      "description": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Can you come up with an algorithm that runs in O(m + n) time?",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums1 = [1], m = 1, nums2 = [], n = 0\nOutput: [1]\nExplanation: The arrays we are merging are [1] and [].\nThe result of the merge is [1].",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: nums1 = [0], m = 0, nums2 = [1], n = 1\nOutput: [1]\nExplanation: The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.",
          "images": []
        }
      ],
      "constraints": [
        "nums1.length == m + n",
        "nums2.length == n",
        "0 <= m, n <= 200",
        "1 <= m + n <= 200",
        "-109 <= nums1[i], nums2[j] <= 109"
      ],
      "follow_ups": [
        "Can you come up with an algorithm that runs in O(m + n) time?"
      ],
      "hints": [
        "You can easily solve this problem if you simply think about two elements at a time rather than two arrays. We know that each of the individual arrays is sorted. What we don't know is how they will intertwine. Can we take a local decision and arrive at an optimal solution?",
        "If you simply consider one element each at a time from the two arrays and make a decision and proceed accordingly, you will arrive at the optimal solution."
      ],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        \n    }\n};",
        "java": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        ",
        "c": "void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {\n    \n}",
        "csharp": "public class Solution {\n    public void Merge(int[] nums1, int m, int[] nums2, int n) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\nvar merge = function(nums1, m, nums2, n) {\n    \n};",
        "typescript": "/**\n Do not return anything, modify nums1 in-place instead.\n */\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer $m\n     * @param Integer[] $nums2\n     * @param Integer $n\n     * @return NULL\n     */\n    function merge(&$nums1, $m, $nums2, $n) {\n        \n    }\n}",
        "swift": "class Solution {\n    func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun merge(nums1: IntArray, m: Int, nums2: IntArray, n: Int): Unit {\n        \n    }\n}",
        "dart": "class Solution {\n  void merge(List<int> nums1, int m, List<int> nums2, int n) {\n    \n  }\n}",
        "golang": "func merge(nums1 []int, m int, nums2 []int, n int)  {\n    \n}",
        "ruby": "# @param {Integer[]} nums1\n# @param {Integer} m\n# @param {Integer[]} nums2\n# @param {Integer} n\n# @return {Void} Do not return anything, modify nums1 in-place instead.\ndef merge(nums1, m, nums2, n)\n    \nend",
        "scala": "object Solution {\n    def merge(nums1: Array[Int], m: Int, nums2: Array[Int], n: Int): Unit = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn merge(nums1: &mut Vec<i32>, m: i32, nums2: &mut Vec<i32>, n: i32) {\n        \n    }\n}"
      }
    },
    {
      "title": "Gray Code",
      "problem_id": "89",
      "frontend_id": "89",
      "difficulty": "Medium",
      "problem_slug": "gray-code",
      "topics": [
        "Math",
        "Backtracking",
        "Bit Manipulation"
      ],
      "description": "An n-bit gray code sequence is a sequence of 2n integers where:\nGiven an integer n, return any valid n-bit gray code sequence.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: n = 2\nOutput: [0,1,3,2]\nExplanation:\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: n = 1\nOutput: [0,1]",
          "images": []
        }
      ],
      "constraints": [
        "1 <= n <= 16"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<int> grayCode(int n) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<Integer> grayCode(int n) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def grayCode(self, n: int) -> List[int]:\n        ",
        "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* grayCode(int n, int* returnSize) {\n    \n}",
        "csharp": "public class Solution {\n    public IList<int> GrayCode(int n) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number} n\n * @return {number[]}\n */\nvar grayCode = function(n) {\n    \n};",
        "typescript": "function grayCode(n: number): number[] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer[]\n     */\n    function grayCode($n) {\n        \n    }\n}",
        "swift": "class Solution {\n    func grayCode(_ n: Int) -> [Int] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun grayCode(n: Int): List<Int> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<int> grayCode(int n) {\n    \n  }\n}",
        "golang": "func grayCode(n int) []int {\n    \n}",
        "ruby": "# @param {Integer} n\n# @return {Integer[]}\ndef gray_code(n)\n    \nend",
        "scala": "object Solution {\n    def grayCode(n: Int): List[Int] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn gray_code(n: i32) -> Vec<i32> {\n        \n    }\n}",
        "racket": "(define/contract (gray-code n)\n  (-> exact-integer? (listof exact-integer?))\n  )",
        "erlang": "-spec gray_code(N :: integer()) -> [integer()].\ngray_code(N) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec gray_code(n :: integer) :: [integer]\n  def gray_code(n) do\n    \n  end\nend"
      }
    },
    {
      "title": "Subsets II",
      "problem_id": "90",
      "frontend_id": "90",
      "difficulty": "Medium",
      "problem_slug": "subsets-ii",
      "topics": [
        "Array",
        "Backtracking",
        "Bit Manipulation"
      ],
      "description": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: nums = [1,2,2]\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: nums = [0]\nOutput: [[],[0]]",
          "images": []
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10",
        "-10 <= nums[i] <= 10"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        ",
        "c": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** subsetsWithDup(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\n    \n}",
        "csharp": "public class Solution {\n    public IList<IList<int>> SubsetsWithDup(int[] nums) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsetsWithDup = function(nums) {\n    \n};",
        "typescript": "function subsetsWithDup(nums: number[]): number[][] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[][]\n     */\n    function subsetsWithDup($nums) {\n        \n    }\n}",
        "swift": "class Solution {\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun subsetsWithDup(nums: IntArray): List<List<Int>> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<List<int>> subsetsWithDup(List<int> nums) {\n    \n  }\n}",
        "golang": "func subsetsWithDup(nums []int) [][]int {\n    \n}",
        "ruby": "# @param {Integer[]} nums\n# @return {Integer[][]}\ndef subsets_with_dup(nums)\n    \nend",
        "scala": "object Solution {\n    def subsetsWithDup(nums: Array[Int]): List[List[Int]] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn subsets_with_dup(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        \n    }\n}",
        "racket": "(define/contract (subsets-with-dup nums)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)))\n  )",
        "erlang": "-spec subsets_with_dup(Nums :: [integer()]) -> [[integer()]].\nsubsets_with_dup(Nums) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec subsets_with_dup(nums :: [integer]) :: [[integer]]\n  def subsets_with_dup(nums) do\n    \n  end\nend"
      }
    },
    {
      "title": "Decode Ways",
      "problem_id": "91",
      "frontend_id": "91",
      "difficulty": "Medium",
      "problem_slug": "decode-ways",
      "topics": [
        "String",
        "Dynamic Programming"
      ],
      "description": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping:\n\"1\" -> 'A'\n\"2\" -> 'B'\n...\n\"25\" -> 'Y'\n\"26\" -> 'Z'\nHowever, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (\"2\" and \"5\" vs \"25\").\nFor example, \"11106\" can be decoded into:\nNote: there may be strings that are impossible to decode.\n\nGiven a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0.\nThe test cases are generated so that the answer fits in a 32-bit integer.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: s = \"12\"\nOutput: 2\nExplanation:\n\"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: s = \"226\"\nOutput: 3\nExplanation:\n\"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: s = \"06\"\nOutput: 0\nExplanation:\n\"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\"). In this case, the string is not a valid encoding, so return 0.",
          "images": []
        }
      ],
      "constraints": [
        "1 <= s.length <= 100",
        "s contains only digits and may contain leading zero(s)."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int numDecodings(string s) {\n        \n    }\n};",
        "java": "class Solution {\n    public int numDecodings(String s) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        ",
        "c": "int numDecodings(char* s) {\n    \n}",
        "csharp": "public class Solution {\n    public int NumDecodings(string s) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar numDecodings = function(s) {\n    \n};",
        "typescript": "function numDecodings(s: string): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function numDecodings($s) {\n        \n    }\n}",
        "swift": "class Solution {\n    func numDecodings(_ s: String) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun numDecodings(s: String): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int numDecodings(String s) {\n    \n  }\n}",
        "golang": "func numDecodings(s string) int {\n    \n}",
        "ruby": "# @param {String} s\n# @return {Integer}\ndef num_decodings(s)\n    \nend",
        "scala": "object Solution {\n    def numDecodings(s: String): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn num_decodings(s: String) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (num-decodings s)\n  (-> string? exact-integer?)\n  )",
        "erlang": "-spec num_decodings(S :: unicode:unicode_binary()) -> integer().\nnum_decodings(S) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec num_decodings(s :: String.t) :: integer\n  def num_decodings(s) do\n    \n  end\nend"
      }
    },
    {
      "title": "Reverse Linked List II",
      "problem_id": "92",
      "frontend_id": "92",
      "difficulty": "Medium",
      "problem_slug": "reverse-linked-list-ii",
      "topics": [
        "Linked List"
      ],
      "description": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: head = [1,2,3,4,5], left = 2, right = 4\nOutput: [1,4,3,2,5]",
          "images": [
            "https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: head = [5], left = 1, right = 1\nOutput: [5]",
          "images": [
            "https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg"
          ]
        }
      ],
      "constraints": [
        "The number of nodes in the list is n.",
        "1 <= n <= 500",
        "-500 <= Node.val <= 500",
        "1 <= left <= right <= n"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        \n    }\n};",
        "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        \n    }\n}",
        "python": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type left: int\n        :type right: int\n        :rtype: Optional[ListNode]\n        \"\"\"\n        ",
        "python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\n        ",
        "c": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* reverseBetween(struct ListNode* head, int left, int right) {\n    \n}",
        "csharp": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode ReverseBetween(ListNode head, int left, int right) {\n        \n    }\n}",
        "javascript": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} left\n * @param {number} right\n * @return {ListNode}\n */\nvar reverseBetween = function(head, left, right) {\n    \n};",
        "typescript": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction reverseBetween(head: ListNode | null, left: number, right: number): ListNode | null {\n    \n};",
        "php": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @param Integer $left\n     * @param Integer $right\n     * @return ListNode\n     */\n    function reverseBetween($head, $left, $right) {\n        \n    }\n}",
        "swift": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        \n    }\n}",
        "kotlin": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun reverseBetween(head: ListNode?, left: Int, right: Int): ListNode? {\n        \n    }\n}",
        "dart": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? reverseBetween(ListNode? head, int left, int right) {\n    \n  }\n}",
        "golang": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\n    \n}",
        "ruby": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @param {Integer} left\n# @param {Integer} right\n# @return {ListNode}\ndef reverse_between(head, left, right)\n    \nend",
        "scala": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def reverseBetween(head: ListNode, left: Int, right: Int): ListNode = {\n        \n    }\n}",
        "rust": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn reverse_between(head: Option<Box<ListNode>>, left: i32, right: i32) -> Option<Box<ListNode>> {\n        \n    }\n}",
        "racket": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (reverse-between head left right)\n  (-> (or/c list-node? #f) exact-integer? exact-integer? (or/c list-node? #f))\n  )",
        "erlang": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec reverse_between(Head :: #list_node{} | null, Left :: integer(), Right :: integer()) -> #list_node{} | null.\nreverse_between(Head, Left, Right) ->\n  .",
        "elixir": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec reverse_between(head :: ListNode.t | nil, left :: integer, right :: integer) :: ListNode.t | nil\n  def reverse_between(head, left, right) do\n    \n  end\nend"
      }
    },
    {
      "title": "Restore IP Addresses",
      "problem_id": "93",
      "frontend_id": "93",
      "difficulty": "Medium",
      "problem_slug": "restore-ip-addresses",
      "topics": [
        "String",
        "Backtracking"
      ],
      "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
          "images": []
        },
        {
          "example_num": 2,
          "example_text": "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
          "images": []
        },
        {
          "example_num": 3,
          "example_text": "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]",
          "images": []
        }
      ],
      "constraints": [
        "1 <= s.length <= 20",
        "s consists of digits only."
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    vector<string> restoreIpAddresses(string s) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<String> restoreIpAddresses(String s) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def restoreIpAddresses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        ",
        "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** restoreIpAddresses(char* s, int* returnSize) {\n    \n}",
        "csharp": "public class Solution {\n    public IList<string> RestoreIpAddresses(string s) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} s\n * @return {string[]}\n */\nvar restoreIpAddresses = function(s) {\n    \n};",
        "typescript": "function restoreIpAddresses(s: string): string[] {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return String[]\n     */\n    function restoreIpAddresses($s) {\n        \n    }\n}",
        "swift": "class Solution {\n    func restoreIpAddresses(_ s: String) -> [String] {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun restoreIpAddresses(s: String): List<String> {\n        \n    }\n}",
        "dart": "class Solution {\n  List<String> restoreIpAddresses(String s) {\n    \n  }\n}",
        "golang": "func restoreIpAddresses(s string) []string {\n    \n}",
        "ruby": "# @param {String} s\n# @return {String[]}\ndef restore_ip_addresses(s)\n    \nend",
        "scala": "object Solution {\n    def restoreIpAddresses(s: String): List[String] = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn restore_ip_addresses(s: String) -> Vec<String> {\n        \n    }\n}",
        "racket": "(define/contract (restore-ip-addresses s)\n  (-> string? (listof string?))\n  )",
        "erlang": "-spec restore_ip_addresses(S :: unicode:unicode_binary()) -> [unicode:unicode_binary()].\nrestore_ip_addresses(S) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec restore_ip_addresses(s :: String.t) :: [String.t]\n  def restore_ip_addresses(s) do\n    \n  end\nend"
      },
      "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Approach 1: Backtracking\n\n#### Intuition\n\n\nSince a valid IP address consists of 4 integers, that means we need to place 3 dots. We can try putting dots at all possible different positions using backtracking. If an invalid number is formed then we backtrack to try out another combination.\n\n> Backtracking can be defined as a general algorithmic technique that considers searching every possible combination to solve a computational problem. It incrementally builds candidates to the solution and abandons a candidate (\"backtracks\") when it determines that the candidate cannot lead to the solution.\n\nWe will recursively enumerate all the possibilities and whenever we get a new integer because of a dot (or 2 integers for the last dot), we check whether the integer(s) is valid, i.e the integer cannot have leading 0s other than being 0 itself and it's no larger than 255.\nThere are 3 possibilities to add each dot, namely it can be added after 1, 2, or 3 digits from the last dot or the beginning of the string, so there are at most $3 ^ 3 = 27$ possibilities to add all 3 dots.\n\nAn optimization is to return an empty result if the input string's length is longer than 12 since each integer can have 3 digits at most (any more and it would either have leading zeroes or be greater than 255).\n\nWe can create a helper function `valid(s, start, length)` to check whether the substring from index `start` to `start + length` is a valid number from range 0-255. The logic is to check both the conditions (the caller guarantees that the length is in the range of [1, 3]):\n\n1. If the substring's first character is `0` (i.e. `s[start]` is '0'), then `length` must be 1.\n2. If `length` is `3`, the substring should no larger than \"255\" lexically. If the length is 1 or 2 and the first case was not triggered, then it will be in the acceptable range.\n\n#### Algorithm\n\nCreate a function `helper` which takes the original string `s`, the processing index `startIndex` (i.e we only consider the substring starting from `startIndex` and the prefix part is already separated into valid integers.), a list of integers `dots` which saves distances for the dots we have added so far and a list of strings `ans` to save the answers.\n\n1. Set `remainingLength` to `length of s - startIndex` which is the string length we want to process.\n2. Set `remainingNumberOfIntegers` to `4 - dots.length`. This is how many integers we have left to form.\n3. Return if `remainingLength` is larger than `remainingNumberOfIntegers * 3` or smaller than `remainingNumberOfIntegers`, since each integer has 1-3 digits. Also note that this catches the case where `s.length() > 12` since at the very beginning `remainingLength` is `s.length()` and `remainingNumberOfIntegers` is 4.\n4. If `remainingNumberOfIntegers = 1`,\n    * if the last integer `s.substring(startIndex, startIndex + remainingLength)` is valid\n        * Create an empty string to save this answer using the following steps.\n        * Set `last` to `0`.\n        * Iterate over all elements `dot` in the list `dots`.\n            * Append `s.substring(last, last + dot)` and a '.' into the answer string.\n            * Increase `last` by `dot` and repeat these steps for each dot.\n       * Append `s.substring(last, s.length)`. This is the final integer after the last dot.\n       * Add the answer string into `ans`.\n    * Return.\n5. Iterate over `curPos` from `1` to `min(3, remainingLength)`. `curPos` is the number of digits we are including before placing a dot.\n    * Place a dot by adding `curPos` into `dots`.\n    * If the integer `s.substring(startIndex, startIndex + curPos)` is valid\n        * Call helper(s, startIndex + curPos, dots, ans)\n    * Remove the dot that we placed to backtrack.\n\n\n#### Implementation#### Complexity Analysis\n\nLet's assume we need to separate the input string into $N$ integers, each integer is at most $M$ digits.\n\n* Time complexity: $O(M ^ N \\cdot N)$.\n\n There are at most $M ^ {N - 1}$ possibilities, and for each possibility checking whether all parts are valid takes $O(M \\cdot N)$ time, so the final time complexity is $O(M ^ {N - 1}) \\cdot O(M \\cdot N)$ = $O(M ^ N \\cdot N)$.\n\nFor this question, M = 3, N = 4, so the time complexity is $O(1)$.\n\n* Space complexity: $O(M \\cdot N)$.\n\n  For each possibility, we save (N - 1) numbers (the number of digits before each dot) which takes $O(N)$ space. And we need temporary space to save a solution before putting it into the answer list. The length of each solution string is $M \\cdot N + M - 1$ = $O(M \\cdot N)$, so the total space complexity is $O(M \\cdot N)$ if we don't take the output space into consideration.\n\nFor this question, M = 3, N = 4, so the space complexity is $O(1)$.\n\n\n### Approach 2: Iterative\n\n#### Intuition\nWe need to separate the input string into 4 integers, so we can enumerate the length of the first 3 integers, `len1`, `len2`, `len3`. We could iterate over `len1`, `len2`, `len3` with 3 nested loops and the last integer is the remaining part after separating out the first 3.\n\nWe can make the ranges of `len1`, `len2`, `len3` tighter:\n\n* `len1` should be in the range `[max(1, s.length() - 9), min(3, s.length() - 3]` since we need to separate 3 more integers after it and the length of each integer is in [1..3].\n* Similarly, `len2` should be in the range `[max(1, s.length() - len1 - 6, min(3, s.length() - len1 - 2]`\n* `len3` should be in the range `[max(1, s.length() - len1 - len2 - 3), min(3, s.length() - len1 - len2 - 1]`\n\nIn this way, the last part's length is always in the range of `[1..3]`, then we can split each substring out based on the lengths and check whether they are valid. Each integer can be validated before starting the loop of the next part to prevent wasting time.\n\n\n#### Algorithm\n\n1. Initialize an array of strings `ans`.\n2. Iterate over the range of `len1`, the length of the first integer.\n    * If the first integer is valid, then we iterate over `len2`'s range. \n        * If the second integer is also valid, then we iterate over `len3`'s range.\n           * If both third and fourth integers are valid, concatenate all four integers together with a character `'.'` between any 2 neighbors, and add the result string to `ans`.\n3. Return `ans`.\n\n\n#### Implementation#### Complexity Analysis\n\n\nLet's assume we need to separate the input string into $N$ integers, each integer is at most $M$ digits.\n\n* Time complexity: $O(M ^ N \\cdot N)$.\n\n  We have $(N - 1)$ nested loops and each of them iterates at most $M$ times, so the total number of iterations is at most  $M ^ {N - 1}$ .\n\n  In each iteration we split $N$ substrings out to check whether they are valid, each substring's length is at most $M$, so the time complexity to separate out all of them is $O(M \\cdot N)$.\n\nFor this question, M = 3, N = 4, so the time complexity is $O(1)$.\n\n* Space complexity: $O(M \\cdot N)$.\n \nThe algorithm saves (N - 1) numbers (the number of digits before each dot) which takes $O(N)$ space. And we need temporary space to save a solution before putting it into the answer list. The length of each solution string is $M \\cdot N + M - 1$ = $O(M \\cdot N)$, so the total space complexity is $O(M \\cdot N)$ if we don't take the output space into consideration.\n\nFor this question, M = 3, N = 4, so the space complexity is $O(1)$.\n\n---"
    },
    {
      "title": "Binary Tree Inorder Traversal",
      "problem_id": "94",
      "frontend_id": "94",
      "difficulty": "Easy",
      "problem_slug": "binary-tree-inorder-traversal",
      "topics": [
        "Stack",
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values.\nExample 1:\nExample 2:\nExample 3:\nExample 4:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: root = [1,null,2,3]\nOutput: [1,3,2]\nExplanation:\n",
          "images": [
            "https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: root = [1,2,3,4,5,null,8,null,null,6,7,9]\nOutput: [4,2,6,5,7,1,3,9,8]\nExplanation:\n",
          "images": [
            "https://assets.leetcode.com/uploads/2024/08/29/tree_2.png"
          ]
        },
        {
          "example_num": 3,
          "example_text": "Input: root = []\nOutput: []",
          "images": []
        },
        {
          "example_num": 4,
          "example_text": "Input: root = [1]\nOutput: [1]",
          "images": []
        }
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [0, 100].",
        "-100 <= Node.val <= 100"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        \n    }\n};",
        "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        \n    }\n}",
        "python": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[int]\n        \"\"\"\n        ",
        "python3": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ",
        "c": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* inorderTraversal(struct TreeNode* root, int* returnSize) {\n    \n}",
        "csharp": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public IList<int> InorderTraversal(TreeNode root) {\n        \n    }\n}",
        "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function(root) {\n    \n};",
        "typescript": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction inorderTraversal(root: TreeNode | null): number[] {\n    \n};",
        "php": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer[]\n     */\n    function inorderTraversal($root) {\n        \n    }\n}",
        "swift": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\n        \n    }\n}",
        "kotlin": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun inorderTraversal(root: TreeNode?): List<Int> {\n        \n    }\n}",
        "dart": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  List<int> inorderTraversal(TreeNode? root) {\n    \n  }\n}",
        "golang": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc inorderTraversal(root *TreeNode) []int {\n    \n}",
        "ruby": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer[]}\ndef inorder_traversal(root)\n    \nend",
        "scala": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def inorderTraversal(root: TreeNode): List[Int] = {\n        \n    }\n}",
        "rust": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn inorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\n        \n    }\n}",
        "racket": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (inorder-traversal root)\n  (-> (or/c tree-node? #f) (listof exact-integer?))\n  )",
        "erlang": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec inorder_traversal(Root :: #tree_node{} | null) -> [integer()].\ninorder_traversal(Root) ->\n  .",
        "elixir": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec inorder_traversal(root :: TreeNode.t | nil) :: [integer]\n  def inorder_traversal(root) do\n    \n  end\nend"
      },
      "solution": "[TOC]\n\n## Solution\n\n---\n### Approach 1: Recursive Approach\n\nThe first method to solve this problem is using recursion. This is the classical method and is straightforward. We can define a helper function to implement recursion.**Complexity Analysis**\n\nTime complexity: $$O(n)$$\n\n  - The time complexity is $$O(n)$$ because the recursive function is $$T(n) = 2 \\cdot T(n/2)+1$$.\n\nSpace complexity: $$O(n)$$\n\n  - The worst case space required is $$O(n)$$, and in the average case it's $$O(\\log n)$$ where $$n$$ is number of nodes.---\n\n### Approach 2: Iterating method using Stack\n\nThe strategy is very similiar to the first method, the different is using stack.\n\nHere is an illustration:\n\n!?!../Documents/94_Binary.json:1000,563!?!**Complexity Analysis**\n\nTime complexity: $$O(n)$$\n\nSpace complexity: $$O(n)$$---\n\n### Approach 3: Morris Traversal\n\n\nIn this method, we have to use a new data structure - Threaded Binary Tree, and the strategy is as follows:\n\n\n>Step 1: Initialize current as root\n>\n>Step 2: While current is not NULL,\n>\n>     If current does not have left child\n>\n>         a. Add current’s value\n>\n>         b. Go to the right, i.e., current = current.right\n>\n>     Else\n>\n>         a. In current's left subtree, make current the right child of the rightmost node\n>\n>         b. Go to this left child, i.e., current = current.left\n\n\nFor example:\n```\n\n          1\n        /   \\\n       2     3\n      / \\   /\n     4   5 6\n\n```\nFirst, 1 is the root, so initialize 1 as current, 1 has left child which is 2, the current's left subtree is\n\n```\n         2\n        / \\\n       4   5\n```\n So in this subtree, the rightmost node is 5, then make the current(1) as the right child of 5. Set current = current.left (current = 2).\nThe tree now looks like:\n```\n         2\n        / \\\n       4   5\n            \\\n             1\n              \\\n               3\n              /\n             6\n```\nFor current 2, which has left child 4, we can continue with the same process as we did above\n```\n        4\n         \\\n          2\n           \\\n            5\n             \\\n              1\n               \\\n                3\n               /\n              6\n```\n then add 4 because it has no left child, then add 2, 5, 1, 3 one by one, for node 3 which has left child 6, do the same as above.\nFinally, the inorder traversal is [4,2,5,1,6,3].\n\nFor more details, please check\n[Threaded binary tree](https://en.wikipedia.org/wiki/Threaded_binary_tree) and\n[Explanation of Morris Method](https://stackoverflow.com/questions/5502916/explain-morris-inorder-tree-traversal-without-using-stacks-or-recursion)**Complexity Analysis**\n\nTime complexity: $$O(n)$$\n\n  - To prove that the time complexity is $$O(n)$$, the biggest problem lies in finding the time complexity of finding the predecessor nodes of all the nodes in the binary tree. Intuitively, the complexity is $$O(n \\log n)$$, because to find the predecessor node for a single node related to the height of the tree. But in fact, finding the predecessor nodes for all nodes only needs $$O(n)$$ time. Because a binary Tree with $$n$$ nodes has $$n-1$$ edges, the whole processing for each edges up to 2 times, one is to locate a node, and the other is to find the predecessor node. So the complexity is $$O(n)$$.\n\nSpace complexity: $$O(1)$$\n\n  - Extra space is only allocated for the ArrayList of size $$n$$, however the output does not count towards the space complexity."
    },
    {
      "title": "Unique Binary Search Trees II",
      "problem_id": "95",
      "frontend_id": "95",
      "difficulty": "Medium",
      "problem_slug": "unique-binary-search-trees-ii",
      "topics": [
        "Dynamic Programming",
        "Backtracking",
        "Tree",
        "Binary Search Tree",
        "Binary Tree"
      ],
      "description": "Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: n = 3\nOutput: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]",
          "images": [
            "https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: n = 1\nOutput: [[1]]",
          "images": [
            "https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg"
          ]
        }
      ],
      "constraints": [
        "1 <= n <= 8"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<TreeNode*> generateTrees(int n) {\n        \n    }\n};",
        "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<TreeNode> generateTrees(int n) {\n        \n    }\n}",
        "python": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def generateTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[Optional[TreeNode]]\n        \"\"\"\n        ",
        "python3": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\n        ",
        "c": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nstruct TreeNode** generateTrees(int n, int* returnSize) {\n    \n}",
        "csharp": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public IList<TreeNode> GenerateTrees(int n) {\n        \n    }\n}",
        "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number} n\n * @return {TreeNode[]}\n */\nvar generateTrees = function(n) {\n    \n};",
        "typescript": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction generateTrees(n: number): Array<TreeNode | null> {\n    \n};",
        "php": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param Integer $n\n     * @return TreeNode[]\n     */\n    function generateTrees($n) {\n        \n    }\n}",
        "swift": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func generateTrees(_ n: Int) -> [TreeNode?] {\n        \n    }\n}",
        "kotlin": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun generateTrees(n: Int): List<TreeNode?> {\n        \n    }\n}",
        "dart": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  List<TreeNode?> generateTrees(int n) {\n    \n  }\n}",
        "golang": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc generateTrees(n int) []*TreeNode {\n    \n}",
        "ruby": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {Integer} n\n# @return {TreeNode[]}\ndef generate_trees(n)\n    \nend",
        "scala": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def generateTrees(n: Int): List[TreeNode] = {\n        \n    }\n}",
        "rust": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn generate_trees(n: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {\n        \n    }\n}",
        "racket": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (generate-trees n)\n  (-> exact-integer? (listof (or/c tree-node? #f)))\n  )",
        "erlang": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec generate_trees(N :: integer()) -> [#tree_node{} | null].\ngenerate_trees(N) ->\n  .",
        "elixir": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec generate_trees(n :: integer) :: [TreeNode.t | nil]\n  def generate_trees(n) do\n    \n  end\nend"
      },
      "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nGiven an integer `n`, our task is to return all unique BSTs (binary search trees) that have exactly `n` nodes of unique values from `1` to `n`.\n\n---\n\n### Approach 1: Recursive Dynamic Programming\n\n#### Intuition\n\nIn each node of a binary search tree (BST), all values in the left subtree are smaller and all values in the right subtree are greater.\n\nTo find all the possible permutations of BSTs with `n` nodes, we can lock one node as the `root` node and split `n - 1` nodes between the left and right subtrees in all the possible ways. Let's say we place a node with value `i` as the root node and place `i - 1` nodes having values from `1` to `i - 1` in the left subtree. (If `i == 1`, the left child is null). Similarly, we place the remaining `n - i` nodes having values from `i + 1` to `n` in the right subtree. (If `i == n`, the right child is null).\n\nNow, we create a list of nodes called `leftSubTrees` for all the possible BSTs that could be the left subtree. Similarly, we create a list of nodes called `rightSubTrees` for all the BSTs that could be the right subtree. \n\n> In a BST, every subtree is also a BST.\n\nWe iterate over both the lists and for each node pair `l` in `leftSubTrees` and `r` in `rightSubTrees`, we create a new `root` node with value `i` and set the left and right child of `root` to `l` and `r` respectively to form all the BSTs with the root node as `i`.\n\nWe can iterate over the root's value from `i = 1` to `n` and repeat the process for each root value to get all the BSTs.\n\nYou may notice that the subproblem of finding the arrays `leftSubTrees` and `rightSubTrees` are similar to the original problem. We can implement this approach using recursion as we are breaking down a problem with `n` nodes to smaller, repetitive subproblems with `i - 1` and `n - i` nodes (for `i = 1` till `n`) to compute the answer for `n` nodes. We only need the range of node values as the parameters to create the BSTs with nodes having values in that range.\n\nWe implement a recursive function `allPossibleBST(start, end)` where `start` and `end` correspond to the range of node values that should be present in the BSTs created by this call. For a root node with value `i`, we will find all the left subtrees using `leftSubTrees = allPossibleBST(start, i - 1)` and also compute all the right subtrees using `rightSubTrees = allPossibleBST(i + 1, right)`. Finally, we iterate over all pairs between `leftSubTrees` and `rightSubTrees` and create a new root with value `i` for each pair.\n\nThe base case of this function is when `start > end`. We have no values in our range and thus we will return `null` (an empty tree).\n\nHere is a visual representation of the recursion tree with `3` nodes:\n\n![img](../Figures/95/95-1.png)\n\nSeveral subproblems, such as `allPossibleBST(1, 1)`, `allPossibleBST(3, 3)`, etc., are solved multiple times in the small partial recursion tree shown above. If we draw the entire recursion tree, we can see that there are many subproblems that are solved repeatedly.\n\nTo avoid this issue, we store the solution of the subproblem in a hashmap that stores the mapping from a range of nodes values to the list of root nodes of all possible BSTs that can be formed with the same number of nodes. When we encounter the same subproblem again, we simply refer to this map to get the required list of `TreeNode`. This is called **memoization**.\n\n#### Algorithm\n\n1. Create a hash map `memo` where `memo[(start, end)]` contains the list of root nodes of all possible BSTs with the range of node values from `start` to `end`.\n2. We implement a recursive function `allPossibleBST` which takes the starting range of node values `start`, ending range `end`, and `memo` as parameters. It returns a list of `TreeNode` corresponding to all the BSTs that can be formed with this range of node values. We call `allPossibleBST(1, n, memo)` and perform the following:\n    - We declare a list of `TreeNode` called `res` to store the list of root nodes of all possible BSTs.\n    - If `start > end`, we push `null` to `res` and return it.\n    - If we already have solved this subproblem, i.e., `memo` contains the pair `(start, end)`, we return `memo[(start, end)]`.\n    - Select the root node value from `i = start` to `end` incrementing `i` by `1` after each iteration. We recursively call `leftSubtrees = llPossibleBST(start, i - 1, memo)` and `rightSubTrees = allPossibleBST(i + 1, end, memo)`. We iterate over all pairs between `leftSubtrees` and `rightSubTrees` and create a new root with value `i` for each pair. We push `root` of the new formed BST into `res`.\n    - Set `memo[(start, end)] = res` and return `res`.\n\n#### Implementation#### Complexity Analysis\n\nNote, the time and space complexity of this problem is difficult to derive. In an interview, you should do your best to find an upper bound. The level of analysis here would not be expected in an interview.\n\nThe number of unique BSTs that can be formed with `n` nodes is $G(n)$ where $G(n)$ is the $n^{th}$ [Catalan number](https://en.wikipedia.org/wiki/Catalan_number). $G(n) = O(\\dfrac{4^{n}}{n^{1.5}})$.\n\n* Time complexity: $O(\\dfrac{4^n}{\\sqrt{n}})$.\n    - There are $G(n) = \\dfrac{4^n}{n^{1.5}}$ BSTs in our answer. Each of these BSTs has $n$ nodes, so it cost us $O(n)$ to build each one. This gives us a time complexity of $O(n \\cdot G(n)) = O(\\dfrac{4^n}{\\sqrt{n}})$.\n\n* Space complexity: $O(\\sum_{k=1}^{n}{[(n - k + 1) \\cdot  \\dfrac{4^k}{\\sqrt{k}}]})$.\n\n    We use some space for the recursion call stack, but the majority of the space used by the algorithm is storing the lists of BSTs in `memo`. Let's analyze how many nodes are stored in `memo`.\n\n    The number of nodes in a range `start, end` is `end - start + 1`. Let $k = \\text{end} - \\text{start} + 1$ represent this formula.\n\n    There are $n$ states `start, end` with one node, that is $k = 1$.\n\n    There are $n - 1$ states `start, end` with two nodes, that is $k = 2$.\n\n    There are $n - 2$ states `start, end` with three nodes, that is $k = 3$.\n\n    This continues until there is only one state with $n$ nodes (the original input). In general, a value of $k$ has $n - k + 1$ states.\n\n    For a given state with value $k$, there are $G(k) = \\dfrac{4^k}{k^{1.5}}$ BSTs. Each of these BSTs has $k$ nodes, and thus takes up $k \\cdot G(k) = \\dfrac{4^k}{\\sqrt{k}}$ space in `memo`.\n\n    A given value $k$ has $n - k + 1$ states and thus takes up $(n - k + 1) \\cdot  \\dfrac{4^k}{\\sqrt{k}}$ space. In our algorithm, $k$ ranges from $1$ to $n$.\n\n    The space complexity is the summation for all values of $k$:\n\n    $\\Large{\\sum_{k=1}^{n}{[(n - k + 1) \\cdot  \\dfrac{4^k}{\\sqrt{k}}]}}$\n\n    This is a difficult sum to compute and involves higher-level mathematics. Using a program like WolframAlpha, we find that the sum is equal to:\n\n    $4^{1 + n} \\cdot \\Phi(4, -0.5, 1 + n) - 4^{1 + n} \\cdot (1 + n) \\cdot \\Phi(4, 0.5, 1 + n) - \\text{Li}_{-0.5}(4) + \\text{Li}_{0.5}(4) + n \\cdot \\text{Li}_{0.5}(4)$\n\n    Where $\\Phi$ is the [Lerch transcendent](https://en.wikipedia.org/wiki/Lerch_zeta_function) and $\\text{Li}_n(x)$ is the [polylogarithm function](https://en.wikipedia.org/wiki/Polylogarithm). Needless to say, computing this sum by hand is not necessary in an interview. Even reaching the summation expression would likely impress any interviewer.\n\n---\n\n### Approach 2: Iterative Dynamic Programming\n\n#### Intuition\n\nWe used memoization in the preceding approach to store the answers to subproblems in order to solve a larger problem. We can also use a bottom-up approach to solve such problems without using recursion. We build answers to subproblems iteratively first, then use them to build answers to larger problems.\n\nWe create a 3D list `dp[n + 1][n + 1]` where `dp[i][j]` will store a list of all BSTs that have node values ranging from `i` to `j`. Note that `dp[i][j] = allPossibleBST(i, j)` from the previous approach.\n\nWhen `i = j`, the range contains only one node with value `i`. We push a single node with value `i` in the list `dp[i][i]` for all the values of `i` from `1` to `n`. This acts as the base case of our solution while we move in bottom to top manner.\n\nWe form the answer with a smaller number of nodes having consecutive node values and move on to form answers for a bigger number of nodes. We run an outer loop from `numberOfNodes = 2` to `numberOfNodes = n` incrementing `numberOfNodes` by `1` after each iteration. This loop controls the total number of nodes under consideration.\n\nWe further need to choose a node value we start with. Let's call it `start`. As we have `numberOfNodes` nodes under consideration with consecutive values, the maximum node value in such a BST would be `end = start + numberOfNodes - 1`. We will move `start` from `1` to `n - numberOfNodes + 1`.\n\nNow we have the `start` value and the `end` value, we can implement the same logic that we did in the `allPossibleBST` function from the previous approach. Lock a value `i`, find all left and right subtrees, and then iterate over each `left, right` pair and create a new root with value `i` for each pair.\n\nAs we move from bottom to top, we will have a list of all the root nodes for all BSTs for every range of node values with lesser nodes.\n\nLocking a value `i` as the root node, we can find all left subtrees in `dp[start][i - 1]` and all right subtrees in `dp[i + 1][end]`. If `i == start`, the left subtree would be empty. Similarly, if `i == end`, the right subtree would be empty. We can handle these cases separately.\n\nWe run an outer loop from `numberOfNodes = 2` to `n`. We run an inner loop that selects the starting node value. It runs from `start = 1` to `n - numberOfNodes + 1`. We define `end = start + numberOfNodes - 1`. We run a third nested loop that selects the root of the BSTs under consideration. It runs from `i = start` to `end`.\n\nWe then iterate over the both the lists of left and right subtrees. For each root node `l` of the left subtree and `r` of the right subtree, we create a new `root` node with value `i` and set the left and right child to `l` and `r` respectively to form all the BSTs with root node as `i`. We also push each BST into `dp[start][end]` to be used later to build answer for other `dp` states with larger number of nodes.\n\n#### Algorithm\n\n1. Create a 3D list `dp[n + 1][n + 1]` where `dp[i][j]` will store a list of root nodes for all possible BSTs using `j - i + 1` nodes with values from `i` to `j` nodes.\n2. We initialize each list `dp[i][i]` to a `TreeNode` having value `i` for `i = 0` to `n`.\n3. Iterate from `numberOfNodes = 2` till `numberOfNodes = n` incrementing `numberOfNodes` by `1` after each iteration. We start an inner loop from `start = 1` to `n - numberOfNodes + 1` incrementing `start` by `1`. We create an integer variable `end = start + numberOfNodes - 1` which stores the highest node value of the BSTs that will be formed. We run another loop from `i = start` to `end` to use all the permutations as the root node value. We perform the following in this loop:\n    - We create a list of `TreeNode` called `leftSubtrees` which will store all the BSTs that can be formed with node values from `start` to `i - 1`. If `i == start`, we just add `null` to `leftSubtrees`, else `leftSubtrees == dp[start][i - 1]`.\n    - Similarly, we create a list of `TreeNode` called `rightSubtrees` which will store all the BSTs that can be formed with node values from `i + 1` to `end`. If `i == end`, we just add `null` to `rightSubtrees`, else `rightSubtrees == dp[i + 1][end]`.\n    - We form a new BST by creating a new node which acts as a root node with value `i`. For each element `left` in `leftSubtrees` and `right` in `rightSubtrees`, we set `root.left = left` and `root.right = right`. Finally, we add `root` to `dp[start][end]`.\n4. Return `dp[1][n]`.\n\n#### Implementation#### Complexity Analysis\n\n* Time complexity: $O(\\dfrac{4^n}{\\sqrt{n}})$.\n    - The time complexity of this approach will be similar to the **time complexity** of the first approach because we are iterating over the same `dp` states in bottom-up manner as compared to the previous approach where we used top-down approach with memoization.\n\n* Space complexity: $O(\\sum_{k=1}^{n}{[(n - k + 1) \\cdot  \\dfrac{4^k}{\\sqrt{k}}]})$.\n    - The space complexity would also be the number of BSTs stored in the `dp` list which is equal to the number of BSTs stored in `memo` in the worst-case. Hence, we have the same space complexity as the first approach.\n\n---\n\n### Approach 3: Dynamic Programming with Space Optimization\n\n#### Intuition\n\nWe used a 3D list where we used `dp[start][end]` to store all the BSTs having `end - start + 1` nodes with range from `start` to `end`. Let's think if we can reduce the 3D `dp` list to a 2D list.\n\nIf we compare all the BSTs that can be created from a set of consecutive values from `start` to `end` to those that can be created with the same number of nodes from a set of values starting at `1` and ending at `end - start + 1`, we will find that **the structure of all the BSTs created with the above two ranges would be identical**. The only difference is an offset of `start - 1` in the node values.\n\nHere's a visual representation of BSTs with 3 nodes from range `[1, 3]` and all BSTs with range `[4, 6]`:\n\n![img](../Figures/95/95-2.png)\n\nWe can see the structure of all the BSTs created with the above two ranges are identical.\n\nSo, we can just store the BSTs for all the ranges starting from `1` and add the offset to convert them to required ranges.\n\nWe create a 2D list `dp[n + 1]` where `dp[i]` will store a list of all BSTs with `i` nodes having values from `1` to `i`. `dp[n]` would be the answer to the problem. Similar to the above approach, we will move in bottom to top manner.\n\nWe push a `null` node (empty tree) to `dp[0]` which acts as the base case.\n\nTo get the list of root nodes for all possible BSTs with `numberOfNodes` nodes, we would split the `numberOfNodes` nodes with `i - 1` nodes with values `1` to `i - 1` in the left subtree, a root node with value `i` and the remaining `numberOfNodes - i` nodes with values `i + 1` to `numberOfNodes` in the right subtree where `1 <= i <= numberOfNodes`. Note that we do not need the starting of the range here, unlike the previous approach. It is always `1`. \n\nAs we are executing in bottom-up manner and figuring out the answer for `numberOfNodes` nodes, we will already have the list of root nodes for all BSTs with `i - 1` and `numberOfNodes - i` nodes (for all values of `i = 1` to `numberOfNodes`).\n\nHowever, you may realize that `dp[i - 1]` will give all the BSTs having values from `1` to `i - 1` which is exactly what we want but `dp[numberOfNodes - i]` will give all the BSTs having values from `1` to `numberOfNodes - i` which isn't what we want. We want the right subtree to have `numberOfNodes - i` nodes but the range of nodes should be from `i + 1` to `numberOfNodes`. If we add the offset `(i + 1) - 1 = i` to all the nodes, it would solve this as we would now have trees with `numberOfNodes - i` nodes from values `i + 1` to `numberOfNodes`. Let us form the BSTs now.\n\nSimilar to the previous approach, we create a new instance of `TreeNode` called `root` with the value `i`. We set the left child of `root` to an element in `dp[i - 1]`.\n\nNow, let's set the right child of `root`. We know every element in `dp[numberOfNodes - i]` is a root node that stores a BST with `numberOfNodes - 1` nodes having values from `1` to `numberOfNodes - i`. To set the right child of `root`, we create a new tree exactly similar to the tree stored by an element of `dp[numberOfNodes - i]` but increment all the node values of the new tree by `i`. We then set the right child of `root` to this newer tree.\n\nThe required tree with `i` offset can be created by using a recursive function `clone` in which we pass a `TreeNode node` which corresponds to an element in `dp[numberOfNodes - i]` and an integer `offset`. We create a new `TreeNode clonedNode` with value `node.val + offset`. We then recursively set the left and the right child of `clonedNode` by performing `clonedNode.left = clone(node.left, offset)` and `clonedNode.right = clone(node.right, offset)`. Finally, return `clonedNode`.\n\nIt is important to note that we are creating new trees to set the right child of `root` to preserve the original trees as it might be used directly (as `dp[i - 1]`) in some other iteration of `i` and `numberOfNodes`.\n\n#### Algorithm\n\n1. Create a list `dp[n + 1]` where `dp[i]` will store a list of root nodes for all possible BSTs using `i` nodes. We initialize each list `dp[i]` to an empty list for `i = 0` to `n`.\n2. We push a `null` node (empty tree) into `dp[0]` because with `n = 0` we can't have any BST. This forms the base case.\n3. Iterate from `numberOfNodes = 1` till `numberOfNodes = n` incrementing `numberOfNodes` by `1` after each iteration. We start an inner loop from `i = 1` to `numberOfNodes` incrementing `i` by `1`. We perform the following in this loop:\n    - Create a variable `j = numberOfNodes - i - 1`. It presents the number of nodes in the right subtree under consideration.\n    - We can form a new BST by creating a new node which acts as a root node with value `i`. We assign its left child to any element in `dp[i]` and right child to a new tree where tree is similar to an element in `dp[j]` but all node values are incremented by `i`. As a result, we need two loops to iterate through the lists `dp[i]` and `dp[j]`. We create a new `root` node with value `i`. For each element `left` in `dp[i]` and `right` in `dp[j]`, we set `root.left = left` and `root.right = clone(right, i)`. Finally, we add `root` to `dp[numberOfNodes]`.\n4. Return `dp[n]`.\n\n#### Implementation#### Complexity Analysis\n\n* Time complexity: $O(\\dfrac{4^n}{\\sqrt{n}})$.\n    - In this approach we are not storing all the BSTs with all the ranges. We are just storing BSTs starting from range `1`. However, we are creating all the BSTs for all the ranges from `[start, end]` (for `1 <= start, end  <= 1`) using the `clone` method by iterating over the BSTs starting with range `1`.\n    - As a result, the time complexity should be similar to the previous approach as we are generating the same number of BSTs.\n\n* Space complexity: $O(\\sum_{k=1}^{n}\\dfrac{4^k}{{\\sqrt{k}}})$.\n    - For any state `dp[k]`, we are storing all the BSTs that can be formed with $k$ nodes. We know there are $G(k)$ BSTs that can be formed with $k$ nodes. As we have $1$ to $n$ states, the total space consumed would be $O(\\sum_{k=1}^{n} k \\cdot G(k))$ = $O(\\sum_{k=1}^{n}\\dfrac{4^k}{{\\sqrt{k}}})$."
    },
    {
      "title": "Unique Binary Search Trees",
      "problem_id": "96",
      "frontend_id": "96",
      "difficulty": "Medium",
      "problem_slug": "unique-binary-search-trees",
      "topics": [
        "Math",
        "Dynamic Programming",
        "Tree",
        "Binary Search Tree",
        "Binary Tree"
      ],
      "description": "Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: n = 3\nOutput: 5",
          "images": [
            "https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: n = 1\nOutput: 1",
          "images": [
            "https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg"
          ]
        }
      ],
      "constraints": [
        "1 <= n <= 19"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    int numTrees(int n) {\n        \n    }\n};",
        "java": "class Solution {\n    public int numTrees(int n) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def numTrees(self, n: int) -> int:\n        ",
        "c": "int numTrees(int n) {\n    \n}",
        "csharp": "public class Solution {\n    public int NumTrees(int n) {\n        \n    }\n}",
        "javascript": "/**\n * @param {number} n\n * @return {number}\n */\nvar numTrees = function(n) {\n    \n};",
        "typescript": "function numTrees(n: number): number {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function numTrees($n) {\n        \n    }\n}",
        "swift": "class Solution {\n    func numTrees(_ n: Int) -> Int {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun numTrees(n: Int): Int {\n        \n    }\n}",
        "dart": "class Solution {\n  int numTrees(int n) {\n    \n  }\n}",
        "golang": "func numTrees(n int) int {\n    \n}",
        "ruby": "# @param {Integer} n\n# @return {Integer}\ndef num_trees(n)\n    \nend",
        "scala": "object Solution {\n    def numTrees(n: Int): Int = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn num_trees(n: i32) -> i32 {\n        \n    }\n}",
        "racket": "(define/contract (num-trees n)\n  (-> exact-integer? exact-integer?)\n  )",
        "erlang": "-spec num_trees(N :: integer()) -> integer().\nnum_trees(N) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec num_trees(n :: integer) :: integer\n  def num_trees(n) do\n    \n  end\nend"
      }
    },
    {
      "title": "Interleaving String",
      "problem_id": "97",
      "frontend_id": "97",
      "difficulty": "Medium",
      "problem_slug": "interleaving-string",
      "topics": [
        "String",
        "Dynamic Programming"
      ],
      "description": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.\nAn interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:\nNote: a + b is the concatenation of strings a and b.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you solve it using only O(s2.length) additional memory space?",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\nOutput: true\nExplanation: One way to obtain s3 is:\nSplit s1 into s1 = \"aa\" + \"bc\" + \"c\", and s2 into s2 = \"dbbc\" + \"a\".\nInterleaving the two splits, we get \"aa\" + \"dbbc\" + \"bc\" + \"a\" + \"c\" = \"aadbbcbcac\".\nSince s3 can be obtained by interleaving s1 and s2, we return true.",
          "images": [
            "https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\nOutput: false\nExplanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.",
          "images": [
            "https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg"
          ]
        },
        {
          "example_num": 3,
          "example_text": "Input: s1 = \"\", s2 = \"\", s3 = \"\"\nOutput: true",
          "images": [
            "https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg"
          ]
        }
      ],
      "constraints": [
        "0 <= s1.length, s2.length <= 100",
        "0 <= s3.length <= 200",
        "s1, s2, and s3 consist of lowercase English letters."
      ],
      "follow_ups": [
        "Could you solve it using only O(s2.length) additional memory space?"
      ],
      "hints": [],
      "code_snippets": {
        "cpp": "class Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        \n    }\n};",
        "java": "class Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        ",
        "python3": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        ",
        "c": "bool isInterleave(char* s1, char* s2, char* s3) {\n    \n}",
        "csharp": "public class Solution {\n    public bool IsInterleave(string s1, string s2, string s3) {\n        \n    }\n}",
        "javascript": "/**\n * @param {string} s1\n * @param {string} s2\n * @param {string} s3\n * @return {boolean}\n */\nvar isInterleave = function(s1, s2, s3) {\n    \n};",
        "typescript": "function isInterleave(s1: string, s2: string, s3: string): boolean {\n    \n};",
        "php": "class Solution {\n\n    /**\n     * @param String $s1\n     * @param String $s2\n     * @param String $s3\n     * @return Boolean\n     */\n    function isInterleave($s1, $s2, $s3) {\n        \n    }\n}",
        "swift": "class Solution {\n    func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool {\n        \n    }\n}",
        "kotlin": "class Solution {\n    fun isInterleave(s1: String, s2: String, s3: String): Boolean {\n        \n    }\n}",
        "dart": "class Solution {\n  bool isInterleave(String s1, String s2, String s3) {\n    \n  }\n}",
        "golang": "func isInterleave(s1 string, s2 string, s3 string) bool {\n    \n}",
        "ruby": "# @param {String} s1\n# @param {String} s2\n# @param {String} s3\n# @return {Boolean}\ndef is_interleave(s1, s2, s3)\n    \nend",
        "scala": "object Solution {\n    def isInterleave(s1: String, s2: String, s3: String): Boolean = {\n        \n    }\n}",
        "rust": "impl Solution {\n    pub fn is_interleave(s1: String, s2: String, s3: String) -> bool {\n        \n    }\n}",
        "racket": "(define/contract (is-interleave s1 s2 s3)\n  (-> string? string? string? boolean?)\n  )",
        "erlang": "-spec is_interleave(S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary(), S3 :: unicode:unicode_binary()) -> boolean().\nis_interleave(S1, S2, S3) ->\n  .",
        "elixir": "defmodule Solution do\n  @spec is_interleave(s1 :: String.t, s2 :: String.t, s3 :: String.t) :: boolean\n  def is_interleave(s1, s2, s3) do\n    \n  end\nend"
      }
    },
    {
      "title": "Validate Binary Search Tree",
      "problem_id": "98",
      "frontend_id": "98",
      "difficulty": "Medium",
      "problem_slug": "validate-binary-search-tree",
      "topics": [
        "Tree",
        "Depth-First Search",
        "Binary Search Tree",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: root = [2,1,3]\nOutput: true",
          "images": [
            "https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.",
          "images": [
            "https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg"
          ]
        }
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [1, 104].",
        "-231 <= Node.val <= 231 - 1"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        \n    }\n};",
        "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        \n    }\n}",
        "python": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: bool\n        \"\"\"\n        ",
        "python3": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        ",
        "c": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nbool isValidBST(struct TreeNode* root) {\n    \n}",
        "csharp": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsValidBST(TreeNode root) {\n        \n    }\n}",
        "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    \n};",
        "typescript": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction isValidBST(root: TreeNode | null): boolean {\n    \n};",
        "php": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Boolean\n     */\n    function isValidBST($root) {\n        \n    }\n}",
        "swift": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func isValidBST(_ root: TreeNode?) -> Bool {\n        \n    }\n}",
        "kotlin": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun isValidBST(root: TreeNode?): Boolean {\n        \n    }\n}",
        "dart": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  bool isValidBST(TreeNode? root) {\n    \n  }\n}",
        "golang": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isValidBST(root *TreeNode) bool {\n    \n}",
        "ruby": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Boolean}\ndef is_valid_bst(root)\n    \nend",
        "scala": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def isValidBST(root: TreeNode): Boolean = {\n        \n    }\n}",
        "rust": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn is_valid_bst(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        \n    }\n}",
        "racket": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (is-valid-bst root)\n  (-> (or/c tree-node? #f) boolean?)\n  )",
        "erlang": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec is_valid_bst(Root :: #tree_node{} | null) -> boolean().\nis_valid_bst(Root) ->\n  .",
        "elixir": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec is_valid_bst(root :: TreeNode.t | nil) :: boolean\n  def is_valid_bst(root) do\n    \n  end\nend"
      }
    },
    {
      "title": "Recover Binary Search Tree",
      "problem_id": "99",
      "frontend_id": "99",
      "difficulty": "Medium",
      "problem_slug": "recover-binary-search-tree",
      "topics": [
        "Tree",
        "Depth-First Search",
        "Binary Search Tree",
        "Binary Tree"
      ],
      "description": "You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.\nExample 1:\nExample 2:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: root = [1,3,null,null,2]\nOutput: [3,1,null,null,2]\nExplanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.",
          "images": [
            "https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: root = [3,1,4,null,null,2]\nOutput: [2,1,4,null,null,3]\nExplanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.",
          "images": [
            "https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg"
          ]
        }
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [2, 1000].",
        "-231 <= Node.val <= 231 - 1"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void recoverTree(TreeNode* root) {\n        \n    }\n};",
        "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public void recoverTree(TreeNode root) {\n        \n    }\n}",
        "python": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        ",
        "python3": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        ",
        "c": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nvoid recoverTree(struct TreeNode* root) {\n    \n}",
        "csharp": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public void RecoverTree(TreeNode root) {\n        \n    }\n}",
        "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {void} Do not return anything, modify root in-place instead.\n */\nvar recoverTree = function(root) {\n    \n};",
        "typescript": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n Do not return anything, modify root in-place instead.\n */\nfunction recoverTree(root: TreeNode | null): void {\n    \n};",
        "php": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return NULL\n     */\n    function recoverTree($root) {\n        \n    }\n}",
        "swift": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func recoverTree(_ root: TreeNode?) {\n        \n    }\n}",
        "kotlin": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun recoverTree(root: TreeNode?): Unit {\n        \n    }\n}",
        "dart": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  void recoverTree(TreeNode? root) {\n    \n  }\n}",
        "golang": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc recoverTree(root *TreeNode)  {\n    \n}",
        "ruby": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Void} Do not return anything, modify root in-place instead.\ndef recover_tree(root)\n    \nend",
        "scala": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def recoverTree(root: TreeNode): Unit = {\n        \n    }\n}",
        "rust": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn recover_tree(root: &mut Option<Rc<RefCell<TreeNode>>>) {\n        \n    }\n}",
        "racket": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (recover-tree root)\n  (-> (or/c tree-node? #f) void?)\n  )"
      }
    },
    {
      "title": "Same Tree",
      "problem_id": "100",
      "frontend_id": "100",
      "difficulty": "Easy",
      "problem_slug": "same-tree",
      "topics": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
      "examples": [
        {
          "example_num": 1,
          "example_text": "Input: p = [1,2,3], q = [1,2,3]\nOutput: true",
          "images": [
            "https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg"
          ]
        },
        {
          "example_num": 2,
          "example_text": "Input: p = [1,2], q = [1,null,2]\nOutput: false",
          "images": [
            "https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg"
          ]
        },
        {
          "example_num": 3,
          "example_text": "Input: p = [1,2,1], q = [1,1,2]\nOutput: false",
          "images": [
            "https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg"
          ]
        }
      ],
      "constraints": [
        "The number of nodes in both trees is in the range [0, 100].",
        "-104 <= Node.val <= 104"
      ],
      "follow_ups": [],
      "hints": [],
      "code_snippets": {
        "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        \n    }\n};",
        "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        \n    }\n}",
        "python": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: Optional[TreeNode]\n        :type q: Optional[TreeNode]\n        :rtype: bool\n        \"\"\"\n        ",
        "python3": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        ",
        "c": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nbool isSameTree(struct TreeNode* p, struct TreeNode* q) {\n    \n}",
        "csharp": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsSameTree(TreeNode p, TreeNode q) {\n        \n    }\n}",
        "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    \n};",
        "typescript": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n    \n};",
        "php": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $p\n     * @param TreeNode $q\n     * @return Boolean\n     */\n    function isSameTree($p, $q) {\n        \n    }\n}",
        "swift": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\n        \n    }\n}",
        "kotlin": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\n        \n    }\n}",
        "dart": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  bool isSameTree(TreeNode? p, TreeNode? q) {\n    \n  }\n}",
        "golang": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\n    \n}",
        "ruby": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} p\n# @param {TreeNode} q\n# @return {Boolean}\ndef is_same_tree(p, q)\n    \nend",
        "scala": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {\n        \n    }\n}",
        "rust": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        \n    }\n}",
        "racket": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (is-same-tree p q)\n  (-> (or/c tree-node? #f) (or/c tree-node? #f) boolean?)\n  )",
        "erlang": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec is_same_tree(P :: #tree_node{} | null, Q :: #tree_node{} | null) -> boolean().\nis_same_tree(P, Q) ->\n  .",
        "elixir": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec is_same_tree(p :: TreeNode.t | nil, q :: TreeNode.t | nil) :: boolean\n  def is_same_tree(p, q) do\n    \n  end\nend"
      }
    }
  ]
}