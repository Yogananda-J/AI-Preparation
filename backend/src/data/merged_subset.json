[
  {
    "numId": "1",
    "title": "Two Sum",
    "difficulty": "Easy",
    "category": "Array",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1].",
        "images": []
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1,2]",
        "explanation": "",
        "images": []
      },
      {
        "input": "nums = [3,3], target = 6",
        "output": "[0,1]",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "2 <= nums.length <= 104",
      "-109 <= nums[i] <= 109",
      "-109 <= target <= 109",
      "Only one valid answer exists."
    ],
    "frontendId": "1",
    "problemId": "1",
    "slug": "two-sum",
    "topics": [
      "Array",
      "Hash Table"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* twoSum(int* nums, int numsSize, int target, int* returnSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int[] TwoSum(int[] nums, int target) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function twoSum(nums: number[], target: number): number[] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer[]\n     */\n    function twoSum($nums, $target) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun twoSum(nums: IntArray, target: Int): IntArray {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<int> twoSum(List<int> nums, int target) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func twoSum(nums []int, target int) []int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer[]}\ndef two_sum(nums, target)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def twoSum(nums: Array[Int], target: Int): Array[Int] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (two-sum nums target)\n  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec two_sum(Nums :: [integer()], Target :: integer()) -> [integer()].\ntwo_sum(Nums, Target) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec two_sum(nums :: [integer], target :: integer) :: [integer]\n  def two_sum(nums, target) do\n    \n  end\nend"
      }
    },
    "hints": [
      "A really brute force way would be to search for all possible pairs of numbers but that would be too slow. Again, it's best to try out brute force solutions for just for completeness. It is from these brute force solutions that you can come up with optimizations.",
      "So, if we fix one of the numbers, say <code>x</code>, we have to scan the entire array to find the next number <code>y</code> which is <code>value - x</code> where value is the input parameter. Can we change our array somehow so that this search becomes faster?",
      "The second train of thought is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"
    ],
    "acceptance": 0,
    "points": 100
  },
  {
    "numId": "2",
    "title": "Add Two Numbers",
    "difficulty": "Medium",
    "category": "Linked List",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "l1 = [2,4,3], l2 = [5,6,4]",
        "output": "[7,0,8]",
        "explanation": "342 + 465 = 807.",
        "images": [
          "https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg"
        ]
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg"
        ]
      },
      {
        "input": "l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]",
        "output": "[8,9,9,9,0,0,0,1]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= Node.val <= 9",
      "It is guaranteed that the list represents a number that does not have leading zeros."
    ],
    "frontendId": "2",
    "problemId": "2",
    "slug": "add-two-numbers",
    "topics": [
      "Linked List",
      "Math",
      "Recursion"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: Optional[ListNode]\n        :type l2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function(l1, l2) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $l1\n     * @param ListNode $l2\n     * @return ListNode\n     */\n    function addTwoNumbers($l1, $l2) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun addTwoNumbers(l1: ListNode?, l2: ListNode?): ListNode? {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? addTwoNumbers(ListNode? l1, ListNode? l2) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} l1\n# @param {ListNode} l2\n# @return {ListNode}\ndef add_two_numbers(l1, l2)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn add_two_numbers(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (add-two-numbers l1 l2)\n  (-> (or/c list-node? #f) (or/c list-node? #f) (or/c list-node? #f))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec add_two_numbers(L1 :: #list_node{} | null, L2 :: #list_node{} | null) -> #list_node{} | null.\nadd_two_numbers(L1, L2) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec add_two_numbers(l1 :: ListNode.t | nil, l2 :: ListNode.t | nil) :: ListNode.t | nil\n  def add_two_numbers(l1, l2) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "3",
    "title": "Longest Substring Without Repeating Characters",
    "difficulty": "Medium",
    "category": "Hash Table",
    "description": "Given a string s, find the length of the longest substring without duplicate characters.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The answer is \"abc\", with the length of 3.",
        "images": []
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The answer is \"b\", with the length of 1.",
        "images": []
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "0 <= s.length <= 5 * 104",
      "s consists of English letters, digits, symbols and spaces."
    ],
    "frontendId": "3",
    "problemId": "3",
    "slug": "longest-substring-without-repeating-characters",
    "topics": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int lengthOfLongestSubstring(char* s) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int LengthOfLongestSubstring(string s) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function lengthOfLongestSubstring(s: string): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function lengthOfLongestSubstring($s) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func lengthOfLongestSubstring(_ s: String) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun lengthOfLongestSubstring(s: String): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int lengthOfLongestSubstring(String s) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func lengthOfLongestSubstring(s string) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} s\n# @return {Integer}\ndef length_of_longest_substring(s)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def lengthOfLongestSubstring(s: String): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn length_of_longest_substring(s: String) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (length-of-longest-substring s)\n  (-> string? exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec length_of_longest_substring(S :: unicode:unicode_binary()) -> integer().\nlength_of_longest_substring(S) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec length_of_longest_substring(s :: String.t) :: integer\n  def length_of_longest_substring(s) do\n    \n  end\nend"
      }
    },
    "hints": [
      "Generate all possible substrings & check for each substring if it's valid and keep updating maxLen accordingly."
    ],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "4",
    "title": "Median of Two Sorted Arrays",
    "difficulty": "Hard",
    "category": "Array",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "nums1 = [1,3], nums2 = [2]",
        "output": "2.00000",
        "explanation": "merged array = [1,2,3] and median is 2.",
        "images": []
      },
      {
        "input": "nums1 = [1,2], nums2 = [3,4]",
        "output": "2.50000",
        "explanation": "merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "nums1.length == m",
      "nums2.length == n",
      "0 <= m <= 1000",
      "0 <= n <= 1000",
      "1 <= m + n <= 2000",
      "-106 <= nums1[i], nums2[i] <= 106"
    ],
    "frontendId": "4",
    "problemId": "4",
    "slug": "median-of-two-sorted-arrays",
    "topics": [
      "Array",
      "Binary Search",
      "Divide and Conquer"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        "
      },
      "c": {
        "name": "c",
        "code": "double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar findMedianSortedArrays = function(nums1, nums2) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function findMedianSortedArrays(nums1: number[], nums2: number[]): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @return Float\n     */\n    function findMedianSortedArrays($nums1, $nums2) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  double findMedianSortedArrays(List<int> nums1, List<int> nums2) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @return {Float}\ndef find_median_sorted_arrays(nums1, nums2)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def findMedianSortedArrays(nums1: Array[Int], nums2: Array[Int]): Double = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (find-median-sorted-arrays nums1 nums2)\n  (-> (listof exact-integer?) (listof exact-integer?) flonum?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec find_median_sorted_arrays(Nums1 :: [integer()], Nums2 :: [integer()]) -> float().\nfind_median_sorted_arrays(Nums1, Nums2) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec find_median_sorted_arrays(nums1 :: [integer], nums2 :: [integer]) :: float\n  def find_median_sorted_arrays(nums1, nums2) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 260
  },
  {
    "numId": "5",
    "title": "Longest Palindromic Substring",
    "difficulty": "Medium",
    "category": "Two Pointers",
    "description": "Given a string s, return the longest palindromic substring in s.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "s = \"babad\"",
        "output": "\"bab\"",
        "explanation": "\"aba\" is also a valid answer.",
        "images": []
      },
      {
        "input": "s = \"cbbd\"",
        "output": "\"bb\"",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= s.length <= 1000",
      "s consist of only digits and English letters."
    ],
    "frontendId": "5",
    "problemId": "5",
    "slug": "longest-palindromic-substring",
    "topics": [
      "Two Pointers",
      "String",
      "Dynamic Programming"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public String longestPalindrome(String s) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        "
      },
      "c": {
        "name": "c",
        "code": "char* longestPalindrome(char* s) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public string LongestPalindrome(string s) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function(s) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function longestPalindrome(s: string): string {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @return String\n     */\n    function longestPalindrome($s) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func longestPalindrome(_ s: String) -> String {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun longestPalindrome(s: String): String {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  String longestPalindrome(String s) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func longestPalindrome(s string) string {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} s\n# @return {String}\ndef longest_palindrome(s)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def longestPalindrome(s: String): String = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn longest_palindrome(s: String) -> String {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (longest-palindrome s)\n  (-> string? string?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec longest_palindrome(S :: unicode:unicode_binary()) -> unicode:unicode_binary().\nlongest_palindrome(S) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec longest_palindrome(s :: String.t) :: String.t\n  def longest_palindrome(s) do\n    \n  end\nend"
      }
    },
    "hints": [
      "How can we reuse a previously computed palindrome to compute a larger palindrome?",
      "If “aba” is a palindrome, is “xabax” a palindrome? Similarly is “xabay” a palindrome?",
      "Complexity based hint:</br>\r\nIf we use brute-force and check whether for every start and end position a substring is a palindrome we have O(n^2) start - end pairs and O(n) palindromic checks. Can we reduce the time for palindromic checks to O(1) by reusing some previous computation."
    ],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "6",
    "title": "Zigzag Conversion",
    "difficulty": "Medium",
    "category": "String",
    "description": "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\nWrite the code that will take a string and make this conversion given a number of rows:\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "s = \"PAYPALISHIRING\", numRows = 3",
        "output": "\"PAHNAPLSIIGYIR\"",
        "explanation": "",
        "images": []
      },
      {
        "input": "s = \"PAYPALISHIRING\", numRows = 4",
        "output": "\"PINALSIGYAHRPI\"",
        "explanation": "P     I    N\nA   L S  I G\nY A   H R\nP     I",
        "images": []
      },
      {
        "input": "s = \"A\", numRows = 1",
        "output": "\"A\"",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of English letters (lower-case and upper-case), ',' and '.'.",
      "1 <= numRows <= 1000"
    ],
    "frontendId": "6",
    "problemId": "6",
    "slug": "zigzag-conversion",
    "topics": [
      "String"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    string convert(string s, int numRows) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public String convert(String s, int numRows) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        "
      },
      "c": {
        "name": "c",
        "code": "char* convert(char* s, int numRows) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public string Convert(string s, int numRows) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} s\n * @param {number} numRows\n * @return {string}\n */\nvar convert = function(s, numRows) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function convert(s: string, numRows: number): string {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @param Integer $numRows\n     * @return String\n     */\n    function convert($s, $numRows) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func convert(_ s: String, _ numRows: Int) -> String {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun convert(s: String, numRows: Int): String {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  String convert(String s, int numRows) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func convert(s string, numRows int) string {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} s\n# @param {Integer} num_rows\n# @return {String}\ndef convert(s, num_rows)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def convert(s: String, numRows: Int): String = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn convert(s: String, num_rows: i32) -> String {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (convert s numRows)\n  (-> string? exact-integer? string?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec convert(S :: unicode:unicode_binary(), NumRows :: integer()) -> unicode:unicode_binary().\nconvert(S, NumRows) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec convert(s :: String.t, num_rows :: integer) :: String.t\n  def convert(s, num_rows) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "7",
    "title": "Reverse Integer",
    "difficulty": "Medium",
    "category": "Math",
    "description": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "x = 123",
        "output": "321",
        "explanation": "",
        "images": []
      },
      {
        "input": "x = -123",
        "output": "-321",
        "explanation": "",
        "images": []
      },
      {
        "input": "x = 120",
        "output": "21",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "-231 <= x <= 231 - 1"
    ],
    "frontendId": "7",
    "problemId": "7",
    "slug": "reverse-integer",
    "topics": [
      "Math"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int reverse(int x) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int reverse(int x) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def reverse(self, x: int) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int reverse(int x){\n\n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int Reverse(int x) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number} x\n * @return {number}\n */\nvar reverse = function(x) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function reverse(x: number): number {\n\n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer $x\n     * @return Integer\n     */\n    function reverse($x) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func reverse(_ x: Int) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun reverse(x: Int): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int reverse(int x) {\n\n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func reverse(x int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer} x\n# @return {Integer}\ndef reverse(x)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def reverse(x: Int): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn reverse(x: i32) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (reverse x)\n  (-> exact-integer? exact-integer?)\n\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec reverse(X :: integer()) -> integer().\nreverse(X) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec reverse(x :: integer) :: integer\n  def reverse(x) do\n\n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "8",
    "title": "String to Integer (atoi)",
    "difficulty": "Medium",
    "category": "String",
    "description": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.\nThe algorithm for myAtoi(string s) is as follows:\nReturn the integer as the final result.\nExample 1:\nExample 2:\nExample 3:\nExample 4:\nExample 5:\nConstraints:",
    "examples": [],
    "privateTests": [],
    "constraints": [
      "0 <= s.length <= 200",
      "s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'."
    ],
    "frontendId": "8",
    "problemId": "8",
    "slug": "string-to-integer-atoi",
    "topics": [
      "String"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int myAtoi(string s) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int myAtoi(String s) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def myAtoi(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int myAtoi(char* s) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int MyAtoi(string s) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar myAtoi = function(s) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function myAtoi(s: string): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function myAtoi($s) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func myAtoi(_ s: String) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun myAtoi(s: String): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int myAtoi(String s) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func myAtoi(s string) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} s\n# @return {Integer}\ndef my_atoi(s)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def myAtoi(s: String): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn my_atoi(s: String) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (my-atoi s)\n  (-> string? exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec my_atoi(S :: unicode:unicode_binary()) -> integer().\nmy_atoi(S) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec my_atoi(s :: String.t) :: integer\n  def my_atoi(s) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "9",
    "title": "Palindrome Number",
    "difficulty": "Easy",
    "category": "Math",
    "description": "Given an integer x, return true if x is a palindrome, and false otherwise.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "x = 121",
        "output": "true",
        "explanation": "121 reads as 121 from left to right and from right to left.",
        "images": []
      },
      {
        "input": "x = -121",
        "output": "false",
        "explanation": "From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.",
        "images": []
      },
      {
        "input": "x = 10",
        "output": "false",
        "explanation": "Reads 01 from right to left. Therefore it is not a palindrome.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "-231 <= x <= 231 - 1"
    ],
    "frontendId": "9",
    "problemId": "9",
    "slug": "palindrome-number",
    "topics": [
      "Math"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public boolean isPalindrome(int x) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        "
      },
      "c": {
        "name": "c",
        "code": "bool isPalindrome(int x) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public bool IsPalindrome(int x) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number} x\n * @return {boolean}\n */\nvar isPalindrome = function(x) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function isPalindrome(x: number): boolean {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer $x\n     * @return Boolean\n     */\n    function isPalindrome($x) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func isPalindrome(_ x: Int) -> Bool {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun isPalindrome(x: Int): Boolean {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  bool isPalindrome(int x) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func isPalindrome(x int) bool {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer} x\n# @return {Boolean}\ndef is_palindrome(x)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def isPalindrome(x: Int): Boolean = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn is_palindrome(x: i32) -> bool {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (is-palindrome x)\n  (-> exact-integer? boolean?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec is_palindrome(X :: integer()) -> boolean().\nis_palindrome(X) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec is_palindrome(x :: integer) :: boolean\n  def is_palindrome(x) do\n    \n  end\nend"
      }
    },
    "hints": [
      "Beware of overflow when you reverse the integer."
    ],
    "acceptance": 0,
    "points": 100
  },
  {
    "numId": "10",
    "title": "Regular Expression Matching",
    "difficulty": "Hard",
    "category": "String",
    "description": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\nThe matching should cover the entire input string (not partial).\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "s = \"aa\", p = \"a\"",
        "output": "false",
        "explanation": "\"a\" does not match the entire string \"aa\".",
        "images": []
      },
      {
        "input": "s = \"aa\", p = \"a*\"",
        "output": "true",
        "explanation": "'*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".",
        "images": []
      },
      {
        "input": "s = \"ab\", p = \".*\"",
        "output": "true",
        "explanation": "\".*\" means \"zero or more (*) of any character (.)\".",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= s.length <= 20",
      "1 <= p.length <= 20",
      "s contains only lowercase English letters.",
      "p contains only lowercase English letters, '.', and '*'.",
      "It is guaranteed for each appearance of the character '*', there will be a previous valid character to match."
    ],
    "frontendId": "10",
    "problemId": "10",
    "slug": "regular-expression-matching",
    "topics": [
      "String",
      "Dynamic Programming",
      "Recursion"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public boolean isMatch(String s, String p) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        "
      },
      "c": {
        "name": "c",
        "code": "bool isMatch(char* s, char* p) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public bool IsMatch(string s, string p) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} s\n * @param {string} p\n * @return {boolean}\n */\nvar isMatch = function(s, p) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function isMatch(s: string, p: string): boolean {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String $p\n     * @return Boolean\n     */\n    function isMatch($s, $p) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func isMatch(_ s: String, _ p: String) -> Bool {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun isMatch(s: String, p: String): Boolean {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  bool isMatch(String s, String p) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func isMatch(s string, p string) bool {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} s\n# @param {String} p\n# @return {Boolean}\ndef is_match(s, p)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def isMatch(s: String, p: String): Boolean = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn is_match(s: String, p: String) -> bool {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (is-match s p)\n  (-> string? string? boolean?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec is_match(S :: unicode:unicode_binary(), P :: unicode:unicode_binary()) -> boolean().\nis_match(S, P) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec is_match(s :: String.t, p :: String.t) :: boolean\n  def is_match(s, p) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 260
  },
  {
    "numId": "11",
    "title": "Container With Most Water",
    "difficulty": "Medium",
    "category": "Array",
    "description": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.",
        "images": [
          "https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg"
        ]
      },
      {
        "input": "height = [1,1]",
        "output": "1",
        "explanation": "",
        "images": [
          "https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "n == height.length",
      "2 <= n <= 105",
      "0 <= height[i] <= 104"
    ],
    "frontendId": "11",
    "problemId": "11",
    "slug": "container-with-most-water",
    "topics": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int maxArea(int[] height) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int maxArea(int* height, int heightSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int MaxArea(int[] height) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} height\n * @return {number}\n */\nvar maxArea = function(height) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function maxArea(height: number[]): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $height\n     * @return Integer\n     */\n    function maxArea($height) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func maxArea(_ height: [Int]) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun maxArea(height: IntArray): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int maxArea(List<int> height) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func maxArea(height []int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} height\n# @return {Integer}\ndef max_area(height)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def maxArea(height: Array[Int]): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn max_area(height: Vec<i32>) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (max-area height)\n  (-> (listof exact-integer?) exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec max_area(Height :: [integer()]) -> integer().\nmax_area(Height) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec max_area(height :: [integer]) :: integer\n  def max_area(height) do\n    \n  end\nend"
      }
    },
    "hints": [
      "If you simulate the problem, it will be O(n^2) which is not efficient.",
      "Try to use two-pointers. Set one pointer to the left and one to the right of the array. Always move the pointer that points to the lower line.",
      "How can you calculate the amount of water at each step?"
    ],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "12",
    "title": "Integer to Roman",
    "difficulty": "Medium",
    "category": "Hash Table",
    "description": "Seven different symbols represent Roman numerals with the following values:\nRoman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:\nGiven an integer, convert it to a Roman numeral.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [],
    "privateTests": [],
    "constraints": [
      "1 <= num <= 3999"
    ],
    "frontendId": "12",
    "problemId": "12",
    "slug": "integer-to-roman",
    "topics": [
      "Hash Table",
      "Math",
      "String"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    string intToRoman(int num) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public String intToRoman(int num) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        "
      },
      "c": {
        "name": "c",
        "code": "char* intToRoman(int num) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public string IntToRoman(int num) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number} num\n * @return {string}\n */\nvar intToRoman = function(num) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function intToRoman(num: number): string {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer $num\n     * @return String\n     */\n    function intToRoman($num) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func intToRoman(_ num: Int) -> String {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun intToRoman(num: Int): String {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  String intToRoman(int num) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func intToRoman(num int) string {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer} num\n# @return {String}\ndef int_to_roman(num)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def intToRoman(num: Int): String = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn int_to_roman(num: i32) -> String {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (int-to-roman num)\n  (-> exact-integer? string?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec int_to_roman(Num :: integer()) -> unicode:unicode_binary().\nint_to_roman(Num) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec int_to_roman(num :: integer) :: String.t\n  def int_to_roman(num) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "13",
    "title": "Roman to Integer",
    "difficulty": "Easy",
    "category": "Hash Table",
    "description": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nFor example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nGiven a roman numeral, convert it to an integer.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "s = \"III\"",
        "output": "3",
        "explanation": "III = 3.",
        "images": []
      },
      {
        "input": "s = \"LVIII\"",
        "output": "58",
        "explanation": "L = 50, V= 5, III = 3.",
        "images": []
      },
      {
        "input": "s = \"MCMXCIV\"",
        "output": "1994",
        "explanation": "M = 1000, CM = 900, XC = 90 and IV = 4.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= s.length <= 15",
      "s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').",
      "It is guaranteed that s is a valid roman numeral in the range [1, 3999]."
    ],
    "frontendId": "13",
    "problemId": "13",
    "slug": "roman-to-integer",
    "topics": [
      "Hash Table",
      "Math",
      "String"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int romanToInt(string s) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int romanToInt(String s) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int romanToInt(char* s) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int RomanToInt(string s) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar romanToInt = function(s) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function romanToInt(s: string): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function romanToInt($s) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func romanToInt(_ s: String) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun romanToInt(s: String): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int romanToInt(String s) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func romanToInt(s string) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} s\n# @return {Integer}\ndef roman_to_int(s)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def romanToInt(s: String): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn roman_to_int(s: String) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (roman-to-int s)\n  (-> string? exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec roman_to_int(S :: unicode:unicode_binary()) -> integer().\nroman_to_int(S) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec roman_to_int(s :: String.t) :: integer\n  def roman_to_int(s) do\n    \n  end\nend"
      }
    },
    "hints": [
      "Problem is simpler to solve by working the string from back to front and using a map."
    ],
    "acceptance": 0,
    "points": 100
  },
  {
    "numId": "14",
    "title": "Longest Common Prefix",
    "difficulty": "Easy",
    "category": "Array",
    "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "strs = [\"flower\",\"flow\",\"flight\"]",
        "output": "\"fl\"",
        "explanation": "",
        "images": []
      },
      {
        "input": "strs = [\"dog\",\"racecar\",\"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix among the input strings.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "strs[i] consists of only lowercase English letters if it is non-empty."
    ],
    "frontendId": "14",
    "problemId": "14",
    "slug": "longest-common-prefix",
    "topics": [
      "Array",
      "String",
      "Trie"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        "
      },
      "c": {
        "name": "c",
        "code": "char* longestCommonPrefix(char** strs, int strsSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public string LongestCommonPrefix(string[] strs) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string[]} strs\n * @return {string}\n */\nvar longestCommonPrefix = function(strs) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function longestCommonPrefix(strs: string[]): string {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String[] $strs\n     * @return String\n     */\n    function longestCommonPrefix($strs) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func longestCommonPrefix(_ strs: [String]) -> String {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun longestCommonPrefix(strs: Array<String>): String {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  String longestCommonPrefix(List<String> strs) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func longestCommonPrefix(strs []string) string {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String[]} strs\n# @return {String}\ndef longest_common_prefix(strs)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def longestCommonPrefix(strs: Array[String]): String = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn longest_common_prefix(strs: Vec<String>) -> String {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (longest-common-prefix strs)\n  (-> (listof string?) string?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec longest_common_prefix(Strs :: [unicode:unicode_binary()]) -> unicode:unicode_binary().\nlongest_common_prefix(Strs) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec longest_common_prefix(strs :: [String.t]) :: String.t\n  def longest_common_prefix(strs) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 100
  },
  {
    "numId": "15",
    "title": "3Sum",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "nums = [-1,0,1,2,-1,-4]",
        "output": "[[-1,-1,2],[-1,0,1]]",
        "explanation": "nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.",
        "images": []
      },
      {
        "input": "nums = [0,1,1]",
        "output": "[]",
        "explanation": "The only possible triplet does not sum up to 0.",
        "images": []
      },
      {
        "input": "nums = [0,0,0]",
        "output": "[[0,0,0]]",
        "explanation": "The only possible triplet sums up to 0.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "3 <= nums.length <= 3000",
      "-105 <= nums[i] <= 105"
    ],
    "frontendId": "15",
    "problemId": "15",
    "slug": "3sum",
    "topics": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public IList<IList<int>> ThreeSum(int[] nums) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar threeSum = function(nums) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function threeSum(nums: number[]): number[][] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[][]\n     */\n    function threeSum($nums) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func threeSum(_ nums: [Int]) -> [[Int]] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun threeSum(nums: IntArray): List<List<Int>> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<List<int>> threeSum(List<int> nums) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func threeSum(nums []int) [][]int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @return {Integer[][]}\ndef three_sum(nums)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def threeSum(nums: Array[Int]): List[List[Int]] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn three_sum(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (three-sum nums)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec three_sum(Nums :: [integer()]) -> [[integer()]].\nthree_sum(Nums) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec three_sum(nums :: [integer]) :: [[integer]]\n  def three_sum(nums) do\n    \n  end\nend"
      }
    },
    "hints": [
      "So, we essentially need to find three numbers x, y, and z such that they add up to the given value. If we fix one of the numbers say x, we are left with the two-sum problem at hand!",
      "For the two-sum problem, if we fix one of the numbers, say x, we have to scan the entire array to find the next number y, which is value - x where value is the input parameter. Can we change our array somehow so that this search becomes faster?",
      "The second train of thought for two-sum is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"
    ],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "16",
    "title": "3Sum Closest",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\nReturn the sum of the three integers.\nYou may assume that each input would have exactly one solution.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "nums = [-1,2,1,-4], target = 1",
        "output": "2",
        "explanation": "The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).",
        "images": []
      },
      {
        "input": "nums = [0,0,0], target = 1",
        "output": "0",
        "explanation": "The sum that is closest to the target is 0. (0 + 0 + 0 = 0).",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "3 <= nums.length <= 500",
      "-1000 <= nums[i] <= 1000",
      "-104 <= target <= 104"
    ],
    "frontendId": "16",
    "problemId": "16",
    "slug": "3sum-closest",
    "topics": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int threeSumClosest(int* nums, int numsSize, int target) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int ThreeSumClosest(int[] nums, int target) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar threeSumClosest = function(nums, target) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function threeSumClosest(nums: number[], target: number): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer\n     */\n    function threeSumClosest($nums, $target) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun threeSumClosest(nums: IntArray, target: Int): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int threeSumClosest(List<int> nums, int target) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func threeSumClosest(nums []int, target int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer}\ndef three_sum_closest(nums, target)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def threeSumClosest(nums: Array[Int], target: Int): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn three_sum_closest(nums: Vec<i32>, target: i32) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (three-sum-closest nums target)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec three_sum_closest(Nums :: [integer()], Target :: integer()) -> integer().\nthree_sum_closest(Nums, Target) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec three_sum_closest(nums :: [integer], target :: integer) :: integer\n  def three_sum_closest(nums, target) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "17",
    "title": "Letter Combinations of a Phone Number",
    "difficulty": "Medium",
    "category": "Hash Table",
    "description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "digits = \"23\"",
        "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png"
        ]
      },
      {
        "input": "digits = \"\"",
        "output": "[]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png"
        ]
      },
      {
        "input": "digits = \"2\"",
        "output": "[\"a\",\"b\",\"c\"]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "0 <= digits.length <= 4",
      "digits[i] is a digit in the range ['2', '9']."
    ],
    "frontendId": "17",
    "problemId": "17",
    "slug": "letter-combinations-of-a-phone-number",
    "topics": [
      "Hash Table",
      "String",
      "Backtracking"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public List<String> letterCombinations(String digits) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** letterCombinations(char* digits, int* returnSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public IList<string> LetterCombinations(string digits) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} digits\n * @return {string[]}\n */\nvar letterCombinations = function(digits) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function letterCombinations(digits: string): string[] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $digits\n     * @return String[]\n     */\n    function letterCombinations($digits) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func letterCombinations(_ digits: String) -> [String] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun letterCombinations(digits: String): List<String> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<String> letterCombinations(String digits) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func letterCombinations(digits string) []string {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} digits\n# @return {String[]}\ndef letter_combinations(digits)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def letterCombinations(digits: String): List[String] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn letter_combinations(digits: String) -> Vec<String> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (letter-combinations digits)\n  (-> string? (listof string?))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec letter_combinations(Digits :: unicode:unicode_binary()) -> [unicode:unicode_binary()].\nletter_combinations(Digits) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec letter_combinations(digits :: String.t) :: [String.t]\n  def letter_combinations(digits) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "18",
    "title": "4Sum",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\nYou may return the answer in any order.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "nums = [1,0,-1,0,-2,2], target = 0",
        "output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
        "explanation": "",
        "images": []
      },
      {
        "input": "nums = [2,2,2,2,2], target = 8",
        "output": "[[2,2,2,2]]",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= nums.length <= 200",
      "-109 <= nums[i] <= 109",
      "-109 <= target <= 109"
    ],
    "frontendId": "18",
    "problemId": "18",
    "slug": "4sum",
    "topics": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public IList<IList<int>> FourSum(int[] nums, int target) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[][]}\n */\nvar fourSum = function(nums, target) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function fourSum(nums: number[], target: number): number[][] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer[][]\n     */\n    function fourSum($nums, $target) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func fourSum(_ nums: [Int], _ target: Int) -> [[Int]] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun fourSum(nums: IntArray, target: Int): List<List<Int>> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<List<int>> fourSum(List<int> nums, int target) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func fourSum(nums []int, target int) [][]int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer[][]}\ndef four_sum(nums, target)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def fourSum(nums: Array[Int], target: Int): List[List[Int]] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn four_sum(nums: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (four-sum nums target)\n  (-> (listof exact-integer?) exact-integer? (listof (listof exact-integer?)))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec four_sum(Nums :: [integer()], Target :: integer()) -> [[integer()]].\nfour_sum(Nums, Target) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec four_sum(nums :: [integer], target :: integer) :: [[integer]]\n  def four_sum(nums, target) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "19",
    "title": "Remove Nth Node From End of List",
    "difficulty": "Medium",
    "category": "Linked List",
    "description": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you do this in one pass?",
    "examples": [
      {
        "input": "head = [1,2,3,4,5], n = 2",
        "output": "[1,2,3,5]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg"
        ]
      },
      {
        "input": "head = [1], n = 1",
        "output": "[]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg"
        ]
      },
      {
        "input": "head = [1,2], n = 1",
        "output": "[1]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "The number of nodes in the list is sz.",
      "1 <= sz <= 30",
      "0 <= Node.val <= 100",
      "1 <= n <= sz"
    ],
    "frontendId": "19",
    "problemId": "19",
    "slug": "remove-nth-node-from-end-of-list",
    "topics": [
      "Linked List",
      "Two Pointers"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type n: int\n        :rtype: Optional[ListNode]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} n\n * @return {ListNode}\n */\nvar removeNthFromEnd = function(head, n) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @param Integer $n\n     * @return ListNode\n     */\n    function removeNthFromEnd($head, $n) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun removeNthFromEnd(head: ListNode?, n: Int): ListNode? {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? removeNthFromEnd(ListNode? head, int n) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @param {Integer} n\n# @return {ListNode}\ndef remove_nth_from_end(head, n)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def removeNthFromEnd(head: ListNode, n: Int): ListNode = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (remove-nth-from-end head n)\n  (-> (or/c list-node? #f) exact-integer? (or/c list-node? #f))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec remove_nth_from_end(Head :: #list_node{} | null, N :: integer()) -> #list_node{} | null.\nremove_nth_from_end(Head, N) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec remove_nth_from_end(head :: ListNode.t | nil, n :: integer) :: ListNode.t | nil\n  def remove_nth_from_end(head, n) do\n    \n  end\nend"
      }
    },
    "hints": [
      "Maintain two pointers and update one with a delay of n steps."
    ],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "20",
    "title": "Valid Parentheses",
    "difficulty": "Easy",
    "category": "String",
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\nAn input string is valid if:\nExample 1:\nExample 2:\nExample 3:\nExample 4:\nExample 5:\nConstraints:",
    "examples": [
      {
        "input": "s = \"()\"",
        "output": "true",
        "explanation": "",
        "images": []
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true",
        "explanation": "",
        "images": []
      },
      {
        "input": "s = \"(]\"",
        "output": "false",
        "explanation": "",
        "images": []
      },
      {
        "input": "s = \"([])\"",
        "output": "true",
        "explanation": "",
        "images": []
      },
      {
        "input": "s = \"([)]\"",
        "output": "false",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= s.length <= 104",
      "s consists of parentheses only '()[]{}'."
    ],
    "frontendId": "20",
    "problemId": "20",
    "slug": "valid-parentheses",
    "topics": [
      "String",
      "Stack"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    bool isValid(string s) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public boolean isValid(String s) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def isValid(self, s: str) -> bool:\n        "
      },
      "c": {
        "name": "c",
        "code": "bool isValid(char* s) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public bool IsValid(string s) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(s) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function isValid(s: string): boolean {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Boolean\n     */\n    function isValid($s) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func isValid(_ s: String) -> Bool {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun isValid(s: String): Boolean {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  bool isValid(String s) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func isValid(s string) bool {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} s\n# @return {Boolean}\ndef is_valid(s)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def isValid(s: String): Boolean = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn is_valid(s: String) -> bool {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (is-valid s)\n  (-> string? boolean?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec is_valid(S :: unicode:unicode_binary()) -> boolean().\nis_valid(S) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec is_valid(s :: String.t) :: boolean\n  def is_valid(s) do\n    \n  end\nend"
      }
    },
    "hints": [
      "Use a stack of characters.",
      "When you encounter an opening bracket, push it to the top of the stack.",
      "When you encounter a closing bracket, check if the top of the stack was the opening for it. If yes, pop it from the stack. Otherwise, return false."
    ],
    "acceptance": 0,
    "points": 100
  },
  {
    "numId": "21",
    "title": "Merge Two Sorted Lists",
    "difficulty": "Easy",
    "category": "Linked List",
    "description": "You are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg"
        ]
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg"
        ]
      },
      {
        "input": "list1 = [], list2 = [0]",
        "output": "[0]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50].",
      "-100 <= Node.val <= 100",
      "Both list1 and list2 are sorted in non-decreasing order."
    ],
    "frontendId": "21",
    "problemId": "21",
    "slug": "merge-two-sorted-lists",
    "topics": [
      "Linked List",
      "Recursion"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode MergeTwoLists(ListNode list1, ListNode list2) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} list1\n * @param {ListNode} list2\n * @return {ListNode}\n */\nvar mergeTwoLists = function(list1, list2) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $list1\n     * @param ListNode $list2\n     * @return ListNode\n     */\n    function mergeTwoLists($list1, $list2) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func mergeTwoLists(_ list1: ListNode?, _ list2: ListNode?) -> ListNode? {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun mergeTwoLists(list1: ListNode?, list2: ListNode?): ListNode? {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? mergeTwoLists(ListNode? list1, ListNode? list2) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} list1\n# @param {ListNode} list2\n# @return {ListNode}\ndef merge_two_lists(list1, list2)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def mergeTwoLists(list1: ListNode, list2: ListNode): ListNode = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn merge_two_lists(list1: Option<Box<ListNode>>, list2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (merge-two-lists list1 list2)\n  (-> (or/c list-node? #f) (or/c list-node? #f) (or/c list-node? #f))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec merge_two_lists(List1 :: #list_node{} | null, List2 :: #list_node{} | null) -> #list_node{} | null.\nmerge_two_lists(List1, List2) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec merge_two_lists(list1 :: ListNode.t | nil, list2 :: ListNode.t | nil) :: ListNode.t | nil\n  def merge_two_lists(list1, list2) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 100
  },
  {
    "numId": "22",
    "title": "Generate Parentheses",
    "difficulty": "Medium",
    "category": "String",
    "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "n = 3",
        "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
        "explanation": "",
        "images": []
      },
      {
        "input": "n = 1",
        "output": "[\"()\"]",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= n <= 8"
    ],
    "frontendId": "22",
    "problemId": "22",
    "slug": "generate-parentheses",
    "topics": [
      "String",
      "Dynamic Programming",
      "Backtracking"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<string> generateParenthesis(int n) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public List<String> generateParenthesis(int n) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** generateParenthesis(int n, int* returnSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public IList<string> GenerateParenthesis(int n) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number} n\n * @return {string[]}\n */\nvar generateParenthesis = function(n) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function generateParenthesis(n: number): string[] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return String[]\n     */\n    function generateParenthesis($n) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func generateParenthesis(_ n: Int) -> [String] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun generateParenthesis(n: Int): List<String> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<String> generateParenthesis(int n) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func generateParenthesis(n int) []string {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer} n\n# @return {String[]}\ndef generate_parenthesis(n)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def generateParenthesis(n: Int): List[String] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn generate_parenthesis(n: i32) -> Vec<String> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (generate-parenthesis n)\n  (-> exact-integer? (listof string?))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec generate_parenthesis(N :: integer()) -> [unicode:unicode_binary()].\ngenerate_parenthesis(N) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec generate_parenthesis(n :: integer) :: [String.t]\n  def generate_parenthesis(n) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "23",
    "title": "Merge k Sorted Lists",
    "difficulty": "Hard",
    "category": "Linked List",
    "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
        "output": "[1,1,2,3,4,4,5,6]",
        "explanation": "The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted linked list:\n1->1->2->3->4->4->5->6",
        "images": []
      },
      {
        "input": "lists = []",
        "output": "[]",
        "explanation": "",
        "images": []
      },
      {
        "input": "lists = [[]]",
        "output": "[]",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "k == lists.length",
      "0 <= k <= 104",
      "0 <= lists[i].length <= 500",
      "-104 <= lists[i][j] <= 104",
      "lists[i] is sorted in ascending order.",
      "The sum of lists[i].length will not exceed 104."
    ],
    "frontendId": "23",
    "problemId": "23",
    "slug": "merge-k-sorted-lists",
    "topics": [
      "Linked List",
      "Divide and Conquer",
      "Heap (Priority Queue)",
      "Merge Sort"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[Optional[ListNode]]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* mergeKLists(struct ListNode** lists, int listsSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode MergeKLists(ListNode[] lists) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nvar mergeKLists = function(lists) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction mergeKLists(lists: Array<ListNode | null>): ListNode | null {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode[] $lists\n     * @return ListNode\n     */\n    function mergeKLists($lists) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func mergeKLists(_ lists: [ListNode?]) -> ListNode? {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun mergeKLists(lists: Array<ListNode?>): ListNode? {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? mergeKLists(List<ListNode?> lists) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc mergeKLists(lists []*ListNode) *ListNode {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode[]} lists\n# @return {ListNode}\ndef merge_k_lists(lists)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def mergeKLists(lists: Array[ListNode]): ListNode = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (merge-k-lists lists)\n  (-> (listof (or/c list-node? #f)) (or/c list-node? #f))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec merge_k_lists(Lists :: [#list_node{} | null]) -> #list_node{} | null.\nmerge_k_lists(Lists) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec merge_k_lists(lists :: [ListNode.t | nil]) :: ListNode.t | nil\n  def merge_k_lists(lists) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 260
  },
  {
    "numId": "24",
    "title": "Swap Nodes in Pairs",
    "difficulty": "Medium",
    "category": "Linked List",
    "description": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\nExample 1:\nExample 2:\nExample 3:\nExample 4:\nConstraints:",
    "examples": [
      {
        "input": "head = [1,2,3,4]",
        "output": "[2,1,4,3]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg"
        ]
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": "",
        "images": []
      },
      {
        "input": "head = [1]",
        "output": "[1]",
        "explanation": "",
        "images": []
      },
      {
        "input": "head = [1,2,3]",
        "output": "[2,1,3]",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "The number of nodes in the list is in the range [0, 100].",
      "0 <= Node.val <= 100"
    ],
    "frontendId": "24",
    "problemId": "24",
    "slug": "swap-nodes-in-pairs",
    "topics": [
      "Linked List",
      "Recursion"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* swapPairs(struct ListNode* head) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode SwapPairs(ListNode head) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction swapPairs(head: ListNode | null): ListNode | null {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function swapPairs($head) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func swapPairs(_ head: ListNode?) -> ListNode? {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun swapPairs(head: ListNode?): ListNode? {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? swapPairs(ListNode? head) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc swapPairs(head *ListNode) *ListNode {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @return {ListNode}\ndef swap_pairs(head)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def swapPairs(head: ListNode): ListNode = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (swap-pairs head)\n  (-> (or/c list-node? #f) (or/c list-node? #f))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec swap_pairs(Head :: #list_node{} | null) -> #list_node{} | null.\nswap_pairs(Head) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec swap_pairs(head :: ListNode.t | nil) :: ListNode.t | nil\n  def swap_pairs(head) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "25",
    "title": "Reverse Nodes in k-Group",
    "difficulty": "Hard",
    "category": "Linked List",
    "description": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\nExample 1:\nExample 2:\nConstraints:\nFollow-up: Can you solve the problem in O(1) extra memory space?",
    "examples": [
      {
        "input": "head = [1,2,3,4,5], k = 2",
        "output": "[2,1,4,3,5]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg"
        ]
      },
      {
        "input": "head = [1,2,3,4,5], k = 3",
        "output": "[3,2,1,4,5]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "The number of nodes in the list is n.",
      "1 <= k <= n <= 5000",
      "0 <= Node.val <= 1000"
    ],
    "frontendId": "25",
    "problemId": "25",
    "slug": "reverse-nodes-in-k-group",
    "topics": [
      "Linked List",
      "Recursion"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type k: int\n        :rtype: Optional[ListNode]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* reverseKGroup(struct ListNode* head, int k) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode ReverseKGroup(ListNode head, int k) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar reverseKGroup = function(head, k) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction reverseKGroup(head: ListNode | null, k: number): ListNode | null {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @param Integer $k\n     * @return ListNode\n     */\n    function reverseKGroup($head, $k) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func reverseKGroup(_ head: ListNode?, _ k: Int) -> ListNode? {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun reverseKGroup(head: ListNode?, k: Int): ListNode? {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? reverseKGroup(ListNode? head, int k) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @param {Integer} k\n# @return {ListNode}\ndef reverse_k_group(head, k)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def reverseKGroup(head: ListNode, k: Int): ListNode = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn reverse_k_group(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (reverse-k-group head k)\n  (-> (or/c list-node? #f) exact-integer? (or/c list-node? #f))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec reverse_k_group(Head :: #list_node{} | null, K :: integer()) -> #list_node{} | null.\nreverse_k_group(Head, K) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec reverse_k_group(head :: ListNode.t | nil, k :: integer) :: ListNode.t | nil\n  def reverse_k_group(head, k) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 260
  },
  {
    "numId": "26",
    "title": "Remove Duplicates from Sorted Array",
    "difficulty": "Easy",
    "category": "Array",
    "description": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\nCustom Judge:\nThe judge will test your solution with the following code:\nIf all assertions pass, then your solution will be accepted.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "nums = [1,1,2]",
        "output": "2, nums = [1,2,_]",
        "explanation": "Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
        "images": []
      },
      {
        "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
        "output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
        "explanation": "Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= nums.length <= 3 * 104",
      "-100 <= nums[i] <= 100",
      "nums is sorted in non-decreasing order."
    ],
    "frontendId": "26",
    "problemId": "26",
    "slug": "remove-duplicates-from-sorted-array",
    "topics": [
      "Array",
      "Two Pointers"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int removeDuplicates(int* nums, int numsSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int RemoveDuplicates(int[] nums) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function removeDuplicates(nums: number[]): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function removeDuplicates(&$nums) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func removeDuplicates(_ nums: inout [Int]) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun removeDuplicates(nums: IntArray): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int removeDuplicates(List<int> nums) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func removeDuplicates(nums []int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef remove_duplicates(nums)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def removeDuplicates(nums: Array[Int]): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\n        \n    }\n}"
      }
    },
    "hints": [
      "In this problem, the key point to focus on is the input array being sorted. As far as duplicate elements are concerned, what is their positioning in the array when the given array is sorted? Look at the image below for the answer. If we know the position of one of the elements, do we also know the positioning of all the duplicate elements?\r\n\r\n<br>\r\n<img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_rem_dup.png\" width=\"500\"/>",
      "We need to modify the array in-place and the size of the final array would potentially be smaller than the size of the input array. So, we ought to use a two-pointer approach here. One, that would keep track of the current element in the original array and another one for just the unique elements.",
      "Essentially, once an element is encountered, you simply need to <b>bypass</b> its duplicates and move on to the next unique element."
    ],
    "acceptance": 0,
    "points": 100
  },
  {
    "numId": "27",
    "title": "Remove Element",
    "difficulty": "Easy",
    "category": "Array",
    "description": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\nCustom Judge:\nThe judge will test your solution with the following code:\nIf all assertions pass, then your solution will be accepted.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "nums = [3,2,2,3], val = 3",
        "output": "2, nums = [2,2,_,_]",
        "explanation": "Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
        "images": []
      },
      {
        "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
        "output": "5, nums = [0,1,4,0,3,_,_,_]",
        "explanation": "Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "0 <= nums.length <= 100",
      "0 <= nums[i] <= 50",
      "0 <= val <= 100"
    ],
    "frontendId": "27",
    "problemId": "27",
    "slug": "remove-element",
    "topics": [
      "Array",
      "Two Pointers"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def removeElement(self, nums, val):\n        \"\"\"\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int removeElement(int* nums, int numsSize, int val) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int RemoveElement(int[] nums, int val) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @param {number} val\n * @return {number}\n */\nvar removeElement = function(nums, val) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function removeElement(nums: number[], val: number): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $val\n     * @return Integer\n     */\n    function removeElement(&$nums, $val) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func removeElement(_ nums: inout [Int], _ val: Int) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun removeElement(nums: IntArray, `val`: Int): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int removeElement(List<int> nums, int val) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func removeElement(nums []int, val int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @param {Integer} val\n# @return {Integer}\ndef remove_element(nums, val)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def removeElement(nums: Array[Int], `val`: Int): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {\n        \n    }\n}"
      }
    },
    "hints": [
      "The problem statement clearly asks us to modify the array in-place and it also says that the element beyond the new length of the array can be anything. Given an element, we need to remove all the occurrences of it from the array. We don't technically need to <b>remove</b> that element per-say, right?",
      "We can move all the occurrences of this element to the end of the array. Use two pointers!\r\n<br><img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_remove_element.png\" width=\"500\"/>",
      "Yet another direction of thought is to consider the elements to be removed as non-existent. In a single pass, if we keep copying the visible elements in-place, that should also solve this problem for us."
    ],
    "acceptance": 0,
    "points": 100
  },
  {
    "numId": "28",
    "title": "Find the Index of the First Occurrence in a String",
    "difficulty": "Easy",
    "category": "Two Pointers",
    "description": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "haystack = \"sadbutsad\", needle = \"sad\"",
        "output": "0",
        "explanation": "\"sad\" occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.",
        "images": []
      },
      {
        "input": "haystack = \"leetcode\", needle = \"leeto\"",
        "output": "-1",
        "explanation": "\"leeto\" did not occur in \"leetcode\", so we return -1.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= haystack.length, needle.length <= 104",
      "haystack and needle consist of only lowercase English characters."
    ],
    "frontendId": "28",
    "problemId": "28",
    "slug": "find-the-index-of-the-first-occurrence-in-a-string",
    "topics": [
      "Two Pointers",
      "String",
      "String Matching"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int strStr(char* haystack, char* needle) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int StrStr(string haystack, string needle) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} haystack\n * @param {string} needle\n * @return {number}\n */\nvar strStr = function(haystack, needle) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function strStr(haystack: string, needle: string): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $haystack\n     * @param String $needle\n     * @return Integer\n     */\n    function strStr($haystack, $needle) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func strStr(_ haystack: String, _ needle: String) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun strStr(haystack: String, needle: String): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int strStr(String haystack, String needle) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func strStr(haystack string, needle string) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} haystack\n# @param {String} needle\n# @return {Integer}\ndef str_str(haystack, needle)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def strStr(haystack: String, needle: String): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn str_str(haystack: String, needle: String) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (str-str haystack needle)\n  (-> string? string? exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec str_str(Haystack :: unicode:unicode_binary(), Needle :: unicode:unicode_binary()) -> integer().\nstr_str(Haystack, Needle) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec str_str(haystack :: String.t, needle :: String.t) :: integer\n  def str_str(haystack, needle) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 100
  },
  {
    "numId": "29",
    "title": "Divide Two Integers",
    "difficulty": "Medium",
    "category": "Math",
    "description": "Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\nThe integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\nReturn the quotient after dividing dividend by divisor.\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "dividend = 10, divisor = 3",
        "output": "3",
        "explanation": "10/3 = 3.33333.. which is truncated to 3.",
        "images": []
      },
      {
        "input": "dividend = 7, divisor = -3",
        "output": "-2",
        "explanation": "7/-3 = -2.33333.. which is truncated to -2.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "-231 <= dividend, divisor <= 231 - 1",
      "divisor != 0"
    ],
    "frontendId": "29",
    "problemId": "29",
    "slug": "divide-two-integers",
    "topics": [
      "Math",
      "Bit Manipulation"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int divide(int dividend, int divisor) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int divide(int dividend, int divisor) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int Divide(int dividend, int divisor) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number} dividend\n * @param {number} divisor\n * @return {number}\n */\nvar divide = function(dividend, divisor) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function divide(dividend: number, divisor: number): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer $dividend\n     * @param Integer $divisor\n     * @return Integer\n     */\n    function divide($dividend, $divisor) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func divide(_ dividend: Int, _ divisor: Int) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun divide(dividend: Int, divisor: Int): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int divide(int dividend, int divisor) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func divide(dividend int, divisor int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer} dividend\n# @param {Integer} divisor\n# @return {Integer}\ndef divide(dividend, divisor)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def divide(dividend: Int, divisor: Int): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn divide(dividend: i32, divisor: i32) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (divide dividend divisor)\n  (-> exact-integer? exact-integer? exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec divide(Dividend :: integer(), Divisor :: integer()) -> integer().\ndivide(Dividend, Divisor) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec divide(dividend :: integer, divisor :: integer) :: integer\n  def divide(dividend, divisor) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "30",
    "title": "Substring with Concatenation of All Words",
    "difficulty": "Hard",
    "category": "Hash Table",
    "description": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated string is a string that exactly contains all the strings of any permutation of words concatenated.\nReturn an array of the starting indices of all the concatenated substrings in s. You can return the answer in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
        "output": "[0,9]",
        "explanation": "The substring starting at 0 is \"barfoo\" . It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words . The substring starting at 9 is \"foobar\" . It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words .",
        "images": []
      },
      {
        "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
        "output": "[]",
        "explanation": "There is no concatenated substring.",
        "images": []
      },
      {
        "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
        "output": "[6,9,12]",
        "explanation": "The substring starting at 6 is \"foobarthe\" . It is the concatenation of [\"foo\",\"bar\",\"the\"] . The substring starting at 9 is \"barthefoo\" . It is the concatenation of [\"bar\",\"the\",\"foo\"] . The substring starting at 12 is \"thefoobar\" . It is the concatenation of [\"the\",\"foo\",\"bar\"] .",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= s.length <= 104",
      "1 <= words.length <= 5000",
      "1 <= words[i].length <= 30",
      "s and words[i] consist of lowercase English letters."
    ],
    "frontendId": "30",
    "problemId": "30",
    "slug": "substring-with-concatenation-of-all-words",
    "topics": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findSubstring(char* s, char** words, int wordsSize, int* returnSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public IList<int> FindSubstring(string s, string[] words) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function findSubstring(s: string, words: string[]): number[] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String[] $words\n     * @return Integer[]\n     */\n    function findSubstring($s, $words) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func findSubstring(_ s: String, _ words: [String]) -> [Int] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun findSubstring(s: String, words: Array<String>): List<Int> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<int> findSubstring(String s, List<String> words) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func findSubstring(s string, words []string) []int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} s\n# @param {String[]} words\n# @return {Integer[]}\ndef find_substring(s, words)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def findSubstring(s: String, words: Array[String]): List[Int] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn find_substring(s: String, words: Vec<String>) -> Vec<i32> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (find-substring s words)\n  (-> string? (listof string?) (listof exact-integer?))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec find_substring(S :: unicode:unicode_binary(), Words :: [unicode:unicode_binary()]) -> [integer()].\nfind_substring(S, Words) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec find_substring(s :: String.t, words :: [String.t]) :: [integer]\n  def find_substring(s, words) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 260
  },
  {
    "numId": "31",
    "title": "Next Permutation",
    "difficulty": "Medium",
    "category": "Array",
    "description": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\nGiven an array of integers nums, find the next permutation of nums.\nThe replacement must be in place and use only constant extra memory.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "nums = [1,2,3]",
        "output": "[1,3,2]",
        "explanation": "",
        "images": []
      },
      {
        "input": "nums = [3,2,1]",
        "output": "[1,2,3]",
        "explanation": "",
        "images": []
      },
      {
        "input": "nums = [1,1,5]",
        "output": "[1,5,1]",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 100"
    ],
    "frontendId": "31",
    "problemId": "31",
    "slug": "next-permutation",
    "topics": [
      "Array",
      "Two Pointers"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public void nextPermutation(int[] nums) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        "
      },
      "c": {
        "name": "c",
        "code": "void nextPermutation(int* nums, int numsSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public void NextPermutation(int[] nums) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar nextPermutation = function(nums) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n Do not return anything, modify nums in-place instead.\n */\nfunction nextPermutation(nums: number[]): void {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return NULL\n     */\n    function nextPermutation(&$nums) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func nextPermutation(_ nums: inout [Int]) {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun nextPermutation(nums: IntArray): Unit {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  void nextPermutation(List<int> nums) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func nextPermutation(nums []int)  {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @return {Void} Do not return anything, modify nums in-place instead.\ndef next_permutation(nums)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def nextPermutation(nums: Array[Int]): Unit = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn next_permutation(nums: &mut Vec<i32>) {\n        \n    }\n}"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "32",
    "title": "Longest Valid Parentheses",
    "difficulty": "Hard",
    "category": "String",
    "description": "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "s = \"(()\"",
        "output": "2",
        "explanation": "The longest valid parentheses substring is \"()\".",
        "images": []
      },
      {
        "input": "s = \")()())\"",
        "output": "4",
        "explanation": "The longest valid parentheses substring is \"()()\".",
        "images": []
      },
      {
        "input": "s = \"\"",
        "output": "0",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "0 <= s.length <= 3 * 104",
      "s[i] is '(', or ')'."
    ],
    "frontendId": "32",
    "problemId": "32",
    "slug": "longest-valid-parentheses",
    "topics": [
      "String",
      "Dynamic Programming",
      "Stack"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int longestValidParentheses(String s) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int longestValidParentheses(char* s) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int LongestValidParentheses(string s) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar longestValidParentheses = function(s) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function longestValidParentheses(s: string): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function longestValidParentheses($s) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func longestValidParentheses(_ s: String) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun longestValidParentheses(s: String): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int longestValidParentheses(String s) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func longestValidParentheses(s string) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} s\n# @return {Integer}\ndef longest_valid_parentheses(s)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def longestValidParentheses(s: String): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn longest_valid_parentheses(s: String) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (longest-valid-parentheses s)\n  (-> string? exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec longest_valid_parentheses(S :: unicode:unicode_binary()) -> integer().\nlongest_valid_parentheses(S) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec longest_valid_parentheses(s :: String.t) :: integer\n  def longest_valid_parentheses(s) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 260
  },
  {
    "numId": "33",
    "title": "Search in Rotated Sorted Array",
    "difficulty": "Medium",
    "category": "Array",
    "description": "There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "",
        "images": []
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": "",
        "images": []
      },
      {
        "input": "nums = [1], target = 0",
        "output": "-1",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= nums.length <= 5000",
      "-104 <= nums[i] <= 104",
      "All values of nums are unique.",
      "nums is an ascending array that is possibly rotated.",
      "-104 <= target <= 104"
    ],
    "frontendId": "33",
    "problemId": "33",
    "slug": "search-in-rotated-sorted-array",
    "topics": [
      "Array",
      "Binary Search"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int search(int[] nums, int target) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int search(int* nums, int numsSize, int target) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int Search(int[] nums, int target) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function search(nums: number[], target: number): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer\n     */\n    function search($nums, $target) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func search(_ nums: [Int], _ target: Int) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun search(nums: IntArray, target: Int): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int search(List<int> nums, int target) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func search(nums []int, target int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer}\ndef search(nums, target)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def search(nums: Array[Int], target: Int): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (search nums target)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec search(Nums :: [integer()], Target :: integer()) -> integer().\nsearch(Nums, Target) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec search(nums :: [integer], target :: integer) :: integer\n  def search(nums, target) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "34",
    "title": "Find First and Last Position of Element in Sorted Array",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1, -1].\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "nums = [5,7,7,8,8,10], target = 8",
        "output": "[3,4]",
        "explanation": "",
        "images": []
      },
      {
        "input": "nums = [5,7,7,8,8,10], target = 6",
        "output": "[-1,-1]",
        "explanation": "",
        "images": []
      },
      {
        "input": "nums = [], target = 0",
        "output": "[-1,-1]",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "0 <= nums.length <= 105",
      "-109 <= nums[i] <= 109",
      "nums is a non-decreasing array.",
      "-109 <= target <= 109"
    ],
    "frontendId": "34",
    "problemId": "34",
    "slug": "find-first-and-last-position-of-element-in-sorted-array",
    "topics": [
      "Array",
      "Binary Search"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* searchRange(int* nums, int numsSize, int target, int* returnSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int[] SearchRange(int[] nums, int target) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar searchRange = function(nums, target) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function searchRange(nums: number[], target: number): number[] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer[]\n     */\n    function searchRange($nums, $target) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func searchRange(_ nums: [Int], _ target: Int) -> [Int] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun searchRange(nums: IntArray, target: Int): IntArray {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<int> searchRange(List<int> nums, int target) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func searchRange(nums []int, target int) []int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer[]}\ndef search_range(nums, target)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def searchRange(nums: Array[Int], target: Int): Array[Int] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (search-range nums target)\n  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec search_range(Nums :: [integer()], Target :: integer()) -> [integer()].\nsearch_range(Nums, Target) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec search_range(nums :: [integer], target :: integer) :: [integer]\n  def search_range(nums, target) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "35",
    "title": "Search Insert Position",
    "difficulty": "Easy",
    "category": "Array",
    "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "nums = [1,3,5,6], target = 5",
        "output": "2",
        "explanation": "",
        "images": []
      },
      {
        "input": "nums = [1,3,5,6], target = 2",
        "output": "1",
        "explanation": "",
        "images": []
      },
      {
        "input": "nums = [1,3,5,6], target = 7",
        "output": "4",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= nums.length <= 104",
      "-104 <= nums[i] <= 104",
      "nums contains distinct values sorted in ascending order.",
      "-104 <= target <= 104"
    ],
    "frontendId": "35",
    "problemId": "35",
    "slug": "search-insert-position",
    "topics": [
      "Array",
      "Binary Search"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int searchInsert(int* nums, int numsSize, int target) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int SearchInsert(int[] nums, int target) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function searchInsert(nums: number[], target: number): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer\n     */\n    function searchInsert($nums, $target) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func searchInsert(_ nums: [Int], _ target: Int) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun searchInsert(nums: IntArray, target: Int): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int searchInsert(List<int> nums, int target) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func searchInsert(nums []int, target int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer}\ndef search_insert(nums, target)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def searchInsert(nums: Array[Int], target: Int): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn search_insert(nums: Vec<i32>, target: i32) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (search-insert nums target)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec search_insert(Nums :: [integer()], Target :: integer()) -> integer().\nsearch_insert(Nums, Target) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec search_insert(nums :: [integer], target :: integer) :: integer\n  def search_insert(nums, target) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 100
  },
  {
    "numId": "36",
    "title": "Valid Sudoku",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\nNote:\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "board =",
        "output": "true",
        "explanation": "",
        "images": [
          "https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"
        ]
      },
      {
        "input": "board =",
        "output": "false",
        "explanation": "Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.",
        "images": [
          "https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "board.length == 9",
      "board[i].length == 9",
      "board[i][j] is a digit 1-9 or '.'."
    ],
    "frontendId": "36",
    "problemId": "36",
    "slug": "valid-sudoku",
    "topics": [
      "Array",
      "Hash Table",
      "Matrix"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    bool isValidSudoku(vector<vector<char>>& board) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        "
      },
      "c": {
        "name": "c",
        "code": "bool isValidSudoku(char** board, int boardSize, int* boardColSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public bool IsValidSudoku(char[][] board) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {character[][]} board\n * @return {boolean}\n */\nvar isValidSudoku = function(board) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function isValidSudoku(board: string[][]): boolean {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String[][] $board\n     * @return Boolean\n     */\n    function isValidSudoku($board) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun isValidSudoku(board: Array<CharArray>): Boolean {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  bool isValidSudoku(List<List<String>> board) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func isValidSudoku(board [][]byte) bool {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Character[][]} board\n# @return {Boolean}\ndef is_valid_sudoku(board)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def isValidSudoku(board: Array[Array[Char]]): Boolean = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (is-valid-sudoku board)\n  (-> (listof (listof char?)) boolean?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec is_valid_sudoku(Board :: [[char()]]) -> boolean().\nis_valid_sudoku(Board) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec is_valid_sudoku(board :: [[char]]) :: boolean\n  def is_valid_sudoku(board) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "37",
    "title": "Sudoku Solver",
    "difficulty": "Hard",
    "category": "Array",
    "description": "Write a program to solve a Sudoku puzzle by filling the empty cells.\nA sudoku solution must satisfy all of the following rules:\nThe '.' character indicates empty cells.\nExample 1:\nConstraints:",
    "examples": [
      {
        "input": "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
        "output": "[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]",
        "explanation": "The input board is shown above and the only valid solution is shown below:",
        "images": [
          "https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "board.length == 9",
      "board[i].length == 9",
      "board[i][j] is a digit or '.'.",
      "It is guaranteed that the input board has only one solution."
    ],
    "frontendId": "37",
    "problemId": "37",
    "slug": "sudoku-solver",
    "topics": [
      "Array",
      "Hash Table",
      "Backtracking",
      "Matrix"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    void solveSudoku(vector<vector<char>>& board) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public void solveSudoku(char[][] board) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        "
      },
      "c": {
        "name": "c",
        "code": "void solveSudoku(char** board, int boardSize, int* boardColSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public void SolveSudoku(char[][] board) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar solveSudoku = function(board) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n Do not return anything, modify board in-place instead.\n */\nfunction solveSudoku(board: string[][]): void {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String[][] $board\n     * @return NULL\n     */\n    function solveSudoku(&$board) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func solveSudoku(_ board: inout [[Character]]) {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun solveSudoku(board: Array<CharArray>): Unit {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  void solveSudoku(List<List<String>> board) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func solveSudoku(board [][]byte)  {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Character[][]} board\n# @return {Void} Do not return anything, modify board in-place instead.\ndef solve_sudoku(board)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def solveSudoku(board: Array[Array[Char]]): Unit = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn solve_sudoku(board: &mut Vec<Vec<char>>) {\n        \n    }\n}"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 260
  },
  {
    "numId": "38",
    "title": "Count and Say",
    "difficulty": "Medium",
    "category": "String",
    "description": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\nRun-length encoding (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string \"3322251\" we replace \"33\" with \"23\", replace \"222\" with \"32\", replace \"5\" with \"15\" and replace \"1\" with \"11\". Thus the compressed string becomes \"23321511\".\nGiven a positive integer n, return the nth element of the count-and-say sequence.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [],
    "privateTests": [],
    "constraints": [
      "1 <= n <= 30"
    ],
    "frontendId": "38",
    "problemId": "38",
    "slug": "count-and-say",
    "topics": [
      "String"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    string countAndSay(int n) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public String countAndSay(int n) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        "
      },
      "c": {
        "name": "c",
        "code": "char* countAndSay(int n) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public string CountAndSay(int n) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number} n\n * @return {string}\n */\nvar countAndSay = function(n) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function countAndSay(n: number): string {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return String\n     */\n    function countAndSay($n) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func countAndSay(_ n: Int) -> String {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun countAndSay(n: Int): String {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  String countAndSay(int n) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func countAndSay(n int) string {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer} n\n# @return {String}\ndef count_and_say(n)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def countAndSay(n: Int): String = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn count_and_say(n: i32) -> String {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (count-and-say n)\n  (-> exact-integer? string?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec count_and_say(N :: integer()) -> unicode:unicode_binary().\ncount_and_say(N) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec count_and_say(n :: integer) :: String.t\n  def count_and_say(n) do\n    \n  end\nend"
      }
    },
    "hints": [
      "Create a helper function that maps an integer to pairs of its digits and their frequencies. For example, if you call this function with \"223314444411\", then it maps it to an array of pairs [[2,2], [3,2], [1,1], [4,5], [1, 2]].",
      "Create another helper function that takes the array of pairs and creates a new integer. For example, if you call this function with [[2,2], [3,2], [1,1], [4,5], [1, 2]], it should create \"22\"+\"23\"+\"11\"+\"54\"+\"21\" = \"2223115421\".",
      "Now, with the two helper functions, you can start with \"1\" and call the two functions alternatively n-1 times. The answer is the last integer you will obtain."
    ],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "39",
    "title": "Combination Sum",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "candidates = [2,3,6,7], target = 7",
        "output": "[[2,2,3],[7]]",
        "explanation": "2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.",
        "images": []
      },
      {
        "input": "candidates = [2,3,5], target = 8",
        "output": "[[2,2,2,2],[2,3,3],[3,5]]",
        "explanation": "",
        "images": []
      },
      {
        "input": "candidates = [2], target = 1",
        "output": "[]",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= candidates.length <= 30",
      "2 <= candidates[i] <= 40",
      "All elements of candidates are distinct.",
      "1 <= target <= 40"
    ],
    "frontendId": "39",
    "problemId": "39",
    "slug": "combination-sum",
    "topics": [
      "Array",
      "Backtracking"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** combinationSum(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public IList<IList<int>> CombinationSum(int[] candidates, int target) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum = function(candidates, target) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function combinationSum(candidates: number[], target: number): number[][] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $candidates\n     * @param Integer $target\n     * @return Integer[][]\n     */\n    function combinationSum($candidates, $target) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun combinationSum(candidates: IntArray, target: Int): List<List<Int>> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<List<int>> combinationSum(List<int> candidates, int target) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func combinationSum(candidates []int, target int) [][]int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} candidates\n# @param {Integer} target\n# @return {Integer[][]}\ndef combination_sum(candidates, target)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn combination_sum(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (combination-sum candidates target)\n  (-> (listof exact-integer?) exact-integer? (listof (listof exact-integer?)))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec combination_sum(Candidates :: [integer()], Target :: integer()) -> [[integer()]].\ncombination_sum(Candidates, Target) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec combination_sum(candidates :: [integer], target :: integer) :: [[integer]]\n  def combination_sum(candidates, target) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "40",
    "title": "Combination Sum II",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\nEach number in candidates may only be used once in the combination.\nNote: The solution set must not contain duplicate combinations.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "candidates = [10,1,2,7,6,1,5], target = 8",
        "output": "[",
        "explanation": "",
        "images": []
      },
      {
        "input": "candidates = [2,5,2,1,2], target = 5",
        "output": "[",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= candidates.length <= 100",
      "1 <= candidates[i] <= 50",
      "1 <= target <= 30"
    ],
    "frontendId": "40",
    "problemId": "40",
    "slug": "combination-sum-ii",
    "topics": [
      "Array",
      "Backtracking"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public IList<IList<int>> CombinationSum2(int[] candidates, int target) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum2 = function(candidates, target) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function combinationSum2(candidates: number[], target: number): number[][] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $candidates\n     * @param Integer $target\n     * @return Integer[][]\n     */\n    function combinationSum2($candidates, $target) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun combinationSum2(candidates: IntArray, target: Int): List<List<Int>> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<List<int>> combinationSum2(List<int> candidates, int target) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func combinationSum2(candidates []int, target int) [][]int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} candidates\n# @param {Integer} target\n# @return {Integer[][]}\ndef combination_sum2(candidates, target)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def combinationSum2(candidates: Array[Int], target: Int): List[List[Int]] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn combination_sum2(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (combination-sum2 candidates target)\n  (-> (listof exact-integer?) exact-integer? (listof (listof exact-integer?)))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec combination_sum2(Candidates :: [integer()], Target :: integer()) -> [[integer()]].\ncombination_sum2(Candidates, Target) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec combination_sum2(candidates :: [integer], target :: integer) :: [[integer]]\n  def combination_sum2(candidates, target) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "41",
    "title": "First Missing Positive",
    "difficulty": "Hard",
    "category": "Array",
    "description": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.\nYou must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "nums = [1,2,0]",
        "output": "3",
        "explanation": "The numbers in the range [1,2] are all in the array.",
        "images": []
      },
      {
        "input": "nums = [3,4,-1,1]",
        "output": "2",
        "explanation": "1 is in the array but 2 is missing.",
        "images": []
      },
      {
        "input": "nums = [7,8,9,11,12]",
        "output": "1",
        "explanation": "The smallest positive integer 1 is missing.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= nums.length <= 105",
      "-231 <= nums[i] <= 231 - 1"
    ],
    "frontendId": "41",
    "problemId": "41",
    "slug": "first-missing-positive",
    "topics": [
      "Array",
      "Hash Table"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int firstMissingPositive(int[] nums) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int firstMissingPositive(int* nums, int numsSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int FirstMissingPositive(int[] nums) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar firstMissingPositive = function(nums) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function firstMissingPositive(nums: number[]): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function firstMissingPositive($nums) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func firstMissingPositive(_ nums: [Int]) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun firstMissingPositive(nums: IntArray): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int firstMissingPositive(List<int> nums) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func firstMissingPositive(nums []int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef first_missing_positive(nums)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def firstMissingPositive(nums: Array[Int]): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn first_missing_positive(nums: Vec<i32>) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (first-missing-positive nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec first_missing_positive(Nums :: [integer()]) -> integer().\nfirst_missing_positive(Nums) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec first_missing_positive(nums :: [integer]) :: integer\n  def first_missing_positive(nums) do\n    \n  end\nend"
      }
    },
    "hints": [
      "Think about how you would solve the problem in non-constant space.  Can you apply that logic to the existing space?",
      "We don't care about duplicates or non-positive integers",
      "Remember that O(2n) = O(n)"
    ],
    "acceptance": 0,
    "points": 260
  },
  {
    "numId": "42",
    "title": "Trapping Rain Water",
    "difficulty": "Hard",
    "category": "Array",
    "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.",
        "images": [
          "https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png"
        ]
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "n == height.length",
      "1 <= n <= 2 * 104",
      "0 <= height[i] <= 105"
    ],
    "frontendId": "42",
    "problemId": "42",
    "slug": "trapping-rain-water",
    "topics": [
      "Array",
      "Two Pointers",
      "Dynamic Programming",
      "Stack",
      "Monotonic Stack"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int trap(vector<int>& height) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int trap(int[] height) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int trap(int* height, int heightSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int Trap(int[] height) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} height\n * @return {number}\n */\nvar trap = function(height) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function trap(height: number[]): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $height\n     * @return Integer\n     */\n    function trap($height) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func trap(_ height: [Int]) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun trap(height: IntArray): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int trap(List<int> height) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func trap(height []int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} height\n# @return {Integer}\ndef trap(height)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def trap(height: Array[Int]): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn trap(height: Vec<i32>) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (trap height)\n  (-> (listof exact-integer?) exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec trap(Height :: [integer()]) -> integer().\ntrap(Height) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec trap(height :: [integer]) :: integer\n  def trap(height) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 260
  },
  {
    "numId": "43",
    "title": "Multiply Strings",
    "difficulty": "Medium",
    "category": "Math",
    "description": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "num1 = \"2\", num2 = \"3\"",
        "output": "\"6\"",
        "explanation": "",
        "images": []
      },
      {
        "input": "num1 = \"123\", num2 = \"456\"",
        "output": "\"56088\"",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= num1.length, num2.length <= 200",
      "num1 and num2 consist of digits only.",
      "Both num1 and num2 do not contain any leading zero, except the number 0 itself."
    ],
    "frontendId": "43",
    "problemId": "43",
    "slug": "multiply-strings",
    "topics": [
      "Math",
      "String",
      "Simulation"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public String multiply(String num1, String num2) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        "
      },
      "c": {
        "name": "c",
        "code": "char* multiply(char* num1, char* num2) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public string Multiply(string num1, string num2) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\nvar multiply = function(num1, num2) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function multiply(num1: string, num2: string): string {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $num1\n     * @param String $num2\n     * @return String\n     */\n    function multiply($num1, $num2) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func multiply(_ num1: String, _ num2: String) -> String {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun multiply(num1: String, num2: String): String {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  String multiply(String num1, String num2) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func multiply(num1 string, num2 string) string {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} num1\n# @param {String} num2\n# @return {String}\ndef multiply(num1, num2)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def multiply(num1: String, num2: String): String = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn multiply(num1: String, num2: String) -> String {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (multiply num1 num2)\n  (-> string? string? string?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec multiply(Num1 :: unicode:unicode_binary(), Num2 :: unicode:unicode_binary()) -> unicode:unicode_binary().\nmultiply(Num1, Num2) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec multiply(num1 :: String.t, num2 :: String.t) :: String.t\n  def multiply(num1, num2) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "44",
    "title": "Wildcard Matching",
    "difficulty": "Hard",
    "category": "String",
    "description": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\nThe matching should cover the entire input string (not partial).\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "s = \"aa\", p = \"a\"",
        "output": "false",
        "explanation": "\"a\" does not match the entire string \"aa\".",
        "images": []
      },
      {
        "input": "s = \"aa\", p = \"*\"",
        "output": "true",
        "explanation": "'*' matches any sequence.",
        "images": []
      },
      {
        "input": "s = \"cb\", p = \"?a\"",
        "output": "false",
        "explanation": "'?' matches 'c', but the second letter is 'a', which does not match 'b'.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "0 <= s.length, p.length <= 2000",
      "s contains only lowercase English letters.",
      "p contains only lowercase English letters, '?' or '*'."
    ],
    "frontendId": "44",
    "problemId": "44",
    "slug": "wildcard-matching",
    "topics": [
      "String",
      "Dynamic Programming",
      "Greedy",
      "Recursion"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public boolean isMatch(String s, String p) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        "
      },
      "c": {
        "name": "c",
        "code": "bool isMatch(char* s, char* p) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public bool IsMatch(string s, string p) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} s\n * @param {string} p\n * @return {boolean}\n */\nvar isMatch = function(s, p) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function isMatch(s: string, p: string): boolean {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String $p\n     * @return Boolean\n     */\n    function isMatch($s, $p) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func isMatch(_ s: String, _ p: String) -> Bool {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun isMatch(s: String, p: String): Boolean {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  bool isMatch(String s, String p) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func isMatch(s string, p string) bool {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} s\n# @param {String} p\n# @return {Boolean}\ndef is_match(s, p)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def isMatch(s: String, p: String): Boolean = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn is_match(s: String, p: String) -> bool {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (is-match s p)\n  (-> string? string? boolean?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec is_match(S :: unicode:unicode_binary(), P :: unicode:unicode_binary()) -> boolean().\nis_match(S, P) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec is_match(s :: String.t, p :: String.t) :: boolean\n  def is_match(s, p) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 260
  },
  {
    "numId": "45",
    "title": "Jump Game II",
    "difficulty": "Medium",
    "category": "Array",
    "description": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\nReturn the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "nums = [2,3,1,1,4]",
        "output": "2",
        "explanation": "The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.",
        "images": []
      },
      {
        "input": "nums = [2,3,0,1,4]",
        "output": "2",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= nums.length <= 104",
      "0 <= nums[i] <= 1000",
      "It's guaranteed that you can reach nums[n - 1]."
    ],
    "frontendId": "45",
    "problemId": "45",
    "slug": "jump-game-ii",
    "topics": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int jump(vector<int>& nums) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int jump(int[] nums) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int jump(int* nums, int numsSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int Jump(int[] nums) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar jump = function(nums) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function jump(nums: number[]): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function jump($nums) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func jump(_ nums: [Int]) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun jump(nums: IntArray): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int jump(List<int> nums) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func jump(nums []int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef jump(nums)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def jump(nums: Array[Int]): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn jump(nums: Vec<i32>) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (jump nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec jump(Nums :: [integer()]) -> integer().\njump(Nums) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec jump(nums :: [integer]) :: integer\n  def jump(nums) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "46",
    "title": "Permutations",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "nums = [1,2,3]",
        "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "explanation": "",
        "images": []
      },
      {
        "input": "nums = [0,1]",
        "output": "[[0,1],[1,0]]",
        "explanation": "",
        "images": []
      },
      {
        "input": "nums = [1]",
        "output": "[[1]]",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= nums.length <= 6",
      "-10 <= nums[i] <= 10",
      "All the integers of nums are unique."
    ],
    "frontendId": "46",
    "problemId": "46",
    "slug": "permutations",
    "topics": [
      "Array",
      "Backtracking"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public IList<IList<int>> Permute(int[] nums) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permute = function(nums) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function permute(nums: number[]): number[][] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[][]\n     */\n    function permute($nums) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func permute(_ nums: [Int]) -> [[Int]] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun permute(nums: IntArray): List<List<Int>> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<List<int>> permute(List<int> nums) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func permute(nums []int) [][]int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @return {Integer[][]}\ndef permute(nums)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def permute(nums: Array[Int]): List[List[Int]] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn permute(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (permute nums)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec permute(Nums :: [integer()]) -> [[integer()]].\npermute(Nums) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec permute(nums :: [integer]) :: [[integer]]\n  def permute(nums) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "47",
    "title": "Permutations II",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "nums = [1,1,2]",
        "output": "[[1,1,2],",
        "explanation": "",
        "images": []
      },
      {
        "input": "nums = [1,2,3]",
        "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= nums.length <= 8",
      "-10 <= nums[i] <= 10"
    ],
    "frontendId": "47",
    "problemId": "47",
    "slug": "permutations-ii",
    "topics": [
      "Array",
      "Backtracking",
      "Sorting"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** permuteUnique(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public IList<IList<int>> PermuteUnique(int[] nums) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permuteUnique = function(nums) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function permuteUnique(nums: number[]): number[][] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[][]\n     */\n    function permuteUnique($nums) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun permuteUnique(nums: IntArray): List<List<Int>> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<List<int>> permuteUnique(List<int> nums) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func permuteUnique(nums []int) [][]int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @return {Integer[][]}\ndef permute_unique(nums)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def permuteUnique(nums: Array[Int]): List[List[Int]] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (permute-unique nums)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec permute_unique(Nums :: [integer()]) -> [[integer()]].\npermute_unique(Nums) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec permute_unique(nums :: [integer]) :: [[integer]]\n  def permute_unique(nums) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "48",
    "title": "Rotate Image",
    "difficulty": "Medium",
    "category": "Array",
    "description": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[[7,4,1],[8,5,2],[9,6,3]]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg"
        ]
      },
      {
        "input": "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",
        "output": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "n == matrix.length == matrix[i].length",
      "1 <= n <= 20",
      "-1000 <= matrix[i][j] <= 1000"
    ],
    "frontendId": "48",
    "problemId": "48",
    "slug": "rotate-image",
    "topics": [
      "Array",
      "Math",
      "Matrix"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public void rotate(int[][] matrix) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        "
      },
      "c": {
        "name": "c",
        "code": "void rotate(int** matrix, int matrixSize, int* matrixColSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public void Rotate(int[][] matrix) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nvar rotate = function(matrix) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n Do not return anything, modify matrix in-place instead.\n */\nfunction rotate(matrix: number[][]): void {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[][] $matrix\n     * @return NULL\n     */\n    function rotate(&$matrix) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func rotate(_ matrix: inout [[Int]]) {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun rotate(matrix: Array<IntArray>): Unit {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  void rotate(List<List<int>> matrix) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func rotate(matrix [][]int)  {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[][]} matrix\n# @return {Void} Do not return anything, modify matrix in-place instead.\ndef rotate(matrix)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def rotate(matrix: Array[Array[Int]]): Unit = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {\n        \n    }\n}"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "49",
    "title": "Group Anagrams",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "explanation": "",
        "images": []
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "",
        "images": []
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= strs.length <= 104",
      "0 <= strs[i].length <= 100",
      "strs[i] consists of lowercase English letters."
    ],
    "frontendId": "49",
    "problemId": "49",
    "slug": "group-anagrams",
    "topics": [
      "Array",
      "Hash Table",
      "String",
      "Sorting"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nchar*** groupAnagrams(char** strs, int strsSize, int* returnSize, int** returnColumnSizes) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string[]} strs\n * @return {string[][]}\n */\nvar groupAnagrams = function(strs) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function groupAnagrams(strs: string[]): string[][] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String[] $strs\n     * @return String[][]\n     */\n    function groupAnagrams($strs) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun groupAnagrams(strs: Array<String>): List<List<String>> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<List<String>> groupAnagrams(List<String> strs) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func groupAnagrams(strs []string) [][]string {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String[]} strs\n# @return {String[][]}\ndef group_anagrams(strs)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def groupAnagrams(strs: Array[String]): List[List[String]] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (group-anagrams strs)\n  (-> (listof string?) (listof (listof string?)))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec group_anagrams(Strs :: [unicode:unicode_binary()]) -> [[unicode:unicode_binary()]].\ngroup_anagrams(Strs) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec group_anagrams(strs :: [String.t]) :: [[String.t]]\n  def group_anagrams(strs) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "50",
    "title": "Pow(x, n)",
    "difficulty": "Medium",
    "category": "Math",
    "description": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "x = 2.00000, n = 10",
        "output": "1024.00000",
        "explanation": "",
        "images": []
      },
      {
        "input": "x = 2.10000, n = 3",
        "output": "9.26100",
        "explanation": "",
        "images": []
      },
      {
        "input": "x = 2.00000, n = -2",
        "output": "0.25000",
        "explanation": "2-2 = 1/22 = 1/4 = 0.25",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "-100.0 < x < 100.0",
      "-231 <= n <= 231-1",
      "n is an integer.",
      "Either x is not zero or n > 0.",
      "-104 <= xn <= 104"
    ],
    "frontendId": "50",
    "problemId": "50",
    "slug": "powx-n",
    "topics": [
      "Math",
      "Recursion"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    double myPow(double x, int n) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public double myPow(double x, int n) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        "
      },
      "c": {
        "name": "c",
        "code": "double myPow(double x, int n) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public double MyPow(double x, int n) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number} x\n * @param {number} n\n * @return {number}\n */\nvar myPow = function(x, n) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function myPow(x: number, n: number): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Float $x\n     * @param Integer $n\n     * @return Float\n     */\n    function myPow($x, $n) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func myPow(_ x: Double, _ n: Int) -> Double {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun myPow(x: Double, n: Int): Double {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  double myPow(double x, int n) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func myPow(x float64, n int) float64 {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Float} x\n# @param {Integer} n\n# @return {Float}\ndef my_pow(x, n)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def myPow(x: Double, n: Int): Double = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn my_pow(x: f64, n: i32) -> f64 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (my-pow x n)\n  (-> flonum? exact-integer? flonum?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec my_pow(X :: float(), N :: integer()) -> float().\nmy_pow(X, N) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec my_pow(x :: float, n :: integer) :: float\n  def my_pow(x, n) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "51",
    "title": "N-Queens",
    "difficulty": "Hard",
    "category": "Array",
    "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "n = 4",
        "output": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]",
        "explanation": "There exist two distinct solutions to the 4-queens puzzle as shown above",
        "images": [
          "https://assets.leetcode.com/uploads/2020/11/13/queens.jpg"
        ]
      },
      {
        "input": "n = 1",
        "output": "[[\"Q\"]]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/11/13/queens.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= n <= 9"
    ],
    "frontendId": "51",
    "problemId": "51",
    "slug": "n-queens",
    "topics": [
      "Array",
      "Backtracking"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<vector<string>> solveNQueens(int n) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public List<List<String>> solveNQueens(int n) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nchar*** solveNQueens(int n, int* returnSize, int** returnColumnSizes) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public IList<IList<string>> SolveNQueens(int n) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number} n\n * @return {string[][]}\n */\nvar solveNQueens = function(n) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function solveNQueens(n: number): string[][] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return String[][]\n     */\n    function solveNQueens($n) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func solveNQueens(_ n: Int) -> [[String]] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun solveNQueens(n: Int): List<List<String>> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<List<String>> solveNQueens(int n) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func solveNQueens(n int) [][]string {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer} n\n# @return {String[][]}\ndef solve_n_queens(n)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def solveNQueens(n: Int): List[List[String]] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn solve_n_queens(n: i32) -> Vec<Vec<String>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (solve-n-queens n)\n  (-> exact-integer? (listof (listof string?)))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec solve_n_queens(N :: integer()) -> [[unicode:unicode_binary()]].\nsolve_n_queens(N) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec solve_n_queens(n :: integer) :: [[String.t]]\n  def solve_n_queens(n) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 260
  },
  {
    "numId": "52",
    "title": "N-Queens II",
    "difficulty": "Hard",
    "category": "Backtracking",
    "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to the n-queens puzzle.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "n = 4",
        "output": "2",
        "explanation": "There are two distinct solutions to the 4-queens puzzle as shown.",
        "images": [
          "https://assets.leetcode.com/uploads/2020/11/13/queens.jpg"
        ]
      },
      {
        "input": "n = 1",
        "output": "1",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/11/13/queens.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= n <= 9"
    ],
    "frontendId": "52",
    "problemId": "52",
    "slug": "n-queens-ii",
    "topics": [
      "Backtracking"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int totalNQueens(int n) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int totalNQueens(int n) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int totalNQueens(int n) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int TotalNQueens(int n) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar totalNQueens = function(n) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function totalNQueens(n: number): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function totalNQueens($n) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func totalNQueens(_ n: Int) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun totalNQueens(n: Int): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int totalNQueens(int n) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func totalNQueens(n int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer} n\n# @return {Integer}\ndef total_n_queens(n)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def totalNQueens(n: Int): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn total_n_queens(n: i32) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (total-n-queens n)\n  (-> exact-integer? exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec total_n_queens(N :: integer()) -> integer().\ntotal_n_queens(N) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec total_n_queens(n :: integer) :: integer\n  def total_n_queens(n) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 260
  },
  {
    "numId": "53",
    "title": "Maximum Subarray",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.",
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum 6.",
        "images": []
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The subarray [1] has the largest sum 1.",
        "images": []
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The subarray [5,4,-1,7,8] has the largest sum 23.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= nums.length <= 105",
      "-104 <= nums[i] <= 104"
    ],
    "frontendId": "53",
    "problemId": "53",
    "slug": "maximum-subarray",
    "topics": [
      "Array",
      "Divide and Conquer",
      "Dynamic Programming"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int maxSubArray(int* nums, int numsSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int MaxSubArray(int[] nums) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function(nums) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function maxSubArray(nums: number[]): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maxSubArray($nums) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func maxSubArray(_ nums: [Int]) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun maxSubArray(nums: IntArray): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int maxSubArray(List<int> nums) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func maxSubArray(nums []int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef max_sub_array(nums)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def maxSubArray(nums: Array[Int]): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn max_sub_array(nums: Vec<i32>) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (max-sub-array nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec max_sub_array(Nums :: [integer()]) -> integer().\nmax_sub_array(Nums) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec max_sub_array(nums :: [integer]) :: integer\n  def max_sub_array(nums) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "54",
    "title": "Spiral Matrix",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an m x n matrix, return all elements of the matrix in spiral order.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[1,2,3,6,9,8,7,4,5]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg"
        ]
      },
      {
        "input": "matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]",
        "output": "[1,2,3,4,8,12,11,10,9,5,6,7]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 10",
      "-100 <= matrix[i][j] <= 100"
    ],
    "frontendId": "54",
    "problemId": "54",
    "slug": "spiral-matrix",
    "topics": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public IList<int> SpiralOrder(int[][] matrix) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\nvar spiralOrder = function(matrix) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function spiralOrder(matrix: number[][]): number[] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[][] $matrix\n     * @return Integer[]\n     */\n    function spiralOrder($matrix) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func spiralOrder(_ matrix: [[Int]]) -> [Int] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun spiralOrder(matrix: Array<IntArray>): List<Int> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<int> spiralOrder(List<List<int>> matrix) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func spiralOrder(matrix [][]int) []int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[][]} matrix\n# @return {Integer[]}\ndef spiral_order(matrix)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def spiralOrder(matrix: Array[Array[Int]]): List[Int] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn spiral_order(matrix: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (spiral-order matrix)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec spiral_order(Matrix :: [[integer()]]) -> [integer()].\nspiral_order(Matrix) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec spiral_order(matrix :: [[integer]]) :: [integer]\n  def spiral_order(matrix) do\n    \n  end\nend"
      }
    },
    "hints": [
      "Well for some problems, the best way really is to come up with some algorithms for simulation. Basically, you need to simulate what the problem asks us to do.",
      "We go boundary by boundary and move inwards. That is the essential operation. First row, last column, last row, first column, and then we move inwards by 1 and repeat. That's all. That is all the simulation that we need.",
      "Think about when you want to switch the progress on one of the indexes. If you progress on i out of [i, j], you'll shift in the same column. Similarly, by changing values for j, you'd be shifting in the same row.\r\nAlso, keep track of the end of a boundary so that you can move inwards and then keep repeating. It's always best to simulate edge cases like a single column or a single row to see if anything breaks or not."
    ],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "55",
    "title": "Jump Game",
    "difficulty": "Medium",
    "category": "Array",
    "description": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "nums = [2,3,1,1,4]",
        "output": "true",
        "explanation": "Jump 1 step from index 0 to 1, then 3 steps to the last index.",
        "images": []
      },
      {
        "input": "nums = [3,2,1,0,4]",
        "output": "false",
        "explanation": "You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= nums.length <= 104",
      "0 <= nums[i] <= 105"
    ],
    "frontendId": "55",
    "problemId": "55",
    "slug": "jump-game",
    "topics": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public boolean canJump(int[] nums) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        "
      },
      "c": {
        "name": "c",
        "code": "bool canJump(int* nums, int numsSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public bool CanJump(int[] nums) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canJump = function(nums) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function canJump(nums: number[]): boolean {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Boolean\n     */\n    function canJump($nums) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func canJump(_ nums: [Int]) -> Bool {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun canJump(nums: IntArray): Boolean {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  bool canJump(List<int> nums) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func canJump(nums []int) bool {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @return {Boolean}\ndef can_jump(nums)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def canJump(nums: Array[Int]): Boolean = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn can_jump(nums: Vec<i32>) -> bool {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (can-jump nums)\n  (-> (listof exact-integer?) boolean?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec can_jump(Nums :: [integer()]) -> boolean().\ncan_jump(Nums) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec can_jump(nums :: [integer]) :: boolean\n  def can_jump(nums) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "56",
    "title": "Merge Intervals",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "Since intervals [1,3] and [2,6] overlap, merge them into [1,6].",
        "images": []
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "Intervals [1,4] and [4,5] are considered overlapping.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= intervals.length <= 104",
      "intervals[i].length == 2",
      "0 <= starti <= endi <= 104"
    ],
    "frontendId": "56",
    "problemId": "56",
    "slug": "merge-intervals",
    "topics": [
      "Array",
      "Sorting"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int[][] Merge(int[][] intervals) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[][]} intervals\n * @return {number[][]}\n */\nvar merge = function(intervals) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function merge(intervals: number[][]): number[][] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[][] $intervals\n     * @return Integer[][]\n     */\n    function merge($intervals) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func merge(_ intervals: [[Int]]) -> [[Int]] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun merge(intervals: Array<IntArray>): Array<IntArray> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<List<int>> merge(List<List<int>> intervals) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func merge(intervals [][]int) [][]int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[][]} intervals\n# @return {Integer[][]}\ndef merge(intervals)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def merge(intervals: Array[Array[Int]]): Array[Array[Int]] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn merge(intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (merge intervals)\n  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec merge(Intervals :: [[integer()]]) -> [[integer()]].\nmerge(Intervals) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec merge(intervals :: [[integer]]) :: [[integer]]\n  def merge(intervals) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "57",
    "title": "Insert Interval",
    "difficulty": "Medium",
    "category": "Array",
    "description": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\nReturn intervals after the insertion.\nNote that you don't need to modify intervals in-place. You can make a new array and return it.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
        "output": "[[1,5],[6,9]]",
        "explanation": "",
        "images": []
      },
      {
        "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
        "output": "[[1,2],[3,10],[12,16]]",
        "explanation": "Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "0 <= intervals.length <= 104",
      "intervals[i].length == 2",
      "0 <= starti <= endi <= 105",
      "intervals is sorted by starti in ascending order.",
      "newInterval.length == 2",
      "0 <= start <= end <= 105"
    ],
    "frontendId": "57",
    "problemId": "57",
    "slug": "insert-interval",
    "topics": [
      "Array"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** insert(int** intervals, int intervalsSize, int* intervalsColSize, int* newInterval, int newIntervalSize, int* returnSize, int** returnColumnSizes) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int[][] Insert(int[][] intervals, int[] newInterval) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[][]} intervals\n * @param {number[]} newInterval\n * @return {number[][]}\n */\nvar insert = function(intervals, newInterval) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function insert(intervals: number[][], newInterval: number[]): number[][] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[][] $intervals\n     * @param Integer[] $newInterval\n     * @return Integer[][]\n     */\n    function insert($intervals, $newInterval) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun insert(intervals: Array<IntArray>, newInterval: IntArray): Array<IntArray> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<List<int>> insert(List<List<int>> intervals, List<int> newInterval) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func insert(intervals [][]int, newInterval []int) [][]int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[][]} intervals\n# @param {Integer[]} new_interval\n# @return {Integer[][]}\ndef insert(intervals, new_interval)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def insert(intervals: Array[Array[Int]], newInterval: Array[Int]): Array[Array[Int]] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (insert intervals newInterval)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?) (listof (listof exact-integer?)))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec insert(Intervals :: [[integer()]], NewInterval :: [integer()]) -> [[integer()]].\ninsert(Intervals, NewInterval) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec insert(intervals :: [[integer]], new_interval :: [integer]) :: [[integer]]\n  def insert(intervals, new_interval) do\n    \n  end\nend"
      }
    },
    "hints": [
      "Intervals Array is sorted. Can you use Binary Search to find the correct position to insert the new Interval.?",
      "Can you try merging the overlapping intervals while inserting the new interval?",
      "This can be done by comparing the end of the last interval with the start of the new interval and vice versa."
    ],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "58",
    "title": "Length of Last Word",
    "difficulty": "Easy",
    "category": "String",
    "description": "Given a string s consisting of words and spaces, return the length of the last word in the string.\nA word is a maximal substring consisting of non-space characters only.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "s = \"Hello World\"",
        "output": "5",
        "explanation": "The last word is \"World\" with length 5.",
        "images": []
      },
      {
        "input": "s = \"   fly me   to   the moon  \"",
        "output": "4",
        "explanation": "The last word is \"moon\" with length 4.",
        "images": []
      },
      {
        "input": "s = \"luffy is still joyboy\"",
        "output": "6",
        "explanation": "The last word is \"joyboy\" with length 6.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= s.length <= 104",
      "s consists of only English letters and spaces ' '.",
      "There will be at least one word in s."
    ],
    "frontendId": "58",
    "problemId": "58",
    "slug": "length-of-last-word",
    "topics": [
      "String"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int lengthOfLastWord(string s) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int lengthOfLastWord(String s) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int lengthOfLastWord(char* s) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int LengthOfLastWord(string s) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLastWord = function(s) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function lengthOfLastWord(s: string): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function lengthOfLastWord($s) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func lengthOfLastWord(_ s: String) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun lengthOfLastWord(s: String): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int lengthOfLastWord(String s) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func lengthOfLastWord(s string) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} s\n# @return {Integer}\ndef length_of_last_word(s)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def lengthOfLastWord(s: String): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn length_of_last_word(s: String) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (length-of-last-word s)\n  (-> string? exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec length_of_last_word(S :: unicode:unicode_binary()) -> integer().\nlength_of_last_word(S) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec length_of_last_word(s :: String.t) :: integer\n  def length_of_last_word(s) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 100
  },
  {
    "numId": "59",
    "title": "Spiral Matrix II",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "n = 3",
        "output": "[[1,2,3],[8,9,4],[7,6,5]]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg"
        ]
      },
      {
        "input": "n = 1",
        "output": "[[1]]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= n <= 20"
    ],
    "frontendId": "59",
    "problemId": "59",
    "slug": "spiral-matrix-ii",
    "topics": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int[][] generateMatrix(int n) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** generateMatrix(int n, int* returnSize, int** returnColumnSizes) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int[][] GenerateMatrix(int n) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number} n\n * @return {number[][]}\n */\nvar generateMatrix = function(n) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function generateMatrix(n: number): number[][] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer[][]\n     */\n    function generateMatrix($n) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func generateMatrix(_ n: Int) -> [[Int]] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun generateMatrix(n: Int): Array<IntArray> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<List<int>> generateMatrix(int n) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func generateMatrix(n int) [][]int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer} n\n# @return {Integer[][]}\ndef generate_matrix(n)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def generateMatrix(n: Int): Array[Array[Int]] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn generate_matrix(n: i32) -> Vec<Vec<i32>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (generate-matrix n)\n  (-> exact-integer? (listof (listof exact-integer?)))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec generate_matrix(N :: integer()) -> [[integer()]].\ngenerate_matrix(N) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec generate_matrix(n :: integer) :: [[integer]]\n  def generate_matrix(n) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "60",
    "title": "Permutation Sequence",
    "difficulty": "Hard",
    "category": "Math",
    "description": "The set [1, 2, 3, ..., n] contains a total of n! unique permutations.\nBy listing and labeling all of the permutations in order, we get the following sequence for n = 3:\nGiven n and k, return the kth permutation sequence.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "n = 3, k = 3",
        "output": "\"213\"",
        "explanation": "",
        "images": []
      },
      {
        "input": "n = 4, k = 9",
        "output": "\"2314\"",
        "explanation": "",
        "images": []
      },
      {
        "input": "n = 3, k = 1",
        "output": "\"123\"",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= n <= 9",
      "1 <= k <= n!"
    ],
    "frontendId": "60",
    "problemId": "60",
    "slug": "permutation-sequence",
    "topics": [
      "Math",
      "Recursion"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    string getPermutation(int n, int k) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public String getPermutation(int n, int k) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        "
      },
      "c": {
        "name": "c",
        "code": "char* getPermutation(int n, int k) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public string GetPermutation(int n, int k) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number} n\n * @param {number} k\n * @return {string}\n */\nvar getPermutation = function(n, k) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function getPermutation(n: number, k: number): string {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $k\n     * @return String\n     */\n    function getPermutation($n, $k) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func getPermutation(_ n: Int, _ k: Int) -> String {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun getPermutation(n: Int, k: Int): String {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  String getPermutation(int n, int k) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func getPermutation(n int, k int) string {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer} n\n# @param {Integer} k\n# @return {String}\ndef get_permutation(n, k)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def getPermutation(n: Int, k: Int): String = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn get_permutation(n: i32, k: i32) -> String {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (get-permutation n k)\n  (-> exact-integer? exact-integer? string?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec get_permutation(N :: integer(), K :: integer()) -> unicode:unicode_binary().\nget_permutation(N, K) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec get_permutation(n :: integer, k :: integer) :: String.t\n  def get_permutation(n, k) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 260
  },
  {
    "numId": "61",
    "title": "Rotate List",
    "difficulty": "Medium",
    "category": "Linked List",
    "description": "Given the head of a linked list, rotate the list to the right by k places.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "head = [1,2,3,4,5], k = 2",
        "output": "[4,5,1,2,3]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg"
        ]
      },
      {
        "input": "head = [0,1,2], k = 4",
        "output": "[2,0,1]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "The number of nodes in the list is in the range [0, 500].",
      "-100 <= Node.val <= 100",
      "0 <= k <= 2 * 109"
    ],
    "frontendId": "61",
    "problemId": "61",
    "slug": "rotate-list",
    "topics": [
      "Linked List",
      "Two Pointers"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type k: int\n        :rtype: Optional[ListNode]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* rotateRight(struct ListNode* head, int k) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode RotateRight(ListNode head, int k) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @param Integer $k\n     * @return ListNode\n     */\n    function rotateRight($head, $k) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun rotateRight(head: ListNode?, k: Int): ListNode? {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? rotateRight(ListNode? head, int k) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc rotateRight(head *ListNode, k int) *ListNode {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @param {Integer} k\n# @return {ListNode}\ndef rotate_right(head, k)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def rotateRight(head: ListNode, k: Int): ListNode = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn rotate_right(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (rotate-right head k)\n  (-> (or/c list-node? #f) exact-integer? (or/c list-node? #f))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec rotate_right(Head :: #list_node{} | null, K :: integer()) -> #list_node{} | null.\nrotate_right(Head, K) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec rotate_right(head :: ListNode.t | nil, k :: integer) :: ListNode.t | nil\n  def rotate_right(head, k) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "62",
    "title": "Unique Paths",
    "difficulty": "Medium",
    "category": "Math",
    "description": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe test cases are generated so that the answer will be less than or equal to 2 * 109.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "m = 3, n = 7",
        "output": "28",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png"
        ]
      },
      {
        "input": "m = 3, n = 2",
        "output": "3",
        "explanation": "From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down",
        "images": [
          "https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= m, n <= 100"
    ],
    "frontendId": "62",
    "problemId": "62",
    "slug": "unique-paths",
    "topics": [
      "Math",
      "Dynamic Programming",
      "Combinatorics"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int uniquePaths(int m, int n) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int uniquePaths(int m, int n) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int UniquePaths(int m, int n) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function(m, n) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function uniquePaths(m: number, n: number): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer $m\n     * @param Integer $n\n     * @return Integer\n     */\n    function uniquePaths($m, $n) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func uniquePaths(_ m: Int, _ n: Int) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun uniquePaths(m: Int, n: Int): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int uniquePaths(int m, int n) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func uniquePaths(m int, n int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer} m\n# @param {Integer} n\n# @return {Integer}\ndef unique_paths(m, n)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def uniquePaths(m: Int, n: Int): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn unique_paths(m: i32, n: i32) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (unique-paths m n)\n  (-> exact-integer? exact-integer? exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec unique_paths(M :: integer(), N :: integer()) -> integer().\nunique_paths(M, N) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec unique_paths(m :: integer, n :: integer) :: integer\n  def unique_paths(m, n) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "63",
    "title": "Unique Paths II",
    "difficulty": "Medium",
    "category": "Array",
    "description": "You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nAn obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\nReturn the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe testcases are generated so that the answer will be less than or equal to 2 * 109.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]",
        "output": "2",
        "explanation": "There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right",
        "images": [
          "https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg"
        ]
      },
      {
        "input": "obstacleGrid = [[0,1],[0,0]]",
        "output": "1",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "m == obstacleGrid.length",
      "n == obstacleGrid[i].length",
      "1 <= m, n <= 100",
      "obstacleGrid[i][j] is 0 or 1."
    ],
    "frontendId": "63",
    "problemId": "63",
    "slug": "unique-paths-ii",
    "topics": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int uniquePathsWithObstacles(int** obstacleGrid, int obstacleGridSize, int* obstacleGridColSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int UniquePathsWithObstacles(int[][] obstacleGrid) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[][]} obstacleGrid\n * @return {number}\n */\nvar uniquePathsWithObstacles = function(obstacleGrid) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function uniquePathsWithObstacles(obstacleGrid: number[][]): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[][] $obstacleGrid\n     * @return Integer\n     */\n    function uniquePathsWithObstacles($obstacleGrid) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func uniquePathsWithObstacles(_ obstacleGrid: [[Int]]) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun uniquePathsWithObstacles(obstacleGrid: Array<IntArray>): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int uniquePathsWithObstacles(List<List<int>> obstacleGrid) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func uniquePathsWithObstacles(obstacleGrid [][]int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[][]} obstacle_grid\n# @return {Integer}\ndef unique_paths_with_obstacles(obstacle_grid)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def uniquePathsWithObstacles(obstacleGrid: Array[Array[Int]]): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn unique_paths_with_obstacles(obstacle_grid: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (unique-paths-with-obstacles obstacleGrid)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec unique_paths_with_obstacles(ObstacleGrid :: [[integer()]]) -> integer().\nunique_paths_with_obstacles(ObstacleGrid) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec unique_paths_with_obstacles(obstacle_grid :: [[integer]]) :: integer\n  def unique_paths_with_obstacles(obstacle_grid) do\n    \n  end\nend"
      }
    },
    "hints": [
      "Use dynamic programming since, from each cell, you can move to the right or down.",
      "assume dp[i][j] is the number of unique paths to reach (i, j). dp[i][j] = dp[i][j -1] + dp[i - 1][j]. Be careful when you encounter an obstacle. set its value in dp to 0."
    ],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "64",
    "title": "Minimum Path Sum",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
        "output": "7",
        "explanation": "Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.",
        "images": [
          "https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg"
        ]
      },
      {
        "input": "grid = [[1,2,3],[4,5,6]]",
        "output": "12",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 200",
      "0 <= grid[i][j] <= 200"
    ],
    "frontendId": "64",
    "problemId": "64",
    "slug": "minimum-path-sum",
    "topics": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int minPathSum(int[][] grid) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int minPathSum(int** grid, int gridSize, int* gridColSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int MinPathSum(int[][] grid) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minPathSum = function(grid) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function minPathSum(grid: number[][]): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer\n     */\n    function minPathSum($grid) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func minPathSum(_ grid: [[Int]]) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun minPathSum(grid: Array<IntArray>): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int minPathSum(List<List<int>> grid) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func minPathSum(grid [][]int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[][]} grid\n# @return {Integer}\ndef min_path_sum(grid)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def minPathSum(grid: Array[Array[Int]]): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn min_path_sum(grid: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (min-path-sum grid)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec min_path_sum(Grid :: [[integer()]]) -> integer().\nmin_path_sum(Grid) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec min_path_sum(grid :: [[integer]]) :: integer\n  def min_path_sum(grid) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "65",
    "title": "Valid Number",
    "difficulty": "Hard",
    "category": "String",
    "description": "Given a string s, return whether s is a valid number.\n\nFor example, all the following are valid numbers: \"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\", while the following are not valid numbers: \"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\".\nFormally, a valid number is defined using one of the following definitions:\nAn integer number is defined with an optional sign '-' or '+' followed by digits.\nA decimal number is defined with an optional sign '-' or '+' followed by one of the following definitions:\nAn exponent is defined with an exponent notation 'e' or 'E' followed by an integer number.\nThe digits are defined as one or more digits.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "s = \"0\"",
        "output": "true",
        "explanation": "",
        "images": []
      },
      {
        "input": "s = \"e\"",
        "output": "false",
        "explanation": "",
        "images": []
      },
      {
        "input": "s = \".\"",
        "output": "false",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= s.length <= 20",
      "s consists of only English letters (both uppercase and lowercase), digits (0-9), plus '+', minus '-', or dot '.'."
    ],
    "frontendId": "65",
    "problemId": "65",
    "slug": "valid-number",
    "topics": [
      "String"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    bool isNumber(string s) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public boolean isNumber(String s) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        "
      },
      "c": {
        "name": "c",
        "code": "bool isNumber(char* s) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public bool IsNumber(string s) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar isNumber = function(s) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function isNumber(s: string): boolean {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Boolean\n     */\n    function isNumber($s) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func isNumber(_ s: String) -> Bool {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun isNumber(s: String): Boolean {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  bool isNumber(String s) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func isNumber(s string) bool {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} s\n# @return {Boolean}\ndef is_number(s)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def isNumber(s: String): Boolean = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn is_number(s: String) -> bool {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (is-number s)\n  (-> string? boolean?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec is_number(S :: unicode:unicode_binary()) -> boolean().\nis_number(S) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec is_number(s :: String.t) :: boolean\n  def is_number(s) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 260
  },
  {
    "numId": "66",
    "title": "Plus One",
    "difficulty": "Easy",
    "category": "Array",
    "description": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "digits = [1,2,3]",
        "output": "[1,2,4]",
        "explanation": "The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].",
        "images": []
      },
      {
        "input": "digits = [4,3,2,1]",
        "output": "[4,3,2,2]",
        "explanation": "The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].",
        "images": []
      },
      {
        "input": "digits = [9]",
        "output": "[1,0]",
        "explanation": "The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= digits.length <= 100",
      "0 <= digits[i] <= 9",
      "digits does not contain any leading 0's."
    ],
    "frontendId": "66",
    "problemId": "66",
    "slug": "plus-one",
    "topics": [
      "Array",
      "Math"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int[] plusOne(int[] digits) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* plusOne(int* digits, int digitsSize, int* returnSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int[] PlusOne(int[] digits) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} digits\n * @return {number[]}\n */\nvar plusOne = function(digits) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function plusOne(digits: number[]): number[] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $digits\n     * @return Integer[]\n     */\n    function plusOne($digits) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func plusOne(_ digits: [Int]) -> [Int] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun plusOne(digits: IntArray): IntArray {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<int> plusOne(List<int> digits) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func plusOne(digits []int) []int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} digits\n# @return {Integer[]}\ndef plus_one(digits)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def plusOne(digits: Array[Int]): Array[Int] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn plus_one(digits: Vec<i32>) -> Vec<i32> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (plus-one digits)\n  (-> (listof exact-integer?) (listof exact-integer?))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec plus_one(Digits :: [integer()]) -> [integer()].\nplus_one(Digits) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec plus_one(digits :: [integer]) :: [integer]\n  def plus_one(digits) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 100
  },
  {
    "numId": "67",
    "title": "Add Binary",
    "difficulty": "Easy",
    "category": "Math",
    "description": "Given two binary strings a and b, return their sum as a binary string.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "a = \"11\", b = \"1\"",
        "output": "\"100\"",
        "explanation": "",
        "images": []
      },
      {
        "input": "a = \"1010\", b = \"1011\"",
        "output": "\"10101\"",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= a.length, b.length <= 104",
      "a and b consist only of '0' or '1' characters.",
      "Each string does not contain leading zeros except for the zero itself."
    ],
    "frontendId": "67",
    "problemId": "67",
    "slug": "add-binary",
    "topics": [
      "Math",
      "String",
      "Bit Manipulation",
      "Simulation"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    string addBinary(string a, string b) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public String addBinary(String a, String b) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        "
      },
      "c": {
        "name": "c",
        "code": "char* addBinary(char* a, char* b) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public string AddBinary(string a, string b) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} a\n * @param {string} b\n * @return {string}\n */\nvar addBinary = function(a, b) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function addBinary(a: string, b: string): string {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $a\n     * @param String $b\n     * @return String\n     */\n    function addBinary($a, $b) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func addBinary(_ a: String, _ b: String) -> String {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun addBinary(a: String, b: String): String {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  String addBinary(String a, String b) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func addBinary(a string, b string) string {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} a\n# @param {String} b\n# @return {String}\ndef add_binary(a, b)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def addBinary(a: String, b: String): String = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn add_binary(a: String, b: String) -> String {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (add-binary a b)\n  (-> string? string? string?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec add_binary(A :: unicode:unicode_binary(), B :: unicode:unicode_binary()) -> unicode:unicode_binary().\nadd_binary(A, B) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec add_binary(a :: String.t, b :: String.t) :: String.t\n  def add_binary(a, b) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 100
  },
  {
    "numId": "68",
    "title": "Text Justification",
    "difficulty": "Hard",
    "category": "Array",
    "description": "Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\nNote:\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
        "output": "[",
        "explanation": "",
        "images": []
      },
      {
        "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
        "output": "[",
        "explanation": "Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.",
        "images": []
      },
      {
        "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
        "output": "[",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= words.length <= 300",
      "1 <= words[i].length <= 20",
      "words[i] consists of only English letters and symbols.",
      "1 <= maxWidth <= 100",
      "words[i].length <= maxWidth"
    ],
    "frontendId": "68",
    "problemId": "68",
    "slug": "text-justification",
    "topics": [
      "Array",
      "String",
      "Simulation"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** fullJustify(char** words, int wordsSize, int maxWidth, int* returnSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public IList<string> FullJustify(string[] words, int maxWidth) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string[]} words\n * @param {number} maxWidth\n * @return {string[]}\n */\nvar fullJustify = function(words, maxWidth) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function fullJustify(words: string[], maxWidth: number): string[] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String[] $words\n     * @param Integer $maxWidth\n     * @return String[]\n     */\n    function fullJustify($words, $maxWidth) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun fullJustify(words: Array<String>, maxWidth: Int): List<String> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<String> fullJustify(List<String> words, int maxWidth) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func fullJustify(words []string, maxWidth int) []string {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String[]} words\n# @param {Integer} max_width\n# @return {String[]}\ndef full_justify(words, max_width)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def fullJustify(words: Array[String], maxWidth: Int): List[String] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn full_justify(words: Vec<String>, max_width: i32) -> Vec<String> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (full-justify words maxWidth)\n  (-> (listof string?) exact-integer? (listof string?))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec full_justify(Words :: [unicode:unicode_binary()], MaxWidth :: integer()) -> [unicode:unicode_binary()].\nfull_justify(Words, MaxWidth) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec full_justify(words :: [String.t], max_width :: integer) :: [String.t]\n  def full_justify(words, max_width) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 260
  },
  {
    "numId": "69",
    "title": "Sqrt(x)",
    "difficulty": "Easy",
    "category": "Math",
    "description": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\nYou must not use any built-in exponent function or operator.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "x = 4",
        "output": "2",
        "explanation": "The square root of 4 is 2, so we return 2.",
        "images": []
      },
      {
        "input": "x = 8",
        "output": "2",
        "explanation": "The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "0 <= x <= 231 - 1"
    ],
    "frontendId": "69",
    "problemId": "69",
    "slug": "sqrtx",
    "topics": [
      "Math",
      "Binary Search"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int mySqrt(int x) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int mySqrt(int x) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int mySqrt(int x) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int MySqrt(int x) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number} x\n * @return {number}\n */\nvar mySqrt = function(x) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function mySqrt(x: number): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer $x\n     * @return Integer\n     */\n    function mySqrt($x) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func mySqrt(_ x: Int) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun mySqrt(x: Int): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int mySqrt(int x) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func mySqrt(x int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer} x\n# @return {Integer}\ndef my_sqrt(x)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def mySqrt(x: Int): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn my_sqrt(x: i32) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (my-sqrt x)\n  (-> exact-integer? exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec my_sqrt(X :: integer()) -> integer().\nmy_sqrt(X) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec my_sqrt(x :: integer) :: integer\n  def my_sqrt(x) do\n    \n  end\nend"
      }
    },
    "hints": [
      "Try exploring all integers. (Credits: @annujoshi)",
      "Use the sorted property of integers to reduced the search space. (Credits: @annujoshi)"
    ],
    "acceptance": 0,
    "points": 100
  },
  {
    "numId": "70",
    "title": "Climbing Stairs",
    "difficulty": "Easy",
    "category": "Math",
    "description": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps",
        "images": []
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= n <= 45"
    ],
    "frontendId": "70",
    "problemId": "70",
    "slug": "climbing-stairs",
    "topics": [
      "Math",
      "Dynamic Programming",
      "Memoization"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int climbStairs(int n) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int climbStairs(int n) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int climbStairs(int n) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int ClimbStairs(int n) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function(n) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function climbStairs(n: number): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function climbStairs($n) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func climbStairs(_ n: Int) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun climbStairs(n: Int): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int climbStairs(int n) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func climbStairs(n int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer} n\n# @return {Integer}\ndef climb_stairs(n)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def climbStairs(n: Int): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn climb_stairs(n: i32) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (climb-stairs n)\n  (-> exact-integer? exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec climb_stairs(N :: integer()) -> integer().\nclimb_stairs(N) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec climb_stairs(n :: integer) :: integer\n  def climb_stairs(n) do\n    \n  end\nend"
      }
    },
    "hints": [
      "To reach nth step, what could have been your previous steps? (Think about the step sizes)"
    ],
    "acceptance": 0,
    "points": 100
  },
  {
    "numId": "71",
    "title": "Simplify Path",
    "difficulty": "Medium",
    "category": "String",
    "description": "You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Your task is to transform this absolute path into its simplified canonical path.\nThe rules of a Unix-style file system are as follows:\nThe simplified canonical path should follow these rules:\nReturn the simplified canonical path.\nExample 1:\nExample 2:\nExample 3:\nExample 4:\nExample 5:\nConstraints:",
    "examples": [
      {
        "input": "path = \"/home/\"",
        "output": "\"/home\"",
        "explanation": "The trailing slash should be removed.",
        "images": []
      },
      {
        "input": "path = \"/home//foo/\"",
        "output": "\"/home/foo\"",
        "explanation": "Multiple consecutive slashes are replaced by a single one.",
        "images": []
      },
      {
        "input": "path = \"/home/user/Documents/../Pictures\"",
        "output": "\"/home/user/Pictures\"",
        "explanation": "A double period \"..\" refers to the directory up a level (the parent directory).",
        "images": []
      },
      {
        "input": "path = \"/../\"",
        "output": "\"/\"",
        "explanation": "Going one level up from the root directory is not possible.",
        "images": []
      },
      {
        "input": "path = \"/.../a/../b/c/../d/./\"",
        "output": "\"/.../b/d\"",
        "explanation": "\"...\" is a valid name for a directory in this problem.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= path.length <= 3000",
      "path consists of English letters, digits, period '.', slash '/' or '_'.",
      "path is a valid absolute Unix path."
    ],
    "frontendId": "71",
    "problemId": "71",
    "slug": "simplify-path",
    "topics": [
      "String",
      "Stack"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    string simplifyPath(string path) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public String simplifyPath(String path) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        "
      },
      "c": {
        "name": "c",
        "code": "char* simplifyPath(char* path) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public string SimplifyPath(string path) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} path\n * @return {string}\n */\nvar simplifyPath = function(path) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function simplifyPath(path: string): string {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $path\n     * @return String\n     */\n    function simplifyPath($path) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func simplifyPath(_ path: String) -> String {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun simplifyPath(path: String): String {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  String simplifyPath(String path) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func simplifyPath(path string) string {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} path\n# @return {String}\ndef simplify_path(path)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def simplifyPath(path: String): String = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn simplify_path(path: String) -> String {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (simplify-path path)\n  (-> string? string?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec simplify_path(Path :: unicode:unicode_binary()) -> unicode:unicode_binary().\nsimplify_path(Path) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec simplify_path(path :: String.t) :: String.t\n  def simplify_path(path) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "72",
    "title": "Edit Distance",
    "difficulty": "Medium",
    "category": "String",
    "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "word1 = \"horse\", word2 = \"ros\"",
        "output": "3",
        "explanation": "horse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')",
        "images": []
      },
      {
        "input": "word1 = \"intention\", word2 = \"execution\"",
        "output": "5",
        "explanation": "intention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "0 <= word1.length, word2.length <= 500",
      "word1 and word2 consist of lowercase English letters."
    ],
    "frontendId": "72",
    "problemId": "72",
    "slug": "edit-distance",
    "topics": [
      "String",
      "Dynamic Programming"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int minDistance(String word1, String word2) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int minDistance(char* word1, char* word2) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int MinDistance(string word1, string word2) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nvar minDistance = function(word1, word2) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function minDistance(word1: string, word2: string): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $word1\n     * @param String $word2\n     * @return Integer\n     */\n    function minDistance($word1, $word2) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func minDistance(_ word1: String, _ word2: String) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun minDistance(word1: String, word2: String): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int minDistance(String word1, String word2) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func minDistance(word1 string, word2 string) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} word1\n# @param {String} word2\n# @return {Integer}\ndef min_distance(word1, word2)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def minDistance(word1: String, word2: String): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn min_distance(word1: String, word2: String) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (min-distance word1 word2)\n  (-> string? string? exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec min_distance(Word1 :: unicode:unicode_binary(), Word2 :: unicode:unicode_binary()) -> integer().\nmin_distance(Word1, Word2) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec min_distance(word1 :: String.t, word2 :: String.t) :: integer\n  def min_distance(word1, word2) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "73",
    "title": "Set Matrix Zeroes",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\nYou must do it in place.\nExample 1:\nExample 2:\nConstraints:\nFollow up:",
    "examples": [
      {
        "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
        "output": "[[1,0,1],[0,0,0],[1,0,1]]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg"
        ]
      },
      {
        "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
        "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "m == matrix.length",
      "n == matrix[0].length",
      "1 <= m, n <= 200",
      "-231 <= matrix[i][j] <= 231 - 1"
    ],
    "frontendId": "73",
    "problemId": "73",
    "slug": "set-matrix-zeroes",
    "topics": [
      "Array",
      "Hash Table",
      "Matrix"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public void setZeroes(int[][] matrix) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        "
      },
      "c": {
        "name": "c",
        "code": "void setZeroes(int** matrix, int matrixSize, int* matrixColSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public void SetZeroes(int[][] matrix) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nvar setZeroes = function(matrix) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n Do not return anything, modify matrix in-place instead.\n */\nfunction setZeroes(matrix: number[][]): void {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[][] $matrix\n     * @return NULL\n     */\n    function setZeroes(&$matrix) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun setZeroes(matrix: Array<IntArray>): Unit {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  void setZeroes(List<List<int>> matrix) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func setZeroes(matrix [][]int)  {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[][]} matrix\n# @return {Void} Do not return anything, modify matrix in-place instead.\ndef set_zeroes(matrix)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def setZeroes(matrix: Array[Array[Int]]): Unit = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn set_zeroes(matrix: &mut Vec<Vec<i32>>) {\n        \n    }\n}"
      }
    },
    "hints": [
      "If any cell of the matrix has a zero we can record its row and column number using additional memory.\r\nBut if you don't want to use extra memory then you can manipulate the array instead. i.e. simulating exactly what the question says.",
      "Setting cell values to zero on the fly while iterating might lead to discrepancies. What if you use some other integer value as your marker?\r\nThere is still a better approach for this problem with O(1) space.",
      "We could have used 2 sets to keep a record of rows/columns which need to be set to zero. But for an O(1) space solution, you can use one of the rows and and one of the columns to keep track of this information.",
      "We can use the first cell of every row and column as a flag. This flag would determine whether a row or column has been set to zero."
    ],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "74",
    "title": "Search a 2D Matrix",
    "difficulty": "Medium",
    "category": "Array",
    "description": "You are given an m x n integer matrix matrix with the following two properties:\nGiven an integer target, return true if target is in matrix or false otherwise.\nYou must write a solution in O(log(m * n)) time complexity.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3",
        "output": "true",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/10/05/mat.jpg"
        ]
      },
      {
        "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13",
        "output": "false",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 100",
      "-104 <= matrix[i][j], target <= 104"
    ],
    "frontendId": "74",
    "problemId": "74",
    "slug": "search-a-2d-matrix",
    "topics": [
      "Array",
      "Binary Search",
      "Matrix"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        "
      },
      "c": {
        "name": "c",
        "code": "bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public bool SearchMatrix(int[][] matrix, int target) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[][]} matrix\n * @param {number} target\n * @return {boolean}\n */\nvar searchMatrix = function(matrix, target) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function searchMatrix(matrix: number[][], target: number): boolean {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[][] $matrix\n     * @param Integer $target\n     * @return Boolean\n     */\n    function searchMatrix($matrix, $target) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func searchMatrix(_ matrix: [[Int]], _ target: Int) -> Bool {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun searchMatrix(matrix: Array<IntArray>, target: Int): Boolean {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  bool searchMatrix(List<List<int>> matrix, int target) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func searchMatrix(matrix [][]int, target int) bool {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[][]} matrix\n# @param {Integer} target\n# @return {Boolean}\ndef search_matrix(matrix, target)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def searchMatrix(matrix: Array[Array[Int]], target: Int): Boolean = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (search-matrix matrix target)\n  (-> (listof (listof exact-integer?)) exact-integer? boolean?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec search_matrix(Matrix :: [[integer()]], Target :: integer()) -> boolean().\nsearch_matrix(Matrix, Target) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec search_matrix(matrix :: [[integer]], target :: integer) :: boolean\n  def search_matrix(matrix, target) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "75",
    "title": "Sort Colors",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library's sort function.\nExample 1:\nExample 2:\nConstraints:\nFollow up: Could you come up with a one-pass algorithm using only constant extra space?",
    "examples": [
      {
        "input": "nums = [2,0,2,1,1,0]",
        "output": "[0,0,1,1,2,2]",
        "explanation": "",
        "images": []
      },
      {
        "input": "nums = [2,0,1]",
        "output": "[0,1,2]",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "n == nums.length",
      "1 <= n <= 300",
      "nums[i] is either 0, 1, or 2."
    ],
    "frontendId": "75",
    "problemId": "75",
    "slug": "sort-colors",
    "topics": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public void sortColors(int[] nums) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        "
      },
      "c": {
        "name": "c",
        "code": "void sortColors(int* nums, int numsSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public void SortColors(int[] nums) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar sortColors = function(nums) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n Do not return anything, modify nums in-place instead.\n */\nfunction sortColors(nums: number[]): void {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return NULL\n     */\n    function sortColors(&$nums) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func sortColors(_ nums: inout [Int]) {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun sortColors(nums: IntArray): Unit {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  void sortColors(List<int> nums) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func sortColors(nums []int)  {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @return {Void} Do not return anything, modify nums in-place instead.\ndef sort_colors(nums)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def sortColors(nums: Array[Int]): Unit = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn sort_colors(nums: &mut Vec<i32>) {\n        \n    }\n}"
      }
    },
    "hints": [
      "A rather straight forward solution is a two-pass algorithm using counting sort.",
      "Iterate the array counting number of 0's, 1's, and 2's.",
      "Overwrite array with the total number of 0's, then 1's and followed by 2's."
    ],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "76",
    "title": "Minimum Window Substring",
    "difficulty": "Hard",
    "category": "Hash Table",
    "description": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\nThe testcases will be generated such that the answer is unique.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you find an algorithm that runs in O(m + n) time?",
    "examples": [
      {
        "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
        "output": "\"BANC\"",
        "explanation": "The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.",
        "images": []
      },
      {
        "input": "s = \"a\", t = \"a\"",
        "output": "\"a\"",
        "explanation": "The entire string s is the minimum window.",
        "images": []
      },
      {
        "input": "s = \"a\", t = \"aa\"",
        "output": "\"\"",
        "explanation": "Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "m == s.length",
      "n == t.length",
      "1 <= m, n <= 105",
      "s and t consist of uppercase and lowercase English letters."
    ],
    "frontendId": "76",
    "problemId": "76",
    "slug": "minimum-window-substring",
    "topics": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    string minWindow(string s, string t) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public String minWindow(String s, String t) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        "
      },
      "c": {
        "name": "c",
        "code": "char* minWindow(char* s, char* t) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public string MinWindow(string s, string t) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} s\n * @param {string} t\n * @return {string}\n */\nvar minWindow = function(s, t) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function minWindow(s: string, t: string): string {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String $t\n     * @return String\n     */\n    function minWindow($s, $t) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func minWindow(_ s: String, _ t: String) -> String {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun minWindow(s: String, t: String): String {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  String minWindow(String s, String t) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func minWindow(s string, t string) string {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} s\n# @param {String} t\n# @return {String}\ndef min_window(s, t)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def minWindow(s: String, t: String): String = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn min_window(s: String, t: String) -> String {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (min-window s t)\n  (-> string? string? string?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec min_window(S :: unicode:unicode_binary(), T :: unicode:unicode_binary()) -> unicode:unicode_binary().\nmin_window(S, T) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec min_window(s :: String.t, t :: String.t) :: String.t\n  def min_window(s, t) do\n    \n  end\nend"
      }
    },
    "hints": [
      "Use two pointers to create a window of letters in s, which would have all the characters from t.",
      "Expand the right pointer until all the characters of t are covered.",
      "Once all the characters are covered, move the left pointer and ensure that all the characters are still covered to minimize the subarray size.",
      "Continue expanding the right and left pointers until you reach the end of s."
    ],
    "acceptance": 0,
    "points": 260
  },
  {
    "numId": "77",
    "title": "Combinations",
    "difficulty": "Medium",
    "category": "Backtracking",
    "description": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\nYou may return the answer in any order.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "n = 4, k = 2",
        "output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
        "explanation": "There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.",
        "images": []
      },
      {
        "input": "n = 1, k = 1",
        "output": "[[1]]",
        "explanation": "There is 1 choose 1 = 1 total combination.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= n <= 20",
      "1 <= k <= n"
    ],
    "frontendId": "77",
    "problemId": "77",
    "slug": "combinations",
    "topics": [
      "Backtracking"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<vector<int>> combine(int n, int k) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** combine(int n, int k, int* returnSize, int** returnColumnSizes) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public IList<IList<int>> Combine(int n, int k) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number} n\n * @param {number} k\n * @return {number[][]}\n */\nvar combine = function(n, k) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function combine(n: number, k: number): number[][] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $k\n     * @return Integer[][]\n     */\n    function combine($n, $k) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func combine(_ n: Int, _ k: Int) -> [[Int]] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun combine(n: Int, k: Int): List<List<Int>> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<List<int>> combine(int n, int k) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func combine(n int, k int) [][]int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer} n\n# @param {Integer} k\n# @return {Integer[][]}\ndef combine(n, k)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def combine(n: Int, k: Int): List[List[Int]] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn combine(n: i32, k: i32) -> Vec<Vec<i32>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (combine n k)\n  (-> exact-integer? exact-integer? (listof (listof exact-integer?)))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec combine(N :: integer(), K :: integer()) -> [[integer()]].\ncombine(N, K) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec combine(n :: integer, k :: integer) :: [[integer]]\n  def combine(n, k) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "78",
    "title": "Subsets",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an integer array nums of unique elements, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "nums = [1,2,3]",
        "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
        "explanation": "",
        "images": []
      },
      {
        "input": "nums = [0]",
        "output": "[[],[0]]",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= nums.length <= 10",
      "-10 <= nums[i] <= 10",
      "All the numbers of nums are unique."
    ],
    "frontendId": "78",
    "problemId": "78",
    "slug": "subsets",
    "topics": [
      "Array",
      "Backtracking",
      "Bit Manipulation"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public IList<IList<int>> Subsets(int[] nums) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function(nums) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function subsets(nums: number[]): number[][] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[][]\n     */\n    function subsets($nums) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func subsets(_ nums: [Int]) -> [[Int]] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun subsets(nums: IntArray): List<List<Int>> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<List<int>> subsets(List<int> nums) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func subsets(nums []int) [][]int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @return {Integer[][]}\ndef subsets(nums)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def subsets(nums: Array[Int]): List[List[Int]] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn subsets(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (subsets nums)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec subsets(Nums :: [integer()]) -> [[integer()]].\nsubsets(Nums) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec subsets(nums :: [integer]) :: [[integer]]\n  def subsets(nums) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "79",
    "title": "Word Search",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you use search pruning to make your solution faster with a larger board?",
    "examples": [
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
        "output": "true",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/11/04/word2.jpg"
        ]
      },
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"",
        "output": "true",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg"
        ]
      },
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"",
        "output": "false",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/10/15/word3.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "m == board.length",
      "n = board[i].length",
      "1 <= m, n <= 6",
      "1 <= word.length <= 15",
      "board and word consists of only lowercase and uppercase English letters."
    ],
    "frontendId": "79",
    "problemId": "79",
    "slug": "word-search",
    "topics": [
      "Array",
      "String",
      "Backtracking",
      "Depth-First Search",
      "Matrix"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public boolean exist(char[][] board, String word) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        "
      },
      "c": {
        "name": "c",
        "code": "bool exist(char** board, int boardSize, int* boardColSize, char* word) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public bool Exist(char[][] board, string word) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nvar exist = function(board, word) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function exist(board: string[][], word: string): boolean {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String[][] $board\n     * @param String $word\n     * @return Boolean\n     */\n    function exist($board, $word) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func exist(_ board: [[Character]], _ word: String) -> Bool {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun exist(board: Array<CharArray>, word: String): Boolean {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  bool exist(List<List<String>> board, String word) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func exist(board [][]byte, word string) bool {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Character[][]} board\n# @param {String} word\n# @return {Boolean}\ndef exist(board, word)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def exist(board: Array[Array[Char]], word: String): Boolean = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn exist(board: Vec<Vec<char>>, word: String) -> bool {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (exist board word)\n  (-> (listof (listof char?)) string? boolean?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec exist(Board :: [[char()]], Word :: unicode:unicode_binary()) -> boolean().\nexist(Board, Word) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec exist(board :: [[char]], word :: String.t) :: boolean\n  def exist(board, word) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "80",
    "title": "Remove Duplicates from Sorted Array II",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nIf all assertions pass, then your solution will be accepted.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3]",
        "output": "5, nums = [1,1,2,2,3,_]",
        "explanation": "Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
        "images": []
      },
      {
        "input": "nums = [0,0,1,1,1,1,2,3,3]",
        "output": "7, nums = [0,0,1,1,2,3,3,_,_]",
        "explanation": "Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= nums.length <= 3 * 104",
      "-104 <= nums[i] <= 104",
      "nums is sorted in non-decreasing order."
    ],
    "frontendId": "80",
    "problemId": "80",
    "slug": "remove-duplicates-from-sorted-array-ii",
    "topics": [
      "Array",
      "Two Pointers"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int removeDuplicates(int* nums, int numsSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int RemoveDuplicates(int[] nums) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function removeDuplicates(nums: number[]): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function removeDuplicates(&$nums) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func removeDuplicates(_ nums: inout [Int]) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun removeDuplicates(nums: IntArray): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int removeDuplicates(List<int> nums) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func removeDuplicates(nums []int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef remove_duplicates(nums)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def removeDuplicates(nums: Array[Int]): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\n        \n    }\n}"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "81",
    "title": "Search in Rotated Sorted Array II",
    "difficulty": "Medium",
    "category": "Array",
    "description": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).\nBefore being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].\nGiven the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.\nYou must decrease the overall operation steps as much as possible.\nExample 1:\nExample 2:\nConstraints:\nFollow up: This problem is similar to Search in Rotated Sorted Array, but nums may contain duplicates. Would this affect the runtime complexity? How and why?",
    "examples": [
      {
        "input": "nums = [2,5,6,0,0,1,2], target = 0",
        "output": "true",
        "explanation": "",
        "images": []
      },
      {
        "input": "nums = [2,5,6,0,0,1,2], target = 3",
        "output": "false",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= nums.length <= 5000",
      "-104 <= nums[i] <= 104",
      "nums is guaranteed to be rotated at some pivot.",
      "-104 <= target <= 104"
    ],
    "frontendId": "81",
    "problemId": "81",
    "slug": "search-in-rotated-sorted-array-ii",
    "topics": [
      "Array",
      "Binary Search"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public boolean search(int[] nums, int target) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        "
      },
      "c": {
        "name": "c",
        "code": "bool search(int* nums, int numsSize, int target) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public bool Search(int[] nums, int target) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {boolean}\n */\nvar search = function(nums, target) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function search(nums: number[], target: number): boolean {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Boolean\n     */\n    function search($nums, $target) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func search(_ nums: [Int], _ target: Int) -> Bool {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun search(nums: IntArray, target: Int): Boolean {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  bool search(List<int> nums, int target) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func search(nums []int, target int) bool {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Boolean}\ndef search(nums, target)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def search(nums: Array[Int], target: Int): Boolean = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn search(nums: Vec<i32>, target: i32) -> bool {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (search nums target)\n  (-> (listof exact-integer?) exact-integer? boolean?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec search(Nums :: [integer()], Target :: integer()) -> boolean().\nsearch(Nums, Target) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec search(nums :: [integer], target :: integer) :: boolean\n  def search(nums, target) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "82",
    "title": "Remove Duplicates from Sorted List II",
    "difficulty": "Medium",
    "category": "Linked List",
    "description": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "head = [1,2,3,3,4,4,5]",
        "output": "[1,2,5]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg"
        ]
      },
      {
        "input": "head = [1,1,1,2,3]",
        "output": "[2,3]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "The number of nodes in the list is in the range [0, 300].",
      "-100 <= Node.val <= 100",
      "The list is guaranteed to be sorted in ascending order."
    ],
    "frontendId": "82",
    "problemId": "82",
    "slug": "remove-duplicates-from-sorted-list-ii",
    "topics": [
      "Linked List",
      "Two Pointers"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode DeleteDuplicates(ListNode head) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar deleteDuplicates = function(head) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function deleteDuplicates($head) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun deleteDuplicates(head: ListNode?): ListNode? {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? deleteDuplicates(ListNode? head) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc deleteDuplicates(head *ListNode) *ListNode {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @return {ListNode}\ndef delete_duplicates(head)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def deleteDuplicates(head: ListNode): ListNode = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (delete-duplicates head)\n  (-> (or/c list-node? #f) (or/c list-node? #f))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec delete_duplicates(Head :: #list_node{} | null) -> #list_node{} | null.\ndelete_duplicates(Head) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec delete_duplicates(head :: ListNode.t | nil) :: ListNode.t | nil\n  def delete_duplicates(head) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "83",
    "title": "Remove Duplicates from Sorted List",
    "difficulty": "Easy",
    "category": "Linked List",
    "description": "Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "head = [1,1,2]",
        "output": "[1,2]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2021/01/04/list1.jpg"
        ]
      },
      {
        "input": "head = [1,1,2,3,3]",
        "output": "[1,2,3]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2021/01/04/list2.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "The number of nodes in the list is in the range [0, 300].",
      "-100 <= Node.val <= 100",
      "The list is guaranteed to be sorted in ascending order."
    ],
    "frontendId": "83",
    "problemId": "83",
    "slug": "remove-duplicates-from-sorted-list",
    "topics": [
      "Linked List"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode DeleteDuplicates(ListNode head) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar deleteDuplicates = function(head) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function deleteDuplicates($head) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun deleteDuplicates(head: ListNode?): ListNode? {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? deleteDuplicates(ListNode? head) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc deleteDuplicates(head *ListNode) *ListNode {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @return {ListNode}\ndef delete_duplicates(head)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def deleteDuplicates(head: ListNode): ListNode = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (delete-duplicates head)\n  (-> (or/c list-node? #f) (or/c list-node? #f))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec delete_duplicates(Head :: #list_node{} | null) -> #list_node{} | null.\ndelete_duplicates(Head) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec delete_duplicates(head :: ListNode.t | nil) :: ListNode.t | nil\n  def delete_duplicates(head) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 100
  },
  {
    "numId": "84",
    "title": "Largest Rectangle in Histogram",
    "difficulty": "Hard",
    "category": "Array",
    "description": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "heights = [2,1,5,6,2,3]",
        "output": "10",
        "explanation": "The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.",
        "images": [
          "https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg"
        ]
      },
      {
        "input": "heights = [2,4]",
        "output": "4",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= heights.length <= 105",
      "0 <= heights[i] <= 104"
    ],
    "frontendId": "84",
    "problemId": "84",
    "slug": "largest-rectangle-in-histogram",
    "topics": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int largestRectangleArea(int* heights, int heightsSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int LargestRectangleArea(int[] heights) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} heights\n * @return {number}\n */\nvar largestRectangleArea = function(heights) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function largestRectangleArea(heights: number[]): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $heights\n     * @return Integer\n     */\n    function largestRectangleArea($heights) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func largestRectangleArea(_ heights: [Int]) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun largestRectangleArea(heights: IntArray): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int largestRectangleArea(List<int> heights) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func largestRectangleArea(heights []int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} heights\n# @return {Integer}\ndef largest_rectangle_area(heights)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def largestRectangleArea(heights: Array[Int]): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn largest_rectangle_area(heights: Vec<i32>) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (largest-rectangle-area heights)\n  (-> (listof exact-integer?) exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec largest_rectangle_area(Heights :: [integer()]) -> integer().\nlargest_rectangle_area(Heights) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec largest_rectangle_area(heights :: [integer]) :: integer\n  def largest_rectangle_area(heights) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 260
  },
  {
    "numId": "85",
    "title": "Maximal Rectangle",
    "difficulty": "Hard",
    "category": "Array",
    "description": "Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
        "output": "6",
        "explanation": "The maximal rectangle is shown in the above picture.",
        "images": [
          "https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg"
        ]
      },
      {
        "input": "matrix = [[\"0\"]]",
        "output": "0",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg"
        ]
      },
      {
        "input": "matrix = [[\"1\"]]",
        "output": "1",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "rows == matrix.length",
      "cols == matrix[i].length",
      "1 <= row, cols <= 200",
      "matrix[i][j] is '0' or '1'."
    ],
    "frontendId": "85",
    "problemId": "85",
    "slug": "maximal-rectangle",
    "topics": [
      "Array",
      "Dynamic Programming",
      "Stack",
      "Matrix",
      "Monotonic Stack"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int maximalRectangle(char[][] matrix) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int maximalRectangle(char** matrix, int matrixSize, int* matrixColSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int MaximalRectangle(char[][] matrix) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {character[][]} matrix\n * @return {number}\n */\nvar maximalRectangle = function(matrix) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function maximalRectangle(matrix: string[][]): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String[][] $matrix\n     * @return Integer\n     */\n    function maximalRectangle($matrix) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func maximalRectangle(_ matrix: [[Character]]) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun maximalRectangle(matrix: Array<CharArray>): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int maximalRectangle(List<List<String>> matrix) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func maximalRectangle(matrix [][]byte) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Character[][]} matrix\n# @return {Integer}\ndef maximal_rectangle(matrix)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def maximalRectangle(matrix: Array[Array[Char]]): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn maximal_rectangle(matrix: Vec<Vec<char>>) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (maximal-rectangle matrix)\n  (-> (listof (listof char?)) exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec maximal_rectangle(Matrix :: [[char()]]) -> integer().\nmaximal_rectangle(Matrix) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec maximal_rectangle(matrix :: [[char]]) :: integer\n  def maximal_rectangle(matrix) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 260
  },
  {
    "numId": "86",
    "title": "Partition List",
    "difficulty": "Medium",
    "category": "Linked List",
    "description": "Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "head = [1,4,3,2,5,2], x = 3",
        "output": "[1,2,2,4,3,5]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2021/01/04/partition.jpg"
        ]
      },
      {
        "input": "head = [2,1], x = 2",
        "output": "[1,2]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2021/01/04/partition.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "The number of nodes in the list is in the range [0, 200].",
      "-100 <= Node.val <= 100",
      "-200 <= x <= 200"
    ],
    "frontendId": "86",
    "problemId": "86",
    "slug": "partition-list",
    "topics": [
      "Linked List",
      "Two Pointers"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode partition(ListNode head, int x) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type x: int\n        :rtype: Optional[ListNode]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* partition(struct ListNode* head, int x) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode Partition(ListNode head, int x) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} x\n * @return {ListNode}\n */\nvar partition = function(head, x) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction partition(head: ListNode | null, x: number): ListNode | null {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @param Integer $x\n     * @return ListNode\n     */\n    function partition($head, $x) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func partition(_ head: ListNode?, _ x: Int) -> ListNode? {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun partition(head: ListNode?, x: Int): ListNode? {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? partition(ListNode? head, int x) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc partition(head *ListNode, x int) *ListNode {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @param {Integer} x\n# @return {ListNode}\ndef partition(head, x)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def partition(head: ListNode, x: Int): ListNode = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn partition(head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (partition head x)\n  (-> (or/c list-node? #f) exact-integer? (or/c list-node? #f))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec partition(Head :: #list_node{} | null, X :: integer()) -> #list_node{} | null.\npartition(Head, X) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec partition(head :: ListNode.t | nil, x :: integer) :: ListNode.t | nil\n  def partition(head, x) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "87",
    "title": "Scramble String",
    "difficulty": "Hard",
    "category": "String",
    "description": "We can scramble a string s to get a string t using the following algorithm:\nGiven two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "s1 = \"great\", s2 = \"rgeat\"",
        "output": "true",
        "explanation": "One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.",
        "images": []
      },
      {
        "input": "s1 = \"abcde\", s2 = \"caebd\"",
        "output": "false",
        "explanation": "",
        "images": []
      },
      {
        "input": "s1 = \"a\", s2 = \"a\"",
        "output": "true",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "s1.length == s2.length",
      "1 <= s1.length <= 30",
      "s1 and s2 consist of lowercase English letters."
    ],
    "frontendId": "87",
    "problemId": "87",
    "slug": "scramble-string",
    "topics": [
      "String",
      "Dynamic Programming"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    bool isScramble(string s1, string s2) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public boolean isScramble(String s1, String s2) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        "
      },
      "c": {
        "name": "c",
        "code": "bool isScramble(char* s1, char* s2) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public bool IsScramble(string s1, string s2) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nvar isScramble = function(s1, s2) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function isScramble(s1: string, s2: string): boolean {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $s1\n     * @param String $s2\n     * @return Boolean\n     */\n    function isScramble($s1, $s2) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func isScramble(_ s1: String, _ s2: String) -> Bool {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun isScramble(s1: String, s2: String): Boolean {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  bool isScramble(String s1, String s2) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func isScramble(s1 string, s2 string) bool {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} s1\n# @param {String} s2\n# @return {Boolean}\ndef is_scramble(s1, s2)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def isScramble(s1: String, s2: String): Boolean = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn is_scramble(s1: String, s2: String) -> bool {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (is-scramble s1 s2)\n  (-> string? string? boolean?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec is_scramble(S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary()) -> boolean().\nis_scramble(S1, S2) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec is_scramble(s1 :: String.t, s2 :: String.t) :: boolean\n  def is_scramble(s1, s2) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 260
  },
  {
    "numId": "88",
    "title": "Merge Sorted Array",
    "difficulty": "Easy",
    "category": "Array",
    "description": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Can you come up with an algorithm that runs in O(m + n) time?",
    "examples": [
      {
        "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
        "output": "[1,2,2,3,5,6]",
        "explanation": "The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.",
        "images": []
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]",
        "explanation": "The arrays we are merging are [1] and [].\nThe result of the merge is [1].",
        "images": []
      },
      {
        "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
        "output": "[1]",
        "explanation": "The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "nums1.length == m + n",
      "nums2.length == n",
      "0 <= m, n <= 200",
      "1 <= m + n <= 200",
      "-109 <= nums1[i], nums2[j] <= 109"
    ],
    "frontendId": "88",
    "problemId": "88",
    "slug": "merge-sorted-array",
    "topics": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        "
      },
      "c": {
        "name": "c",
        "code": "void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public void Merge(int[] nums1, int m, int[] nums2, int n) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\nvar merge = function(nums1, m, nums2, n) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n Do not return anything, modify nums1 in-place instead.\n */\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer $m\n     * @param Integer[] $nums2\n     * @param Integer $n\n     * @return NULL\n     */\n    function merge(&$nums1, $m, $nums2, $n) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun merge(nums1: IntArray, m: Int, nums2: IntArray, n: Int): Unit {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  void merge(List<int> nums1, int m, List<int> nums2, int n) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func merge(nums1 []int, m int, nums2 []int, n int)  {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums1\n# @param {Integer} m\n# @param {Integer[]} nums2\n# @param {Integer} n\n# @return {Void} Do not return anything, modify nums1 in-place instead.\ndef merge(nums1, m, nums2, n)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def merge(nums1: Array[Int], m: Int, nums2: Array[Int], n: Int): Unit = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn merge(nums1: &mut Vec<i32>, m: i32, nums2: &mut Vec<i32>, n: i32) {\n        \n    }\n}"
      }
    },
    "hints": [
      "You can easily solve this problem if you simply think about two elements at a time rather than two arrays. We know that each of the individual arrays is sorted. What we don't know is how they will intertwine. Can we take a local decision and arrive at an optimal solution?",
      "If you simply consider one element each at a time from the two arrays and make a decision and proceed accordingly, you will arrive at the optimal solution."
    ],
    "acceptance": 0,
    "points": 100
  },
  {
    "numId": "89",
    "title": "Gray Code",
    "difficulty": "Medium",
    "category": "Math",
    "description": "An n-bit gray code sequence is a sequence of 2n integers where:\nGiven an integer n, return any valid n-bit gray code sequence.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "n = 2",
        "output": "[0,1,3,2]",
        "explanation": "The binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit",
        "images": []
      },
      {
        "input": "n = 1",
        "output": "[0,1]",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= n <= 16"
    ],
    "frontendId": "89",
    "problemId": "89",
    "slug": "gray-code",
    "topics": [
      "Math",
      "Backtracking",
      "Bit Manipulation"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<int> grayCode(int n) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public List<Integer> grayCode(int n) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def grayCode(self, n: int) -> List[int]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* grayCode(int n, int* returnSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public IList<int> GrayCode(int n) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number} n\n * @return {number[]}\n */\nvar grayCode = function(n) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function grayCode(n: number): number[] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer[]\n     */\n    function grayCode($n) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func grayCode(_ n: Int) -> [Int] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun grayCode(n: Int): List<Int> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<int> grayCode(int n) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func grayCode(n int) []int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer} n\n# @return {Integer[]}\ndef gray_code(n)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def grayCode(n: Int): List[Int] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn gray_code(n: i32) -> Vec<i32> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (gray-code n)\n  (-> exact-integer? (listof exact-integer?))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec gray_code(N :: integer()) -> [integer()].\ngray_code(N) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec gray_code(n :: integer) :: [integer]\n  def gray_code(n) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "90",
    "title": "Subsets II",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "nums = [1,2,2]",
        "output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
        "explanation": "",
        "images": []
      },
      {
        "input": "nums = [0]",
        "output": "[[],[0]]",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= nums.length <= 10",
      "-10 <= nums[i] <= 10"
    ],
    "frontendId": "90",
    "problemId": "90",
    "slug": "subsets-ii",
    "topics": [
      "Array",
      "Backtracking",
      "Bit Manipulation"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** subsetsWithDup(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public IList<IList<int>> SubsetsWithDup(int[] nums) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsetsWithDup = function(nums) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function subsetsWithDup(nums: number[]): number[][] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[][]\n     */\n    function subsetsWithDup($nums) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun subsetsWithDup(nums: IntArray): List<List<Int>> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<List<int>> subsetsWithDup(List<int> nums) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func subsetsWithDup(nums []int) [][]int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer[]} nums\n# @return {Integer[][]}\ndef subsets_with_dup(nums)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def subsetsWithDup(nums: Array[Int]): List[List[Int]] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn subsets_with_dup(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (subsets-with-dup nums)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec subsets_with_dup(Nums :: [integer()]) -> [[integer()]].\nsubsets_with_dup(Nums) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec subsets_with_dup(nums :: [integer]) :: [[integer]]\n  def subsets_with_dup(nums) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "91",
    "title": "Decode Ways",
    "difficulty": "Medium",
    "category": "String",
    "description": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping:\n\"1\" -> 'A'\n\"2\" -> 'B'\n...\n\"25\" -> 'Y'\n\"26\" -> 'Z'\nHowever, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (\"2\" and \"5\" vs \"25\").\nFor example, \"11106\" can be decoded into:\nNote: there may be strings that are impossible to decode.\n\nGiven a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0.\nThe test cases are generated so that the answer fits in a 32-bit integer.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "s = \"12\"",
        "output": "2",
        "explanation": "\"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).",
        "images": []
      },
      {
        "input": "s = \"226\"",
        "output": "3",
        "explanation": "\"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).",
        "images": []
      },
      {
        "input": "s = \"06\"",
        "output": "0",
        "explanation": "\"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\"). In this case, the string is not a valid encoding, so return 0.",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= s.length <= 100",
      "s contains only digits and may contain leading zero(s)."
    ],
    "frontendId": "91",
    "problemId": "91",
    "slug": "decode-ways",
    "topics": [
      "String",
      "Dynamic Programming"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int numDecodings(string s) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int numDecodings(String s) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int numDecodings(char* s) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int NumDecodings(string s) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar numDecodings = function(s) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function numDecodings(s: string): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function numDecodings($s) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func numDecodings(_ s: String) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun numDecodings(s: String): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int numDecodings(String s) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func numDecodings(s string) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} s\n# @return {Integer}\ndef num_decodings(s)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def numDecodings(s: String): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn num_decodings(s: String) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (num-decodings s)\n  (-> string? exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec num_decodings(S :: unicode:unicode_binary()) -> integer().\nnum_decodings(S) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec num_decodings(s :: String.t) :: integer\n  def num_decodings(s) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "92",
    "title": "Reverse Linked List II",
    "difficulty": "Medium",
    "category": "Linked List",
    "description": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "head = [1,2,3,4,5], left = 2, right = 4",
        "output": "[1,4,3,2,5]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg"
        ]
      },
      {
        "input": "head = [5], left = 1, right = 1",
        "output": "[5]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "The number of nodes in the list is n.",
      "1 <= n <= 500",
      "-500 <= Node.val <= 500",
      "1 <= left <= right <= n"
    ],
    "frontendId": "92",
    "problemId": "92",
    "slug": "reverse-linked-list-ii",
    "topics": [
      "Linked List"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type left: int\n        :type right: int\n        :rtype: Optional[ListNode]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* reverseBetween(struct ListNode* head, int left, int right) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode ReverseBetween(ListNode head, int left, int right) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} left\n * @param {number} right\n * @return {ListNode}\n */\nvar reverseBetween = function(head, left, right) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction reverseBetween(head: ListNode | null, left: number, right: number): ListNode | null {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @param Integer $left\n     * @param Integer $right\n     * @return ListNode\n     */\n    function reverseBetween($head, $left, $right) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun reverseBetween(head: ListNode?, left: Int, right: Int): ListNode? {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? reverseBetween(ListNode? head, int left, int right) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @param {Integer} left\n# @param {Integer} right\n# @return {ListNode}\ndef reverse_between(head, left, right)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def reverseBetween(head: ListNode, left: Int, right: Int): ListNode = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn reverse_between(head: Option<Box<ListNode>>, left: i32, right: i32) -> Option<Box<ListNode>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (reverse-between head left right)\n  (-> (or/c list-node? #f) exact-integer? exact-integer? (or/c list-node? #f))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec reverse_between(Head :: #list_node{} | null, Left :: integer(), Right :: integer()) -> #list_node{} | null.\nreverse_between(Head, Left, Right) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec reverse_between(head :: ListNode.t | nil, left :: integer, right :: integer) :: ListNode.t | nil\n  def reverse_between(head, left, right) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "93",
    "title": "Restore IP Addresses",
    "difficulty": "Medium",
    "category": "String",
    "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "s = \"25525511135\"",
        "output": "[\"255.255.11.135\",\"255.255.111.35\"]",
        "explanation": "",
        "images": []
      },
      {
        "input": "s = \"0000\"",
        "output": "[\"0.0.0.0\"]",
        "explanation": "",
        "images": []
      },
      {
        "input": "s = \"101023\"",
        "output": "[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= s.length <= 20",
      "s consists of digits only."
    ],
    "frontendId": "93",
    "problemId": "93",
    "slug": "restore-ip-addresses",
    "topics": [
      "String",
      "Backtracking"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    vector<string> restoreIpAddresses(string s) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public List<String> restoreIpAddresses(String s) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def restoreIpAddresses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** restoreIpAddresses(char* s, int* returnSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public IList<string> RestoreIpAddresses(string s) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} s\n * @return {string[]}\n */\nvar restoreIpAddresses = function(s) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function restoreIpAddresses(s: string): string[] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @return String[]\n     */\n    function restoreIpAddresses($s) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func restoreIpAddresses(_ s: String) -> [String] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun restoreIpAddresses(s: String): List<String> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  List<String> restoreIpAddresses(String s) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func restoreIpAddresses(s string) []string {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} s\n# @return {String[]}\ndef restore_ip_addresses(s)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def restoreIpAddresses(s: String): List[String] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn restore_ip_addresses(s: String) -> Vec<String> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (restore-ip-addresses s)\n  (-> string? (listof string?))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec restore_ip_addresses(S :: unicode:unicode_binary()) -> [unicode:unicode_binary()].\nrestore_ip_addresses(S) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec restore_ip_addresses(s :: String.t) :: [String.t]\n  def restore_ip_addresses(s) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "94",
    "title": "Binary Tree Inorder Traversal",
    "difficulty": "Easy",
    "category": "Stack",
    "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values.\nExample 1:\nExample 2:\nExample 3:\nExample 4:\nConstraints:",
    "examples": [
      {
        "input": "root = [1,null,2,3]",
        "output": "[1,3,2]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png"
        ]
      },
      {
        "input": "root = [1,2,3,4,5,null,8,null,null,6,7,9]",
        "output": "[4,2,6,5,7,1,3,9,8]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2024/08/29/tree_2.png"
        ]
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "",
        "images": []
      },
      {
        "input": "root = [1]",
        "output": "[1]",
        "explanation": "",
        "images": []
      }
    ],
    "privateTests": [],
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "frontendId": "94",
    "problemId": "94",
    "slug": "binary-tree-inorder-traversal",
    "topics": [
      "Stack",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[int]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* inorderTraversal(struct TreeNode* root, int* returnSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public IList<int> InorderTraversal(TreeNode root) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function(root) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction inorderTraversal(root: TreeNode | null): number[] {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer[]\n     */\n    function inorderTraversal($root) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun inorderTraversal(root: TreeNode?): List<Int> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  List<int> inorderTraversal(TreeNode? root) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc inorderTraversal(root *TreeNode) []int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer[]}\ndef inorder_traversal(root)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def inorderTraversal(root: TreeNode): List[Int] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn inorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (inorder-traversal root)\n  (-> (or/c tree-node? #f) (listof exact-integer?))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec inorder_traversal(Root :: #tree_node{} | null) -> [integer()].\ninorder_traversal(Root) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec inorder_traversal(root :: TreeNode.t | nil) :: [integer]\n  def inorder_traversal(root) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 100
  },
  {
    "numId": "95",
    "title": "Unique Binary Search Trees II",
    "difficulty": "Medium",
    "category": "Dynamic Programming",
    "description": "Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "n = 3",
        "output": "[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg"
        ]
      },
      {
        "input": "n = 1",
        "output": "[[1]]",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= n <= 8"
    ],
    "frontendId": "95",
    "problemId": "95",
    "slug": "unique-binary-search-trees-ii",
    "topics": [
      "Dynamic Programming",
      "Backtracking",
      "Tree",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<TreeNode*> generateTrees(int n) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<TreeNode> generateTrees(int n) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def generateTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[Optional[TreeNode]]\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nstruct TreeNode** generateTrees(int n, int* returnSize) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public IList<TreeNode> GenerateTrees(int n) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number} n\n * @return {TreeNode[]}\n */\nvar generateTrees = function(n) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction generateTrees(n: number): Array<TreeNode | null> {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param Integer $n\n     * @return TreeNode[]\n     */\n    function generateTrees($n) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func generateTrees(_ n: Int) -> [TreeNode?] {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun generateTrees(n: Int): List<TreeNode?> {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  List<TreeNode?> generateTrees(int n) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc generateTrees(n int) []*TreeNode {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {Integer} n\n# @return {TreeNode[]}\ndef generate_trees(n)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def generateTrees(n: Int): List[TreeNode] = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn generate_trees(n: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (generate-trees n)\n  (-> exact-integer? (listof (or/c tree-node? #f)))\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec generate_trees(N :: integer()) -> [#tree_node{} | null].\ngenerate_trees(N) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec generate_trees(n :: integer) :: [TreeNode.t | nil]\n  def generate_trees(n) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "96",
    "title": "Unique Binary Search Trees",
    "difficulty": "Medium",
    "category": "Math",
    "description": "Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "n = 3",
        "output": "5",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg"
        ]
      },
      {
        "input": "n = 1",
        "output": "1",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "1 <= n <= 19"
    ],
    "frontendId": "96",
    "problemId": "96",
    "slug": "unique-binary-search-trees",
    "topics": [
      "Math",
      "Dynamic Programming",
      "Tree",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    int numTrees(int n) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public int numTrees(int n) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def numTrees(self, n: int) -> int:\n        "
      },
      "c": {
        "name": "c",
        "code": "int numTrees(int n) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public int NumTrees(int n) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar numTrees = function(n) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function numTrees(n: number): number {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function numTrees($n) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func numTrees(_ n: Int) -> Int {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun numTrees(n: Int): Int {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  int numTrees(int n) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func numTrees(n int) int {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {Integer} n\n# @return {Integer}\ndef num_trees(n)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def numTrees(n: Int): Int = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn num_trees(n: i32) -> i32 {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (num-trees n)\n  (-> exact-integer? exact-integer?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec num_trees(N :: integer()) -> integer().\nnum_trees(N) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec num_trees(n :: integer) :: integer\n  def num_trees(n) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "97",
    "title": "Interleaving String",
    "difficulty": "Medium",
    "category": "String",
    "description": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.\nAn interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:\nNote: a + b is the concatenation of strings a and b.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you solve it using only O(s2.length) additional memory space?",
    "examples": [
      {
        "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"",
        "output": "true",
        "explanation": "One way to obtain s3 is:\nSplit s1 into s1 = \"aa\" + \"bc\" + \"c\", and s2 into s2 = \"dbbc\" + \"a\".\nInterleaving the two splits, we get \"aa\" + \"dbbc\" + \"bc\" + \"a\" + \"c\" = \"aadbbcbcac\".\nSince s3 can be obtained by interleaving s1 and s2, we return true.",
        "images": [
          "https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg"
        ]
      },
      {
        "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"",
        "output": "false",
        "explanation": "Notice how it is impossible to interleave s2 with any other string to obtain s3.",
        "images": [
          "https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg"
        ]
      },
      {
        "input": "s1 = \"\", s2 = \"\", s3 = \"\"",
        "output": "true",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "0 <= s1.length, s2.length <= 100",
      "0 <= s3.length <= 200",
      "s1, s2, and s3 consist of lowercase English letters."
    ],
    "frontendId": "97",
    "problemId": "97",
    "slug": "interleaving-string",
    "topics": [
      "String",
      "Dynamic Programming"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "class Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "class Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        "
      },
      "c": {
        "name": "c",
        "code": "bool isInterleave(char* s1, char* s2, char* s3) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "public class Solution {\n    public bool IsInterleave(string s1, string s2, string s3) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * @param {string} s1\n * @param {string} s2\n * @param {string} s3\n * @return {boolean}\n */\nvar isInterleave = function(s1, s2, s3) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "function isInterleave(s1: string, s2: string, s3: string): boolean {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "class Solution {\n\n    /**\n     * @param String $s1\n     * @param String $s2\n     * @param String $s3\n     * @return Boolean\n     */\n    function isInterleave($s1, $s2, $s3) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "class Solution {\n    func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "class Solution {\n    fun isInterleave(s1: String, s2: String, s3: String): Boolean {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "class Solution {\n  bool isInterleave(String s1, String s2, String s3) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "func isInterleave(s1 string, s2 string, s3 string) bool {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# @param {String} s1\n# @param {String} s2\n# @param {String} s3\n# @return {Boolean}\ndef is_interleave(s1, s2, s3)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "object Solution {\n    def isInterleave(s1: String, s2: String, s3: String): Boolean = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "impl Solution {\n    pub fn is_interleave(s1: String, s2: String, s3: String) -> bool {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "(define/contract (is-interleave s1 s2 s3)\n  (-> string? string? string? boolean?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "-spec is_interleave(S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary(), S3 :: unicode:unicode_binary()) -> boolean().\nis_interleave(S1, S2, S3) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "defmodule Solution do\n  @spec is_interleave(s1 :: String.t, s2 :: String.t, s3 :: String.t) :: boolean\n  def is_interleave(s1, s2, s3) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "98",
    "title": "Validate Binary Search Tree",
    "difficulty": "Medium",
    "category": "Tree",
    "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "root = [2,1,3]",
        "output": "true",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg"
        ]
      },
      {
        "input": "root = [5,1,4,null,null,3,6]",
        "output": "false",
        "explanation": "The root node's value is 5 but its right child's value is 4.",
        "images": [
          "https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "The number of nodes in the tree is in the range [1, 104].",
      "-231 <= Node.val <= 231 - 1"
    ],
    "frontendId": "98",
    "problemId": "98",
    "slug": "validate-binary-search-tree",
    "topics": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: bool\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nbool isValidBST(struct TreeNode* root) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsValidBST(TreeNode root) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction isValidBST(root: TreeNode | null): boolean {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Boolean\n     */\n    function isValidBST($root) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func isValidBST(_ root: TreeNode?) -> Bool {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun isValidBST(root: TreeNode?): Boolean {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  bool isValidBST(TreeNode? root) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isValidBST(root *TreeNode) bool {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Boolean}\ndef is_valid_bst(root)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def isValidBST(root: TreeNode): Boolean = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn is_valid_bst(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (is-valid-bst root)\n  (-> (or/c tree-node? #f) boolean?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec is_valid_bst(Root :: #tree_node{} | null) -> boolean().\nis_valid_bst(Root) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec is_valid_bst(root :: TreeNode.t | nil) :: boolean\n  def is_valid_bst(root) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "99",
    "title": "Recover Binary Search Tree",
    "difficulty": "Medium",
    "category": "Tree",
    "description": "You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.\nExample 1:\nExample 2:\nConstraints:",
    "examples": [
      {
        "input": "root = [1,3,null,null,2]",
        "output": "[3,1,null,null,2]",
        "explanation": "3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.",
        "images": [
          "https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg"
        ]
      },
      {
        "input": "root = [3,1,4,null,null,2]",
        "output": "[2,1,4,null,null,3]",
        "explanation": "2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.",
        "images": [
          "https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "The number of nodes in the tree is in the range [2, 1000].",
      "-231 <= Node.val <= 231 - 1"
    ],
    "frontendId": "99",
    "problemId": "99",
    "slug": "recover-binary-search-tree",
    "topics": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void recoverTree(TreeNode* root) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public void recoverTree(TreeNode root) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nvoid recoverTree(struct TreeNode* root) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public void RecoverTree(TreeNode root) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {void} Do not return anything, modify root in-place instead.\n */\nvar recoverTree = function(root) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n Do not return anything, modify root in-place instead.\n */\nfunction recoverTree(root: TreeNode | null): void {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return NULL\n     */\n    function recoverTree($root) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func recoverTree(_ root: TreeNode?) {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun recoverTree(root: TreeNode?): Unit {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  void recoverTree(TreeNode? root) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc recoverTree(root *TreeNode)  {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Void} Do not return anything, modify root in-place instead.\ndef recover_tree(root)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def recoverTree(root: TreeNode): Unit = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn recover_tree(root: &mut Option<Rc<RefCell<TreeNode>>>) {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (recover-tree root)\n  (-> (or/c tree-node? #f) void?)\n  )"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 170
  },
  {
    "numId": "100",
    "title": "Same Tree",
    "difficulty": "Easy",
    "category": "Tree",
    "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
    "examples": [
      {
        "input": "p = [1,2,3], q = [1,2,3]",
        "output": "true",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg"
        ]
      },
      {
        "input": "p = [1,2], q = [1,null,2]",
        "output": "false",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg"
        ]
      },
      {
        "input": "p = [1,2,1], q = [1,1,2]",
        "output": "false",
        "explanation": "",
        "images": [
          "https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg"
        ]
      }
    ],
    "privateTests": [],
    "constraints": [
      "The number of nodes in both trees is in the range [0, 100].",
      "-104 <= Node.val <= 104"
    ],
    "frontendId": "100",
    "problemId": "100",
    "slug": "same-tree",
    "topics": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "codeSnippets": {
      "cpp": {
        "name": "cpp",
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        \n    }\n};"
      },
      "java": {
        "name": "java",
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        \n    }\n}"
      },
      "python": {
        "name": "python",
        "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: Optional[TreeNode]\n        :type q: Optional[TreeNode]\n        :rtype: bool\n        \"\"\"\n        "
      },
      "python3": {
        "name": "python3",
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        "
      },
      "c": {
        "name": "c",
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nbool isSameTree(struct TreeNode* p, struct TreeNode* q) {\n    \n}"
      },
      "csharp": {
        "name": "csharp",
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsSameTree(TreeNode p, TreeNode q) {\n        \n    }\n}"
      },
      "javascript": {
        "name": "javascript",
        "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    \n};"
      },
      "typescript": {
        "name": "typescript",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n    \n};"
      },
      "php": {
        "name": "php",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $p\n     * @param TreeNode $q\n     * @return Boolean\n     */\n    function isSameTree($p, $q) {\n        \n    }\n}"
      },
      "swift": {
        "name": "swift",
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\n        \n    }\n}"
      },
      "kotlin": {
        "name": "kotlin",
        "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\n        \n    }\n}"
      },
      "dart": {
        "name": "dart",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  bool isSameTree(TreeNode? p, TreeNode? q) {\n    \n  }\n}"
      },
      "golang": {
        "name": "golang",
        "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\n    \n}"
      },
      "ruby": {
        "name": "ruby",
        "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} p\n# @param {TreeNode} q\n# @return {Boolean}\ndef is_same_tree(p, q)\n    \nend"
      },
      "scala": {
        "name": "scala",
        "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {\n        \n    }\n}"
      },
      "rust": {
        "name": "rust",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        \n    }\n}"
      },
      "racket": {
        "name": "racket",
        "code": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (is-same-tree p q)\n  (-> (or/c tree-node? #f) (or/c tree-node? #f) boolean?)\n  )"
      },
      "erlang": {
        "name": "erlang",
        "code": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec is_same_tree(P :: #tree_node{} | null, Q :: #tree_node{} | null) -> boolean().\nis_same_tree(P, Q) ->\n  ."
      },
      "elixir": {
        "name": "elixir",
        "code": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec is_same_tree(p :: TreeNode.t | nil, q :: TreeNode.t | nil) :: boolean\n  def is_same_tree(p, q) do\n    \n  end\nend"
      }
    },
    "hints": [],
    "acceptance": 0,
    "points": 100
  }
]